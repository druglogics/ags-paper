[
["index.html", "AGS paper I - Supplementary Information (SI) Intro", " AGS paper I - Supplementary Information (SI) John Zobolas Last updated: 09 May, 2020 Intro This report is the supplementary material for the AGS I Paper and has all the simulation results and investigations related to that paper, as well as guidelines for reproducing the results. A list of things that change between the simulations and the presented graphs are: The number of Gitsbe simulations: more simulations, more models generated. The type of mutation that Gitsbe models have: unless otherwise specified, the Gitsbe models have only link operator mutations. [Topology mutations] were also tested as well as a combination of [topology and link operator mutations]. The training data for the Gitsbe models: steady state (calibrated models) vs proliferative profile (proliferative models). Also randomly generated models were produced for the link operator mutations using the abmlog module. The type of mathematical model (HSA or Bliss) used in Drabme to evaluate the synergies either from the (Flobak et al. 2015) for the CASCADE 1.0 analysis or from the (Flobak et al. 2019) dataset for the CASCADE 2.0 analysis. More info on the calcualtions that Drabme does see here. The type of output used from Drabme: ensemble-wise or model-wise synergy results. For the ROC curves we used the function get_roc_stats() from (Zobolas 2020b) and for the PR curves the pr.curve() from (Grau and Keilwagen 2018) (see also (Grau, Grosse, and Keilwagen 2015)). The report template is from the rtemps R package (Zobolas 2020a). "],
["input.html", "Input", " Input Loading libraries: library(DT) library(ggpubr) library(RColorBrewer) library(xfun) library(dplyr) library(tidyr) library(tibble) library(emba) library(usefun) library(readr) library(stringr) library(latex2exp) library(corrplot) library(PRROC) library(equatiomatic) library(glmnet) library(knitr) library(MAMSE) "],
["cascade-1-0-analysis.html", "CASCADE 1.0 Analysis HSA results Bliss results Correlation Fitness Evolution", " CASCADE 1.0 Analysis Performance of automatically parameterized models against published data in (Flobak et al. 2015) HSA results HSA refers to the synergy method used in Drabme to assess the synergies from the gitsbe models We test performance using ROC and PR AUC for both the ensemble-wise and model-wise synergies from Drabme Calibrated models: fitted to steady state (\\(50\\) simulations) Proliferative models: fitted to proliferation profile (\\(50\\) simulations) Random models: produced via abmlog (see here and used in Drabme with synergy_method: hsa Gitsbe models have mutations on link operator only Load results: # &#39;ss&#39; =&gt; calibrated models, &#39;random&#39; =&gt; random models, &#39;prolif&#39; =&gt; proliferative models # &#39;ew&#39; =&gt; ensemble-wise, &#39;mw&#39; =&gt; model-wise ## HSA results ss_hsa_ew_file = paste0(&quot;results/link-only/hsa/cascade_1.0_ss_50sim_fixpoints_ensemblewise_synergies.tab&quot;) ss_hsa_mw_file = paste0(&quot;results/link-only/hsa/cascade_1.0_ss_50sim_fixpoints_modelwise_synergies.tab&quot;) prolif_hsa_ew_file = paste0(&quot;results/link-only/hsa/cascade_1.0_rand_50sim_fixpoints_ensemblewise_synergies.tab&quot;) prolif_hsa_mw_file = paste0(&quot;results/link-only/hsa/cascade_1.0_rand_50sim_fixpoints_modelwise_synergies.tab&quot;) random_hsa_ew_file = paste0(&quot;results/link-only/hsa/cascade_1.0_random_ensemblewise_synergies.tab&quot;) random_hsa_mw_file = paste0(&quot;results/link-only/hsa/cascade_1.0_random_modelwise_synergies.tab&quot;) ss_hsa_ensemblewise_synergies = emba::get_synergy_scores(ss_hsa_ew_file) ss_hsa_modelwise_synergies = emba::get_synergy_scores(ss_hsa_mw_file, file_type = &quot;modelwise&quot;) prolif_hsa_ensemblewise_synergies = emba::get_synergy_scores(prolif_hsa_ew_file) prolif_hsa_modelwise_synergies = emba::get_synergy_scores(prolif_hsa_mw_file, file_type = &quot;modelwise&quot;) random_hsa_ensemblewise_synergies = emba::get_synergy_scores(random_hsa_ew_file) random_hsa_modelwise_synergies = emba::get_synergy_scores(random_hsa_mw_file, file_type = &quot;modelwise&quot;) # calculate probability of synergy in the modelwise results ss_hsa_modelwise_synergies = ss_hsa_modelwise_synergies %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) prolif_hsa_modelwise_synergies = prolif_hsa_modelwise_synergies %&gt;% mutate(synergy_prob_prolif = synergies/(synergies + `non-synergies`)) random_hsa_modelwise_synergies = random_hsa_modelwise_synergies %&gt;% mutate(synergy_prob_random = synergies/(synergies + `non-synergies`)) observed_synergies_file = paste0(&quot;results/observed_synergies_cascade_1.0&quot;) observed_synergies = get_observed_synergies(observed_synergies_file) # 1 (positive/observed synergy) or 0 (negative/not observed) for all tested drug combinations observed = sapply(random_hsa_modelwise_synergies$perturbation %in% observed_synergies, as.integer) # &#39;ew&#39; =&gt; ensemble-wise, &#39;mw&#39; =&gt; model-wise pred_ew_hsa = bind_cols(ss_hsa_ensemblewise_synergies %&gt;% rename(ss_score = score), prolif_hsa_ensemblewise_synergies %&gt;% select(score) %&gt;% rename(prolif_score = score), random_hsa_ensemblewise_synergies %&gt;% select(score) %&gt;% rename(random_score = score), as_tibble_col(observed, column_name = &quot;observed&quot;)) pred_mw_hsa = bind_cols( ss_hsa_modelwise_synergies %&gt;% select(perturbation, synergy_prob_ss), prolif_hsa_modelwise_synergies %&gt;% select(synergy_prob_prolif), random_hsa_modelwise_synergies %&gt;% select(synergy_prob_random), as_tibble_col(observed, column_name = &quot;observed&quot;)) ROC curves res_ss_ew = get_roc_stats(df = pred_ew_hsa, pred_col = &quot;ss_score&quot;, label_col = &quot;observed&quot;) res_prolif_ew = get_roc_stats(df = pred_ew_hsa, pred_col = &quot;prolif_score&quot;, label_col = &quot;observed&quot;) res_random_ew = get_roc_stats(df = pred_ew_hsa, pred_col = &quot;random_score&quot;, label_col = &quot;observed&quot;) res_ss_mw = get_roc_stats(df = pred_mw_hsa, pred_col = &quot;synergy_prob_ss&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_prolif_mw = get_roc_stats(df = pred_mw_hsa, pred_col = &quot;synergy_prob_prolif&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_random_mw = get_roc_stats(df = pred_mw_hsa, pred_col = &quot;synergy_prob_random&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) # Plot ROCs my_palette = RColorBrewer::brewer.pal(n = 9, name = &quot;Set1&quot;) plot(x = res_ss_ew$roc_stats$FPR, y = res_ss_ew$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Ensemble-wise synergies (HSA)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = res_prolif_ew$roc_stats$FPR, y = res_prolif_ew$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = res_random_ew$roc_stats$FPR, y = res_random_ew$roc_stats$TPR, lwd = 3, col = my_palette[3]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:3], pch = 19, legend = c(paste(round(res_ss_ew$AUC, digits = 3), &quot;Calibrated&quot;), paste(round(res_prolif_ew$AUC, digits = 3), &quot;Proliferative&quot;), paste(round(res_random_ew$AUC, digits = 3), &quot;Random&quot;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) plot(x = res_ss_mw$roc_stats$FPR, y = res_ss_mw$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Model-wise synergies (HSA)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = res_prolif_mw$roc_stats$FPR, y = res_prolif_mw$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = res_random_mw$roc_stats$FPR, y = res_random_mw$roc_stats$TPR, lwd = 3, col = my_palette[3]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:3], pch = 19, legend = c(paste(round(res_ss_mw$AUC, digits = 3), &quot;Calibrated&quot;), paste(round(res_prolif_mw$AUC, digits = 3), &quot;Proliferative&quot;), paste(round(res_random_mw$AUC, digits = 3), &quot;Random&quot;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) Figure 1: ROC curves (CASCADE 1.0, HSA synergy method) PR curves pr_ss_ew_hsa = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(ss_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_prolif_ew_hsa = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(prolif_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_random_ew_hsa = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(random_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_ss_mw_hsa = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(synergy_prob_ss), weights.class0 = pred_mw_hsa %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_prolif_mw_hsa = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(synergy_prob_prolif), weights.class0 = pred_mw_hsa %&gt;% pull(observed), curve = TRUE) pr_random_mw_hsa = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(synergy_prob_random), weights.class0 = pred_mw_hsa %&gt;% pull(observed), curve = TRUE) plot(pr_ss_ew_hsa, main = &#39;PR curve, Ensemble-wise synergies (HSA)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_prolif_ew_hsa, add = TRUE, color = my_palette[2]) plot(pr_random_ew_hsa, add = TRUE, color = my_palette[3]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:3], pch = 19, legend = c(paste(round(pr_ss_ew_hsa$auc.davis.goadrich, digits = 3), &quot;Calibrated&quot;), paste(round(pr_prolif_ew_hsa$auc.davis.goadrich, digits = 3), &quot;Proliferative&quot;), paste(round(pr_random_ew_hsa$auc.davis.goadrich, digits = 3), &quot;Random&quot;))) grid(lwd = 0.5) plot(pr_ss_mw_hsa, main = &#39;PR curve, Model-wise synergies (HSA)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_prolif_mw_hsa, add = TRUE, color = my_palette[2]) plot(pr_random_mw_hsa, add = TRUE, color = my_palette[3]) legend(&#39;left&#39;, title = &#39;AUC&#39;, col = my_palette[1:3], pch = 19, legend = c(paste(round(pr_ss_mw_hsa$auc.davis.goadrich, digits = 3), &quot;Calibrated&quot;), paste(round(pr_prolif_mw_hsa$auc.davis.goadrich, digits = 3), &quot;Proliferative&quot;), paste(round(pr_random_mw_hsa$auc.davis.goadrich, digits = 3), &quot;Random&quot;))) grid(lwd = 0.5) Figure 2: PR curves (CASCADE 1.0, HSA synergy method) Calibrated models perform a lot better than either the random or proliferative ones AUC sensitivity Investigate combining the synergy results of calibrated and proliferative (random) models Quantify the amount of information from the proliferative (random) models that can be used to augment the calibrated results? Ensemble-wise scenario: \\(score = calibrated + \\beta \\times proliferative\\) (\\(random\\)) \\(\\beta \\rightarrow +\\infty\\): mostly proliferative (random) model predictions \\(\\beta \\rightarrow -\\infty\\): mostly reverse proliferative (random) model predictions \\(\\beta \\simeq -1\\): calibrated models are normalized against proliferative (random) model predictions Model-wise scenario: \\((1-w) \\times prob_{cal} + w \\times prob_{rand}, w \\in[0,1]\\) \\(w=0\\): only calibrated model predictions \\(w=1\\): only proliferative (random) model predictions # Ensemble-wise betas = seq(from = -20, to = 20, by = 0.1) random_roc = sapply(betas, function(beta) { pred_ew_hsa = pred_ew_hsa %&gt;% mutate(combined_score = ss_score + beta * random_score) res = roc.curve(scores.class0 = pred_ew_hsa %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed)) auc_value = res$auc }) prolif_roc = sapply(betas, function(beta) { pred_ew_hsa = pred_ew_hsa %&gt;% mutate(combined_score = ss_score + beta * prolif_score) res = roc.curve(scores.class0 = pred_ew_hsa %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed)) auc_value = res$auc }) random_pr = sapply(betas, function(beta) { pred_ew_hsa = pred_ew_hsa %&gt;% mutate(combined_score = ss_score + beta * random_score) res = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) prolif_pr = sapply(betas, function(beta) { pred_ew_hsa = pred_ew_hsa %&gt;% mutate(combined_score = ss_score + beta * prolif_score) res = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_ew = as_tibble(cbind(betas, random_roc, prolif_roc, random_pr, prolif_pr)) df_ew = df_ew %&gt;% tidyr::pivot_longer(-betas, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_ew, x = &quot;betas&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;$\\\\beta$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: calibrated + β x proliferative&quot;, &quot;ROC: calibrated + β x proliferative&quot;, &quot;PR: calibrated + β x random&quot;, &quot;ROC: calibrated + β x random&quot;)), title = TeX(&quot;AUC sensitivity to $\\\\beta$ parameter (HSA, CASCADE 1.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + geom_vline(xintercept = 0) + geom_vline(xintercept = -1, color = &quot;red&quot;, size = 0.3, linetype = &quot;dashed&quot;) + geom_text(aes(x=-2, label=&quot;β = -1&quot;, y=0.25), colour=&quot;black&quot;, angle=90) + grids() Figure 3: AUC sensitivity (CASCADE 1.0, HSA synergy method, Ensemble-wise results) # Model-wise weights = seq(from = 0, to = 1, by = 0.05) random_roc_mw = sapply(weights, function(w) { pred_mw_hsa = pred_mw_hsa %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_hsa$synergy_prob_ss + w * pred_mw_hsa$synergy_prob_random) res = roc.curve(scores.class0 = pred_mw_hsa %&gt;% pull(weighted_prob), weights.class0 = pred_mw_hsa %&gt;% pull(observed)) auc_value = res$auc }) prolif_roc_mw = sapply(weights, function(w) { pred_mw_hsa = pred_mw_hsa %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_hsa$synergy_prob_ss + w * pred_mw_hsa$synergy_prob_prolif) res = roc.curve(scores.class0 = pred_mw_hsa %&gt;% pull(weighted_prob), weights.class0 = pred_mw_hsa %&gt;% pull(observed)) auc_value = res$auc }) random_pr_mw = sapply(weights, function(w) { pred_mw_hsa = pred_mw_hsa %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_hsa$synergy_prob_ss + w * pred_mw_hsa$synergy_prob_random) res = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(weighted_prob), weights.class0 = pred_mw_hsa %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) prolif_pr_mw = sapply(weights, function(w) { pred_mw_hsa = pred_mw_hsa %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_hsa$synergy_prob_ss + w * pred_mw_hsa$synergy_prob_prolif) res = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(weighted_prob), weights.class0 = pred_mw_hsa %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_mw = as_tibble(cbind(weights, random_roc_mw, prolif_roc_mw, random_pr_mw, prolif_pr_mw)) df_mw = df_mw %&gt;% tidyr::pivot_longer(-weights, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_mw, x = &quot;weights&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;weight $w$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: (1-w) x prob(ss) + w x prob(prolif)&quot;, &quot;ROC: (1-w) x prob(ss) + w x prob(prolif)&quot;, &quot;PR: (1-w) x prob(ss) + w x prob(random)&quot;, &quot;ROC: (1-w) x prob(ss) + w x prob(random)&quot;)), title.position = &quot;center&quot;, title = TeX(&quot;AUC sensitivity to weighted average score (HSA, CASCADE 1.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + grids() Figure 4: AUC sensitivity (CASCADE 1.0, HSA synergy method, Model-wise results) There are \\(\\beta\\) values that can boost the predictive performance of the calibrated models (ensemble-wise) but no \\(w\\) weight in the model-wise case. \\(\\beta=-1\\) seems to be a common value that maximizes both the ROC-AUC and the PR-AUC. The PR-AUC is more sensitive than the ROC-AUC, so a better indicator of performance. Bliss results Bliss refers to the synergy method used in Drabme to assess the synergies from the gitsbe models We test performance using ROC and PR AUC for both the ensemble-wise and model-wise synergies from Drabme Calibrated models: fitted to steady state (\\(50\\) simulations) Proliferative models: fitted to proliferation profile (\\(50\\) simulations) Random models: produced via abmlog (see here and used in Drabme with synergy_method: bliss Gitsbe models have mutations on link operator only Load results: # &#39;ss&#39; =&gt; calibrated models, &#39;random&#39; =&gt; random models, &#39;prolif&#39; =&gt; proliferative models ## Bliss results ss_bliss_ensemblewise_file = paste0(&quot;results/link-only/bliss/cascade_1.0_ss_50sim_fixpoints_ensemblewise_synergies.tab&quot;) ss_bliss_modelwise_file = paste0(&quot;results/link-only/bliss/cascade_1.0_ss_50sim_fixpoints_modelwise_synergies.tab&quot;) prolif_bliss_ensemblewise_file = paste0(&quot;results/link-only/bliss/cascade_1.0_rand_50sim_fixpoints_ensemblewise_synergies.tab&quot;) prolif_bliss_modelwise_file = paste0(&quot;results/link-only/bliss/cascade_1.0_rand_50sim_fixpoints_modelwise_synergies.tab&quot;) random_bliss_ensemblewise_file = paste0(&quot;results/link-only/bliss/cascade_1.0_random_bliss_ensemblewise_synergies.tab&quot;) random_bliss_modelwise_file = paste0(&quot;results/link-only/bliss/cascade_1.0_random_bliss_modelwise_synergies.tab&quot;) ss_bliss_ensemblewise_synergies = emba::get_synergy_scores(ss_bliss_ensemblewise_file) ss_bliss_modelwise_synergies = emba::get_synergy_scores(ss_bliss_modelwise_file, file_type = &quot;modelwise&quot;) prolif_bliss_ensemblewise_synergies = emba::get_synergy_scores(prolif_bliss_ensemblewise_file) prolif_bliss_modelwise_synergies = emba::get_synergy_scores(prolif_bliss_modelwise_file, file_type = &quot;modelwise&quot;) random_bliss_ensemblewise_synergies = emba::get_synergy_scores(random_bliss_ensemblewise_file) random_bliss_modelwise_synergies = emba::get_synergy_scores(random_bliss_modelwise_file, file_type = &quot;modelwise&quot;) # calculate probability of synergy in the modelwise results ss_bliss_modelwise_synergies = ss_bliss_modelwise_synergies %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) prolif_bliss_modelwise_synergies = prolif_bliss_modelwise_synergies %&gt;% mutate(synergy_prob_prolif = synergies/(synergies + `non-synergies`)) random_bliss_modelwise_synergies = random_bliss_modelwise_synergies %&gt;% mutate(synergy_prob_random = synergies/(synergies + `non-synergies`)) # &#39;ew&#39; =&gt; ensemble-wise, &#39;mw&#39; =&gt; model-wise pred_ew_bliss = bind_cols(ss_bliss_ensemblewise_synergies %&gt;% rename(ss_score = score), prolif_bliss_ensemblewise_synergies %&gt;% select(score) %&gt;% rename(prolif_score = score), random_bliss_ensemblewise_synergies %&gt;% select(score) %&gt;% rename(random_score = score), as_tibble_col(observed, column_name = &quot;observed&quot;)) pred_mw_bliss = bind_cols( ss_bliss_modelwise_synergies %&gt;% select(perturbation, synergy_prob_ss), prolif_bliss_modelwise_synergies %&gt;% select(synergy_prob_prolif), random_bliss_modelwise_synergies %&gt;% select(synergy_prob_random), as_tibble_col(observed, column_name = &quot;observed&quot;)) ROC curves res_ss_ew = get_roc_stats(df = pred_ew_bliss, pred_col = &quot;ss_score&quot;, label_col = &quot;observed&quot;) res_prolif_ew = get_roc_stats(df = pred_ew_bliss, pred_col = &quot;prolif_score&quot;, label_col = &quot;observed&quot;) res_random_ew = get_roc_stats(df = pred_ew_bliss, pred_col = &quot;random_score&quot;, label_col = &quot;observed&quot;) res_ss_mw = get_roc_stats(df = pred_mw_bliss, pred_col = &quot;synergy_prob_ss&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_prolif_mw = get_roc_stats(df = pred_mw_bliss, pred_col = &quot;synergy_prob_prolif&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_random_mw = get_roc_stats(df = pred_mw_bliss, pred_col = &quot;synergy_prob_random&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) # Plot ROCs plot(x = res_ss_ew$roc_stats$FPR, y = res_ss_ew$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Ensemble-wise synergies (Bliss)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = res_prolif_ew$roc_stats$FPR, y = res_prolif_ew$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = res_random_ew$roc_stats$FPR, y = res_random_ew$roc_stats$TPR, lwd = 3, col = my_palette[3]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:3], pch = 19, legend = c(paste(round(res_ss_ew$AUC, digits = 3), &quot;Calibrated&quot;), paste(round(res_prolif_ew$AUC, digits = 3), &quot;Proliferative&quot;), paste(round(res_random_ew$AUC, digits = 3), &quot;Random&quot;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) plot(x = res_ss_mw$roc_stats$FPR, y = res_ss_mw$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Model-wise synergies (Bliss)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = res_prolif_mw$roc_stats$FPR, y = res_prolif_mw$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = res_random_mw$roc_stats$FPR, y = res_random_mw$roc_stats$TPR, lwd = 3, col = my_palette[3]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:3], pch = 19, legend = c(paste(round(res_ss_mw$AUC, digits = 3), &quot;Calibrated&quot;), paste(round(res_prolif_mw$AUC, digits = 3), &quot;Proliferative&quot;), paste(round(res_random_mw$AUC, digits = 3), &quot;Random&quot;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) Figure 5: ROC curves (CASCADE 1.0, Bliss synergy method) PR curves pr_ss_ew_bliss = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(ss_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_prolif_ew_bliss = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(prolif_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_random_ew_bliss = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(random_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_ss_mw_bliss = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(synergy_prob_ss), weights.class0 = pred_mw_bliss %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_prolif_mw_bliss = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(synergy_prob_prolif), weights.class0 = pred_mw_bliss %&gt;% pull(observed), curve = TRUE) pr_random_mw_bliss = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(synergy_prob_random), weights.class0 = pred_mw_bliss %&gt;% pull(observed), curve = TRUE) plot(pr_ss_ew_bliss, main = &#39;PR curve, Ensemble-wise synergies (Bliss)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_prolif_ew_bliss, add = TRUE, color = my_palette[2]) plot(pr_random_ew_bliss, add = TRUE, color = my_palette[3]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:3], pch = 19, cex = 0.65, legend = c(paste(round(pr_ss_ew_bliss$auc.davis.goadrich, digits = 3), &quot;Calibrated&quot;), paste(round(pr_prolif_ew_bliss$auc.davis.goadrich, digits = 3), &quot;Proliferative&quot;), paste(round(pr_random_ew_bliss$auc.davis.goadrich, digits = 3), &quot;Random&quot;))) grid(lwd = 0.5) plot(pr_ss_mw_bliss, main = &#39;PR curve, Model-wise synergies (Bliss)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_prolif_mw_bliss, add = TRUE, color = my_palette[2]) plot(pr_random_mw_bliss, add = TRUE, color = my_palette[3]) legend(&#39;left&#39;, title = &#39;AUC&#39;, col = my_palette[1:3], pch = 19, cex = 0.8, legend = c(paste(round(pr_ss_mw_bliss$auc.davis.goadrich, digits = 3), &quot;Calibrated&quot;), paste(round(pr_prolif_mw_bliss$auc.davis.goadrich, digits = 3), &quot;Proliferative&quot;), paste(round(pr_random_mw_bliss$auc.davis.goadrich, digits = 3), &quot;Random&quot;))) grid(lwd = 0.5) Figure 6: PR curves (CASCADE 1.0, Bliss synergy method) Calibrated models perform a lot better than either the random or proliferative ones AUC sensitivity Investigate same thing as described in here. # Ensemble-wise betas = seq(from = -20, to = 20, by = 0.1) random_roc = sapply(betas, function(beta) { pred_ew_bliss = pred_ew_bliss %&gt;% mutate(combined_score = ss_score + beta * random_score) res = roc.curve(scores.class0 = pred_ew_bliss %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed)) auc_value = res$auc }) prolif_roc = sapply(betas, function(beta) { pred_ew_bliss = pred_ew_bliss %&gt;% mutate(combined_score = ss_score + beta * prolif_score) res = roc.curve(scores.class0 = pred_ew_bliss %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed)) auc_value = res$auc }) random_pr = sapply(betas, function(beta) { pred_ew_bliss = pred_ew_bliss %&gt;% mutate(combined_score = ss_score + beta * random_score) res = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) prolif_pr = sapply(betas, function(beta) { pred_ew_bliss = pred_ew_bliss %&gt;% mutate(combined_score = ss_score + beta * prolif_score) res = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_ew = as_tibble(cbind(betas, random_roc, prolif_roc, random_pr, prolif_pr)) df_ew = df_ew %&gt;% tidyr::pivot_longer(-betas, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_ew, x = &quot;betas&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;$\\\\beta$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: calibrated + β x proliferative&quot;, &quot;ROC: calibrated + β x proliferative&quot;, &quot;PR: calibrated + β x random&quot;, &quot;ROC: calibrated + β x random&quot;)), title = TeX(&quot;AUC sensitivity to $\\\\beta$ parameter (Bliss, CASCADE 1.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + geom_vline(xintercept = 0) + geom_vline(xintercept = -1, color = &quot;red&quot;, size = 0.3, linetype = &quot;dashed&quot;) + geom_text(aes(x=-2, label=&quot;β = -1&quot;, y=0.25), colour=&quot;black&quot;, angle=90) + grids() Figure 7: AUC sensitivity (CASCADE 1.0, Bliss synergy method, Ensemble-wise results) # Model-wise weights = seq(from = 0, to = 1, by = 0.05) random_roc_mw = sapply(weights, function(w) { pred_mw_bliss = pred_mw_bliss %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_bliss$synergy_prob_ss + w * pred_mw_bliss$synergy_prob_random) res = roc.curve(scores.class0 = pred_mw_bliss %&gt;% pull(weighted_prob), weights.class0 = pred_mw_bliss %&gt;% pull(observed)) auc_value = res$auc }) prolif_roc_mw = sapply(weights, function(w) { pred_mw_bliss = pred_mw_bliss %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_bliss$synergy_prob_ss + w * pred_mw_bliss$synergy_prob_prolif) res = roc.curve(scores.class0 = pred_mw_bliss %&gt;% pull(weighted_prob), weights.class0 = pred_mw_bliss %&gt;% pull(observed)) auc_value = res$auc }) random_pr_mw = sapply(weights, function(w) { pred_mw_bliss = pred_mw_bliss %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_bliss$synergy_prob_ss + w * pred_mw_bliss$synergy_prob_random) res = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(weighted_prob), weights.class0 = pred_mw_bliss %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) prolif_pr_mw = sapply(weights, function(w) { pred_mw_bliss = pred_mw_bliss %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_bliss$synergy_prob_ss + w * pred_mw_bliss$synergy_prob_prolif) res = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(weighted_prob), weights.class0 = pred_mw_bliss %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_mw = as_tibble(cbind(weights, random_roc_mw, prolif_roc_mw, random_pr_mw, prolif_pr_mw)) df_mw = df_mw %&gt;% tidyr::pivot_longer(-weights, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_mw, x = &quot;weights&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;weight $w$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: (1-w) x prob(ss) + w x prob(prolif)&quot;, &quot;ROC: (1-w) x prob(ss) + w x prob(prolif)&quot;, &quot;PR: (1-w) x prob(ss) + w x prob(random)&quot;, &quot;ROC: (1-w) x prob(ss) + w x prob(random)&quot;)), title.position = &quot;center&quot;, title = TeX(&quot;AUC sensitivity to weighted average score (Bliss, CASCADE 1.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + grids() Figure 8: AUC sensitivity (CASCADE 1.0, Bliss synergy method, Model-wise results) There are \\(\\beta\\) values that can boost the predictive performance of the calibrated models (ensemble-wise) but no \\(w\\) weight in the model-wise case. \\(\\beta=-1\\) seems to be a common value that maximizes both the ROC-AUC and the PR-AUC. The PR-AUC is more sensitive than the ROC-AUC, so a better indicator of performance. Correlation We test for correlation between all the synergy predictor results shown in the previous curves. This means ensemble-wise vs model-wise, random models vs proliferative vs calibrated (ss) models and HSA vs Bliss synergy assessment. P-values are represented at 3 significant levels: \\(0.05, 0.01, 0.001\\) (*, **, ***) and the correlation coefficient is calculated using Kendall’s tau statistic. synergy_scores = bind_cols( pred_ew_hsa %&gt;% select(ss_score, prolif_score, random_score) %&gt;% rename(ss_ew_hsa = ss_score, prolif_ew_hsa = prolif_score, random_ew_hsa = random_score), pred_ew_bliss %&gt;% select(ss_score, prolif_score, random_score) %&gt;% rename(ss_ew_bliss = ss_score, prolif_ew_bliss = prolif_score, random_ew_bliss = random_score), pred_mw_hsa %&gt;% select(synergy_prob_ss, synergy_prob_prolif, synergy_prob_random) %&gt;% rename(ss_mw_hsa = synergy_prob_ss, prolif_mw_hsa = synergy_prob_prolif, random_mw_hsa = synergy_prob_random), pred_mw_bliss %&gt;% select(synergy_prob_ss, synergy_prob_prolif, synergy_prob_random) %&gt;% rename(ss_mw_bliss = synergy_prob_ss, prolif_mw_bliss = synergy_prob_prolif, random_mw_bliss = synergy_prob_random) ) M = cor(synergy_scores, method = &quot;kendall&quot;) res = cor.mtest(synergy_scores, method = &quot;kendall&quot;) corrplot(corr = M, type = &quot;upper&quot;, p.mat = res$p, sig.level = c(.001, .01, .05), pch.cex = 1, pch.col = &quot;white&quot;, insig = &quot;label_sig&quot;, tl.col = &quot;black&quot;, tl.srt = 45) Figure 9: Correlation Plot for CASCADE 1.0 Results Model-wise don’t correlate at all with ensemble-wise results (topright part of the correlation plot). HSA and Bliss results correlate, higher for the model-wise (bottomright) than the ensemble-wise results (topleft). Calibrated results don’t correlate with either random or proliferative results in most cases, while there is stronger correlation between the proliferative and random models results. Fitness Evolution Results are from the simulation result with \\(50\\) Gitsbe simulations, fitting to steady state (calibrated models) and HSA Drabme synergy assessment. We show only \\(10\\) simulations - the first ones that spanned the maximum defined generations in the configuration (\\(20\\)), meaning that they did not surpass the target fitness threhold specified (\\(0.99\\)). Each data point is the average fitness in that generation out of \\(20\\) models. fitness_summary_file = paste0(&quot;results/hsa/cascade_1.0_ss_50sim_fixpoints_summary.txt&quot;) read_summary_file = function(file_name) { lines = readr::read_lines(file = fitness_summary_file, skip = 5, skip_empty_rows = TRUE) data_list = list() index = 1 gen_fit_list = list() gen_index = 1 for (line_index in 1:length(lines)) { line = lines[line_index] if (stringr::str_detect(string = line, pattern = &quot;Simulation&quot;)) { data_list[[index]] = bind_cols(gen_fit_list) index = index + 1 gen_fit_list = list() gen_index = 1 } else { # read fitness values gen_fit_list[[gen_index]] = as_tibble_col(as.numeric(unlist(strsplit(line, split = &#39;\\t&#39;)))) gen_index = gen_index + 1 } } # add the last simulation&#39;s values data_list[[index]] = bind_cols(gen_fit_list) return(data_list) } fit_res = read_summary_file(file_name = fitness_summary_file) first_sim_data = colMeans(fit_res[[1]]) plot(1:length(first_sim_data), y = first_sim_data, ylim = c(0,1), xlim = c(0,20), type = &#39;l&#39;, lwd = 1.5, main = &#39;Fitness vs Generation (10 Simulations)&#39;, xlab = &#39;Generations&#39;, ylab = &#39;Average Fitness&#39;, col = usefun:::colors.100[1]) index = 2 for (fit_data in fit_res) { if (index &gt; 10) break if (ncol(fit_data) != 20) next mean_fit_per_gen = colMeans(fit_data) lines(x = 1:length(mean_fit_per_gen), y = mean_fit_per_gen, lwd = 1.5, col = usefun:::colors.100[index]) index = index + 1 } grid(lwd = 0.5) Figure 10: Fitness Evolution (CASCADE 1.0, HSA Results) "],
["cascade-2-0-analysis-link-operator-mutations.html", "CASCADE 2.0 Analysis (Link Operator Mutations) HSA results Bliss results Correlation Fitness vs Performance", " CASCADE 2.0 Analysis (Link Operator Mutations) Performance of automatically parameterized models against SINTEF dataset (Flobak et al. 2019) HSA results HSA refers to the synergy method used in Drabme to assess the synergies from the gitsbe models We test performance using ROC and PR AUC for both the ensemble-wise and model-wise synergies from Drabme Calibrated models: fitted to steady state (\\(50,100,150,200\\) simulations) Proliferative models: fitted to proliferation profile (\\(150\\) simulations) Random models: produced via abmlog (see here and used in Drabme with synergy_method: hsa Gitsbe models have mutations on link operator only Load results: # &#39;ss&#39; =&gt; calibrated models, &#39;random&#39; =&gt; random models, &#39;prolif&#39; =&gt; proliferative models # &#39;ew&#39; =&gt; ensemble-wise, &#39;mw&#39; =&gt; model-wise ## HSA results ss_hsa_ensemblewise_50sim_file = paste0(&quot;results/link-only/hsa/cascade_2.0_ss_50sim_fixpoints_ensemblewise_synergies.tab&quot;) ss_hsa_modelwise_50sim_file = paste0(&quot;results/link-only/hsa/cascade_2.0_ss_50sim_fixpoints_modelwise_synergies.tab&quot;) ss_hsa_ensemblewise_100sim_file = paste0(&quot;results/link-only/hsa/cascade_2.0_ss_100sim_fixpoints_ensemblewise_synergies.tab&quot;) ss_hsa_modelwise_100sim_file = paste0(&quot;results/link-only/hsa/cascade_2.0_ss_100sim_fixpoints_modelwise_synergies.tab&quot;) ss_hsa_ensemblewise_150sim_file = paste0(&quot;results/link-only/hsa/cascade_2.0_ss_150sim_fixpoints_ensemblewise_synergies.tab&quot;) ss_hsa_modelwise_150sim_file = paste0(&quot;results/link-only/hsa/cascade_2.0_ss_150sim_fixpoints_modelwise_synergies.tab&quot;) ss_hsa_ensemblewise_200sim_file = paste0(&quot;results/link-only/hsa/cascade_2.0_ss_200sim_fixpoints_ensemblewise_synergies.tab&quot;) ss_hsa_modelwise_200sim_file = paste0(&quot;results/link-only/hsa/cascade_2.0_ss_200sim_fixpoints_modelwise_synergies.tab&quot;) prolif_hsa_ensemblewise_file = paste0(&quot;results/link-only/hsa/cascade_2.0_rand_150sim_fixpoints_hsa_ensemblewise_synergies.tab&quot;) prolif_hsa_modelwise_file = paste0(&quot;results/link-only/hsa/cascade_2.0_rand_150sim_fixpoints_hsa_modelwise_synergies.tab&quot;) random_hsa_ensemblewise_file = paste0(&quot;results/link-only/hsa/cascade_2.0_random_ensemblewise_synergies.tab&quot;) random_hsa_modelwise_file = paste0(&quot;results/link-only/hsa/cascade_2.0_random_modelwise_synergies.tab&quot;) ss_hsa_ensemblewise_synergies_50sim = emba::get_synergy_scores(ss_hsa_ensemblewise_50sim_file) ss_hsa_modelwise_synergies_50sim = emba::get_synergy_scores(ss_hsa_modelwise_50sim_file, file_type = &quot;modelwise&quot;) ss_hsa_ensemblewise_synergies_100sim = emba::get_synergy_scores(ss_hsa_ensemblewise_100sim_file) ss_hsa_modelwise_synergies_100sim = emba::get_synergy_scores(ss_hsa_modelwise_100sim_file, file_type = &quot;modelwise&quot;) ss_hsa_ensemblewise_synergies_150sim = emba::get_synergy_scores(ss_hsa_ensemblewise_150sim_file) ss_hsa_modelwise_synergies_150sim = emba::get_synergy_scores(ss_hsa_modelwise_150sim_file, file_type = &quot;modelwise&quot;) ss_hsa_ensemblewise_synergies_200sim = emba::get_synergy_scores(ss_hsa_ensemblewise_200sim_file) ss_hsa_modelwise_synergies_200sim = emba::get_synergy_scores(ss_hsa_modelwise_200sim_file, file_type = &quot;modelwise&quot;) prolif_hsa_ensemblewise_synergies_150sim = emba::get_synergy_scores(prolif_hsa_ensemblewise_file) prolif_hsa_modelwise_synergies_150sim = emba::get_synergy_scores(prolif_hsa_modelwise_file, file_type = &quot;modelwise&quot;) random_hsa_ensemblewise_synergies = emba::get_synergy_scores(random_hsa_ensemblewise_file) random_hsa_modelwise_synergies = emba::get_synergy_scores(random_hsa_modelwise_file, file_type = &quot;modelwise&quot;) # calculate probability of synergy in the modelwise results ss_hsa_modelwise_synergies_50sim = ss_hsa_modelwise_synergies_50sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) ss_hsa_modelwise_synergies_100sim = ss_hsa_modelwise_synergies_100sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) ss_hsa_modelwise_synergies_150sim = ss_hsa_modelwise_synergies_150sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) ss_hsa_modelwise_synergies_200sim = ss_hsa_modelwise_synergies_200sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) prolif_hsa_modelwise_synergies_150sim = prolif_hsa_modelwise_synergies_150sim %&gt;% mutate(synergy_prob_prolif = synergies/(synergies + `non-synergies`)) random_hsa_modelwise_synergies = random_hsa_modelwise_synergies %&gt;% mutate(synergy_prob_random = synergies/(synergies + `non-synergies`)) observed_synergies_file = paste0(&quot;results/observed_synergies_cascade_2.0&quot;) observed_synergies = get_observed_synergies(observed_synergies_file) # 1 (positive/observed synergy) or 0 (negative/not observed) for all tested drug combinations observed = sapply(random_hsa_modelwise_synergies$perturbation %in% observed_synergies, as.integer) # &#39;ew&#39; =&gt; ensemble-wise, &#39;mw&#39; =&gt; model-wise pred_ew_hsa = bind_cols( ss_hsa_ensemblewise_synergies_50sim %&gt;% select(score) %&gt;% rename(ss_score_50sim = score), ss_hsa_ensemblewise_synergies_100sim %&gt;% select(score) %&gt;% rename(ss_score_100sim = score), ss_hsa_ensemblewise_synergies_150sim %&gt;% select(score) %&gt;% rename(ss_score_150sim = score), ss_hsa_ensemblewise_synergies_200sim %&gt;% select(score) %&gt;% rename(ss_score_200sim = score), prolif_hsa_ensemblewise_synergies_150sim %&gt;% select(score) %&gt;% rename(prolif_score_150sim = score), random_hsa_ensemblewise_synergies %&gt;% select(score) %&gt;% rename(random_score = score), as_tibble_col(observed, column_name = &quot;observed&quot;)) pred_mw_hsa = bind_cols( ss_hsa_modelwise_synergies_50sim %&gt;% select(perturbation, synergy_prob_ss) %&gt;% rename(synergy_prob_ss_50sim = synergy_prob_ss), ss_hsa_modelwise_synergies_100sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_ss_100sim = synergy_prob_ss), ss_hsa_modelwise_synergies_150sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_ss_150sim = synergy_prob_ss), ss_hsa_modelwise_synergies_200sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_ss_200sim = synergy_prob_ss), prolif_hsa_modelwise_synergies_150sim %&gt;% select(synergy_prob_prolif) %&gt;% rename(synergy_prob_prolif_150sim = synergy_prob_prolif), random_hsa_modelwise_synergies %&gt;% select(synergy_prob_random), as_tibble_col(observed, column_name = &quot;observed&quot;)) ROC curves res_ss_ew_50sim = get_roc_stats(df = pred_ew_hsa, pred_col = &quot;ss_score_50sim&quot;, label_col = &quot;observed&quot;) res_ss_ew_100sim = get_roc_stats(df = pred_ew_hsa, pred_col = &quot;ss_score_100sim&quot;, label_col = &quot;observed&quot;) res_ss_ew_150sim = get_roc_stats(df = pred_ew_hsa, pred_col = &quot;ss_score_150sim&quot;, label_col = &quot;observed&quot;) res_ss_ew_200sim = get_roc_stats(df = pred_ew_hsa, pred_col = &quot;ss_score_200sim&quot;, label_col = &quot;observed&quot;) res_prolif_ew_150sim = get_roc_stats(df = pred_ew_hsa, pred_col = &quot;prolif_score_150sim&quot;, label_col = &quot;observed&quot;) res_random_ew = get_roc_stats(df = pred_ew_hsa, pred_col = &quot;random_score&quot;, label_col = &quot;observed&quot;) res_ss_mw_50sim = get_roc_stats(df = pred_mw_hsa, pred_col = &quot;synergy_prob_ss_50sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_ss_mw_100sim = get_roc_stats(df = pred_mw_hsa, pred_col = &quot;synergy_prob_ss_100sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_ss_mw_150sim = get_roc_stats(df = pred_mw_hsa, pred_col = &quot;synergy_prob_ss_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_ss_mw_200sim = get_roc_stats(df = pred_mw_hsa, pred_col = &quot;synergy_prob_ss_200sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_prolif_mw_150sim = get_roc_stats(df = pred_mw_hsa, pred_col = &quot;synergy_prob_prolif_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_random_mw = get_roc_stats(df = pred_mw_hsa, pred_col = &quot;synergy_prob_random&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) # Plot ROCs plot(x = res_ss_ew_50sim$roc_stats$FPR, y = res_ss_ew_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Ensemble-wise synergies (HSA)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = res_ss_ew_100sim$roc_stats$FPR, y = res_ss_ew_100sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = res_ss_ew_150sim$roc_stats$FPR, y = res_ss_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = res_ss_ew_200sim$roc_stats$FPR, y = res_ss_ew_200sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) lines(x = res_prolif_ew_150sim$roc_stats$FPR, y = res_prolif_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[5]) lines(x = res_random_ew$roc_stats$FPR, y = res_random_ew$roc_stats$TPR, lwd = 3, col = my_palette[6]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:6], pch = 19, legend = c(paste(round(res_ss_ew_50sim$AUC, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(res_ss_ew_100sim$AUC, digits = 3), &quot;Calibrated (100 sim)&quot;), paste(round(res_ss_ew_150sim$AUC, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(res_ss_ew_200sim$AUC, digits = 3), &quot;Calibrated (200 sim)&quot;), paste(round(res_prolif_ew_150sim$AUC, digits = 3), &quot;Proliferative (150 sim)&quot;), paste(round(res_random_ew$AUC, digits = 3), &quot;Random&quot;)), cex = 0.9) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) plot(x = res_ss_mw_50sim$roc_stats$FPR, y = res_ss_mw_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Model-wise synergies (HSA)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = res_ss_mw_100sim$roc_stats$FPR, y = res_ss_mw_100sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = res_ss_mw_150sim$roc_stats$FPR, y = res_ss_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = res_ss_mw_200sim$roc_stats$FPR, y = res_ss_mw_200sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) lines(x = res_prolif_mw_150sim$roc_stats$FPR, y = res_prolif_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[5]) lines(x = res_random_mw$roc_stats$FPR, y = res_random_mw$roc_stats$TPR, lwd = 3, col = my_palette[6]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:6], pch = 19, legend = c(paste(round(res_ss_mw_50sim$AUC, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(res_ss_mw_100sim$AUC, digits = 3), &quot;Calibrated (100 sim)&quot;), paste(round(res_ss_mw_150sim$AUC, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(res_ss_mw_200sim$AUC, digits = 3), &quot;Calibrated (200 sim)&quot;), paste(round(res_prolif_mw_150sim$AUC, digits = 3), &quot;Proliferative (150 sim)&quot;), paste(round(res_random_mw$AUC, digits = 3), &quot;Random&quot;)), cex = 0.9) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) Figure 11: ROC curves (CASCADE 2.0, HSA synergy method) PR curves pr_ss_ew_hsa_50sim = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(ss_score_50sim) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_ss_ew_hsa_100sim = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(ss_score_100sim) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_ss_ew_hsa_150sim = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(ss_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_ss_ew_hsa_200sim = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(ss_score_200sim) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_prolif_ew_hsa_150sim = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(prolif_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_random_ew_hsa = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(random_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_ss_mw_hsa_50sim = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(synergy_prob_ss_50sim), weights.class0 = pred_mw_hsa %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_ss_mw_hsa_100sim = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(synergy_prob_ss_100sim), weights.class0 = pred_mw_hsa %&gt;% pull(observed), curve = TRUE) pr_ss_mw_hsa_150sim = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(synergy_prob_ss_150sim), weights.class0 = pred_mw_hsa %&gt;% pull(observed), curve = TRUE) pr_ss_mw_hsa_200sim = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(synergy_prob_ss_200sim), weights.class0 = pred_mw_hsa %&gt;% pull(observed), curve = TRUE) pr_prolif_mw_hsa_150sim = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(synergy_prob_prolif_150sim), weights.class0 = pred_mw_hsa %&gt;% pull(observed), curve = TRUE) pr_random_mw_hsa = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(synergy_prob_random), weights.class0 = pred_mw_hsa %&gt;% pull(observed), curve = TRUE) plot(pr_ss_ew_hsa_50sim, main = &#39;PR curve, Ensemble-wise synergies (HSA)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_ss_ew_hsa_100sim, add = TRUE, color = my_palette[2]) plot(pr_ss_ew_hsa_150sim, add = TRUE, color = my_palette[3]) plot(pr_ss_ew_hsa_200sim, add = TRUE, color = my_palette[4]) plot(pr_prolif_ew_hsa_150sim, add = TRUE, color = my_palette[5]) plot(pr_random_ew_hsa, add = TRUE, color = my_palette[6]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:6], pch = 19, legend = c(paste(round(pr_ss_ew_hsa_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_ss_ew_hsa_100sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (100 sim)&quot;), paste(round(pr_ss_ew_hsa_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_ss_ew_hsa_200sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (200 sim)&quot;), paste(round(pr_prolif_ew_hsa_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (150 sim)&quot;), paste(round(pr_random_ew_hsa$auc.davis.goadrich, digits = 3), &quot;Random&quot;))) grid(lwd = 0.5) plot(pr_ss_mw_hsa_50sim, main = &#39;PR curve, Model-wise synergies (HSA)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_ss_mw_hsa_100sim, add = TRUE, color = my_palette[2]) plot(pr_ss_mw_hsa_150sim, add = TRUE, color = my_palette[3]) plot(pr_ss_mw_hsa_200sim, add = TRUE, color = my_palette[4]) plot(pr_prolif_mw_hsa_150sim, add = TRUE, color = my_palette[5]) plot(pr_random_mw_hsa, add = TRUE, color = my_palette[6]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:6], pch = 19, legend = c(paste(round(pr_ss_mw_hsa_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_ss_mw_hsa_100sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (100 sim)&quot;), paste(round(pr_ss_mw_hsa_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_ss_mw_hsa_200sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (200 sim)&quot;), paste(round(pr_prolif_mw_hsa_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (200 sim)&quot;), paste(round(pr_random_mw_hsa$auc.davis.goadrich, digits = 3), &quot;Random&quot;))) grid(lwd = 0.5) Figure 12: PR curves (CASCADE 2.0, HSA synergy method) To minimize the resulting performance variance, \\(150\\) seems to be a good number of Gitsbe simulations to run for the CASCADE 2.0 network. The PR curves show that the performance of each individual predictor is poor compared to the baseline. Someone looking at the ROC curves only might reach a different conclusion. Proliferative and random models perform almost equally well to calibrated models. The model-wise approach produces slightly better ROC results than the ensemble-wise approach AUC sensitivity Investigate same thing as described in here. This is very crucial since the PR performance is poor for the individual predictors, but a combined predictor might be able to counter this. We will combine the synergy scores from the random and proliferative simulations with the results from the calibrated Gitsbe simulations (\\(150\\)). # Ensemble-wise betas = seq(from = -7.5, to = 7.5, by = 0.1) random_roc = sapply(betas, function(beta) { pred_ew_hsa = pred_ew_hsa %&gt;% mutate(combined_score = ss_score_150sim + beta * random_score) res = roc.curve(scores.class0 = pred_ew_hsa %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed)) auc_value = res$auc }) prolif_roc = sapply(betas, function(beta) { pred_ew_hsa = pred_ew_hsa %&gt;% mutate(combined_score = ss_score_150sim + beta * prolif_score_150sim) res = roc.curve(scores.class0 = pred_ew_hsa %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed)) auc_value = res$auc }) random_pr = sapply(betas, function(beta) { pred_ew_hsa = pred_ew_hsa %&gt;% mutate(combined_score = ss_score_150sim + beta * random_score) res = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) prolif_pr = sapply(betas, function(beta) { pred_ew_hsa = pred_ew_hsa %&gt;% mutate(combined_score = ss_score_150sim + beta * prolif_score_150sim) res = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_ew = as_tibble(cbind(betas, random_roc, prolif_roc, random_pr, prolif_pr)) df_ew = df_ew %&gt;% tidyr::pivot_longer(-betas, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_ew, x = &quot;betas&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;$\\\\beta$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: calibrated + β x proliferative&quot;, &quot;ROC: calibrated + β x proliferative&quot;, &quot;PR: calibrated + β x random&quot;, &quot;ROC: calibrated + β x random&quot;)), title = TeX(&quot;AUC sensitivity to $\\\\beta$ parameter (HSA, CASCADE 2.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + geom_vline(xintercept = 0) + geom_vline(xintercept = -1, color = &quot;red&quot;, size = 0.3, linetype = &quot;dashed&quot;) + geom_text(aes(x=-1.5, label=&quot;β = -1&quot;, y=0.25), colour=&quot;black&quot;, angle=90) + grids() Figure 13: AUC sensitivity (CASCADE 2.0, HSA synergy method, Ensemble-wise results) # Model-wise weights = seq(from = 0, to = 1, by = 0.05) random_roc_mw = sapply(weights, function(w) { pred_mw_hsa = pred_mw_hsa %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_hsa$synergy_prob_ss_150sim + w * pred_mw_hsa$synergy_prob_random) res = roc.curve(scores.class0 = pred_mw_hsa %&gt;% pull(weighted_prob), weights.class0 = pred_mw_hsa %&gt;% pull(observed)) auc_value = res$auc }) prolif_roc_mw = sapply(weights, function(w) { pred_mw_hsa = pred_mw_hsa %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_hsa$synergy_prob_ss_150sim + w * pred_mw_hsa$synergy_prob_prolif_150sim) res = roc.curve(scores.class0 = pred_mw_hsa %&gt;% pull(weighted_prob), weights.class0 = pred_mw_hsa %&gt;% pull(observed)) auc_value = res$auc }) random_pr_mw = sapply(weights, function(w) { pred_mw_hsa = pred_mw_hsa %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_hsa$synergy_prob_ss_150sim + w * pred_mw_hsa$synergy_prob_random) res = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(weighted_prob), weights.class0 = pred_mw_hsa %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) prolif_pr_mw = sapply(weights, function(w) { pred_mw_hsa = pred_mw_hsa %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_hsa$synergy_prob_ss_150sim + w * pred_mw_hsa$synergy_prob_prolif_150sim) res = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(weighted_prob), weights.class0 = pred_mw_hsa %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_mw = as_tibble(cbind(weights, random_roc_mw, prolif_roc_mw, random_pr_mw, prolif_pr_mw)) df_mw = df_mw %&gt;% tidyr::pivot_longer(-weights, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_mw, x = &quot;weights&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;weight $w$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: (1-w) x prob(ss) + w x prob(prolif)&quot;, &quot;ROC: (1-w) x prob(ss) + w x prob(prolif)&quot;, &quot;PR: (1-w) x prob(ss) + w x prob(random)&quot;, &quot;ROC: (1-w) x prob(ss) + w x prob(random)&quot;)), title.position = &quot;center&quot;, title = TeX(&quot;AUC sensitivity to weighted average score (HSA, CASCADE 2.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + grids() Figure 14: AUC sensitivity (CASCADE 2.0, HSA synergy method, Model-wise results) No added benefit when using the model-wise approach. Neither the random nor the proliferative models bring any significant change to the prediction performance of the calibrated models (ensemble-wise). Only the proliferative models seem to add a small contribution to the calibrated models performance (top-right panel =&gt; ROC-AUC increases, PR-AUC is insignificantly changed nonetheless). The \\(\\beta_{best}\\) that maximizes the ROC and PR AUC for the combination of proliferative and calibrated models and is equal to \\(\\beta_{best}=-0.3\\). For \\(\\beta=-1\\) we do not observe performance improvement in this case. Logistic Regression We tried fitting a model using logistic regression as a different approach to combine/augment the results from calibrated simulations with the proliferative ones (for the HSA-assessed ensemble-wise results where there was a minimal benefit). model = glm(formula = observed ~ ss_score_150sim + prolif_score_150sim - 1, data = pred_ew_hsa, family = binomial()) model_tidy = broom::tidy(model) coef1 = model_tidy %&gt;% filter(term == &quot;ss_score_150sim&quot;) %&gt;% pull(estimate) coef2 = model_tidy %&gt;% filter(term == &quot;prolif_score_150sim&quot;) %&gt;% pull(estimate) pred_ew_hsa = pred_ew_hsa %&gt;% mutate(glm = coef1 * ss_score_150sim + coef2 * prolif_score_150sim) res_roc = get_roc_stats(df = pred_ew_hsa, pred_col = &quot;glm&quot;, label_col = &quot;observed&quot;) res_pr = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(glm) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed)) The model with the coefficients is as follows (note that adding an intercept makes ROC AUC result considerably worse): extract_eq(model, use_coefs = TRUE) \\[ \\log\\left[ \\frac { P( \\text{observed} = \\text{1} ) }{ 1 - P( \\text{observed} = \\text{1} ) } \\right] = -10.63(\\text{ss\\_score\\_150sim}) + 42.92(\\text{prolif\\_score\\_150sim}) + \\epsilon \\] The ROC AUC produced with a logistic regression model is lower than the calibrated models (with \\(150\\) Gitsbe simulations): 0.5782313 (PR-AUC is also lower: 0.0527052). Regularized Logistic Regression Because the coefficient values found from the above approach are large, we try a regularized logistic regression approach using the glmnet R package (Friedman et al. 2019). We cross validate the \\(\\lambda\\) parameter and try with different \\(\\alpha \\in [0,1]\\) (\\(\\alpha=0\\) means Ridge regression, \\(\\alpha=1\\) means LASSO, in between means Elastic net) while either minimizing the missclassification error (type.measure=\"class\") or maximizing the ROC-AUC (type.measure = \"auc\"). For each respective \\(\\alpha\\) we choose the \\(\\lambda_{min}\\) as the one the minimizes the average CV error. The intercept was again excluded as it resulted in worse AUC performance. x = pred_ew_hsa %&gt;% select(ss_score_150sim, prolif_score_150sim) %&gt;% as.matrix() y = pred_ew_hsa %&gt;% pull(observed) data_list = list() index = 1 for (i in 0:10) { # from Ridge to LASSO a = i/10 for (measure in c(&quot;auc&quot;, &quot;class&quot;)) { set.seed(42) # for reproducibility cvfit = cv.glmnet(x, y, family = &quot;binomial&quot;, type.measure = measure, intercept = FALSE, alpha = a) coef_mat = coef(cvfit, s = &quot;lambda.min&quot;) pred_ew_hsa = pred_ew_hsa %&gt;% mutate(glm_reg = coef_mat[1] + coef_mat[2] * ss_score_150sim + coef_mat[3] * random_score) res_roc = get_roc_stats(df = pred_ew_hsa, pred_col = &quot;glm_reg&quot;, label_col = &quot;observed&quot;) pr_roc = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(glm_reg) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed)) data_list[[index]] = as_tibble_row(list(alpha = a, measure = measure, ROC_AUC = res_roc$AUC, PR_AUC = pr_roc$auc.davis.goadrich)) index = index + 1 } } data = bind_rows(data_list) # List the best two results data %&gt;% arrange(desc(ROC_AUC)) %&gt;% slice(1:4) %&gt;% kable() alpha measure ROC_AUC PR_AUC 0.0 auc 0.6916100 0.0643565 0.0 class 0.6916100 0.0643565 0.3 auc 0.6768707 0.0655809 0.5 auc 0.6746032 0.0645385 The best ROC AUC produced with a regularized logistic regression model is also lower than the one using calibrated models alone (with \\(150\\) Gitsbe simulations). Note that we get warnings when using glmnet because of the small number of observations for the positive class (observed synergies). Resulting coefficients vary, but tend to be either all too small or larger on the proliferative model predictor. MAMSE ROC Using the MAMSE R package (Plante 2017) we try another method to combine the predictor values from the calibrated and proliferative models. The resulting ROC curve gets a little bit distored and AUC is not statistically better from the reference sample population (i.e. the calibrated Gitsbe models with \\(150\\) simulations): # healthy =&gt; non-synergy, diseased =&gt; synergy healthy = list() healthy[[1]] = pred_ew_hsa %&gt;% filter(observed == 0) %&gt;% pull(ss_score_150sim) healthy[[2]] = pred_ew_hsa %&gt;% filter(observed == 0) %&gt;% pull(prolif_score_150sim) diseased = list() diseased[[1]] = pred_ew_hsa %&gt;% filter(observed == 1) %&gt;% pull(ss_score_150sim) diseased[[2]] = pred_ew_hsa %&gt;% filter(observed == 1) %&gt;% pull(prolif_score_150sim) plot(roc(healthy = healthy, diseased = diseased, smalldiseased=TRUE, AUC=TRUE, wh=NULL, wd=NULL, FPR=NULL, method=&quot;np&quot;)) Figure 15: Combined Ensemble-wise Classifier using MAMSE ROC (CASCADE 2.0, HSA) Bliss results Bliss refers to the synergy method used in Drabme to assess the synergies from the gitsbe models We test performance using ROC and PR AUC for both the ensemble-wise and model-wise synergies from Drabme Calibrated models: fitted to steady state (\\(50,100,150,200\\) simulations) Proliferative models: fitted to proliferation profile (\\(150\\) simulations) Random models: produced via abmlog (see here and used in Drabme with synergy_method: bliss Gitsbe models have mutations on link operator only Load results: # &#39;ss&#39; =&gt; calibrated models, &#39;random&#39; =&gt; random models ## Bliss results ss_bliss_ensemblewise_50sim_file = paste0(&quot;results/link-only/bliss/cascade_2.0_ss_50sim_fixpoints_ensemblewise_synergies.tab&quot;) ss_bliss_modelwise_50sim_file = paste0(&quot;results/link-only/bliss/cascade_2.0_ss_50sim_fixpoints_modelwise_synergies.tab&quot;) ss_bliss_ensemblewise_100sim_file = paste0(&quot;results/link-only/bliss/cascade_2.0_ss_100sim_fixpoints_ensemblewise_synergies.tab&quot;) ss_bliss_modelwise_100sim_file = paste0(&quot;results/link-only/bliss/cascade_2.0_ss_100sim_fixpoints_modelwise_synergies.tab&quot;) ss_bliss_ensemblewise_150sim_file = paste0(&quot;results/link-only/bliss/cascade_2.0_ss_150sim_fixpoints_ensemblewise_synergies.tab&quot;) ss_bliss_modelwise_150sim_file = paste0(&quot;results/link-only/bliss/cascade_2.0_ss_150sim_fixpoints_modelwise_synergies.tab&quot;) ss_bliss_ensemblewise_200sim_file = paste0(&quot;results/link-only/bliss/cascade_2.0_ss_200sim_fixpoints_ensemblewise_synergies.tab&quot;) ss_bliss_modelwise_200sim_file = paste0(&quot;results/link-only/bliss/cascade_2.0_ss_200sim_fixpoints_modelwise_synergies.tab&quot;) prolif_bliss_ensemblewise_150sim_file = paste0(&quot;results/link-only/bliss/cascade_2.0_rand_150sim_fixpoints_bliss_ensemblewise_synergies.tab&quot;) prolif_bliss_modelwise_150sim_file = paste0(&quot;results/link-only/bliss/cascade_2.0_rand_150sim_fixpoints_bliss_modelwise_synergies.tab&quot;) random_bliss_ensemblewise_file = paste0(&quot;results/link-only/bliss/cascade_2.0_random_bliss_ensemblewise_synergies.tab&quot;) random_bliss_modelwise_file = paste0(&quot;results/link-only/bliss/cascade_2.0_random_bliss_modelwise_synergies.tab&quot;) ss_bliss_ensemblewise_synergies_50sim = emba::get_synergy_scores(ss_bliss_ensemblewise_50sim_file) ss_bliss_modelwise_synergies_50sim = emba::get_synergy_scores(ss_bliss_modelwise_50sim_file, file_type = &quot;modelwise&quot;) ss_bliss_ensemblewise_synergies_100sim = emba::get_synergy_scores(ss_bliss_ensemblewise_100sim_file) ss_bliss_modelwise_synergies_100sim = emba::get_synergy_scores(ss_bliss_modelwise_100sim_file, file_type = &quot;modelwise&quot;) ss_bliss_ensemblewise_synergies_150sim = emba::get_synergy_scores(ss_bliss_ensemblewise_150sim_file) ss_bliss_modelwise_synergies_150sim = emba::get_synergy_scores(ss_bliss_modelwise_150sim_file, file_type = &quot;modelwise&quot;) ss_bliss_ensemblewise_synergies_200sim = emba::get_synergy_scores(ss_bliss_ensemblewise_200sim_file) ss_bliss_modelwise_synergies_200sim = emba::get_synergy_scores(ss_bliss_modelwise_200sim_file, file_type = &quot;modelwise&quot;) prolif_bliss_ensemblewise_synergies_150sim = emba::get_synergy_scores(prolif_bliss_ensemblewise_150sim_file) prolif_bliss_modelwise_synergies_150sim = emba::get_synergy_scores(prolif_bliss_modelwise_150sim_file, file_type = &quot;modelwise&quot;) random_bliss_ensemblewise_synergies = emba::get_synergy_scores(random_bliss_ensemblewise_file) random_bliss_modelwise_synergies = emba::get_synergy_scores(random_bliss_modelwise_file, file_type = &quot;modelwise&quot;) # calculate probability of synergy in the modelwise results ss_bliss_modelwise_synergies_50sim = ss_bliss_modelwise_synergies_50sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) ss_bliss_modelwise_synergies_100sim = ss_bliss_modelwise_synergies_100sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) ss_bliss_modelwise_synergies_150sim = ss_bliss_modelwise_synergies_150sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) ss_bliss_modelwise_synergies_200sim = ss_bliss_modelwise_synergies_200sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) prolif_bliss_modelwise_synergies_150sim = prolif_bliss_modelwise_synergies_150sim %&gt;% mutate(synergy_prob_prolif = synergies/(synergies + `non-synergies`)) random_bliss_modelwise_synergies = random_bliss_modelwise_synergies %&gt;% mutate(synergy_prob_random = synergies/(synergies + `non-synergies`)) # tidy data pred_ew_bliss = bind_cols( ss_bliss_ensemblewise_synergies_50sim %&gt;% select(perturbation, score) %&gt;% rename(ss_score_50sim = score), ss_bliss_ensemblewise_synergies_100sim %&gt;% select(score) %&gt;% rename(ss_score_100sim = score), ss_bliss_ensemblewise_synergies_150sim %&gt;% select(score) %&gt;% rename(ss_score_150sim = score), ss_bliss_ensemblewise_synergies_200sim %&gt;% select(score) %&gt;% rename(ss_score_200sim = score), prolif_bliss_ensemblewise_synergies_150sim %&gt;% select(score) %&gt;% rename(prolif_score_150sim = score), random_bliss_ensemblewise_synergies %&gt;% select(score) %&gt;% rename(random_score = score), as_tibble_col(observed, column_name = &quot;observed&quot;)) pred_mw_bliss = bind_cols( ss_bliss_modelwise_synergies_50sim %&gt;% select(perturbation, synergy_prob_ss) %&gt;% rename(synergy_prob_ss_50sim = synergy_prob_ss), ss_bliss_modelwise_synergies_100sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_ss_100sim = synergy_prob_ss), ss_bliss_modelwise_synergies_150sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_ss_150sim = synergy_prob_ss), ss_bliss_modelwise_synergies_200sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_ss_200sim = synergy_prob_ss), prolif_bliss_modelwise_synergies_150sim %&gt;% select(synergy_prob_prolif) %&gt;% rename(synergy_prob_prolif_150sim = synergy_prob_prolif), random_bliss_modelwise_synergies %&gt;% select(synergy_prob_random), as_tibble_col(observed, column_name = &quot;observed&quot;)) ROC curves # &#39;ew&#39; =&gt; ensemble-wise, &#39;mw&#39; =&gt; model-wise res_ss_ew_50sim = get_roc_stats(df = pred_ew_bliss, pred_col = &quot;ss_score_50sim&quot;, label_col = &quot;observed&quot;) res_ss_ew_100sim = get_roc_stats(df = pred_ew_bliss, pred_col = &quot;ss_score_100sim&quot;, label_col = &quot;observed&quot;) res_ss_ew_150sim = get_roc_stats(df = pred_ew_bliss, pred_col = &quot;ss_score_150sim&quot;, label_col = &quot;observed&quot;) res_ss_ew_200sim = get_roc_stats(df = pred_ew_bliss, pred_col = &quot;ss_score_200sim&quot;, label_col = &quot;observed&quot;) res_prolif_ew_150sim = get_roc_stats(df = pred_ew_bliss, pred_col = &quot;prolif_score_150sim&quot;, label_col = &quot;observed&quot;) res_random_ew = get_roc_stats(df = pred_ew_bliss, pred_col = &quot;random_score&quot;, label_col = &quot;observed&quot;) res_ss_mw_50sim = get_roc_stats(df = pred_mw_bliss, pred_col = &quot;synergy_prob_ss_50sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_ss_mw_100sim = get_roc_stats(df = pred_mw_bliss, pred_col = &quot;synergy_prob_ss_100sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_ss_mw_150sim = get_roc_stats(df = pred_mw_bliss, pred_col = &quot;synergy_prob_ss_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_ss_mw_200sim = get_roc_stats(df = pred_mw_bliss, pred_col = &quot;synergy_prob_ss_200sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_prolif_mw_150sim = get_roc_stats(df = pred_mw_bliss, pred_col = &quot;synergy_prob_prolif_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_random_mw = get_roc_stats(df = pred_mw_bliss, pred_col = &quot;synergy_prob_random&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) # Plot ROCs plot(x = res_ss_ew_50sim$roc_stats$FPR, y = res_ss_ew_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Ensemble-wise synergies (Bliss)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = res_ss_ew_100sim$roc_stats$FPR, y = res_ss_ew_100sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = res_ss_ew_150sim$roc_stats$FPR, y = res_ss_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = res_ss_ew_200sim$roc_stats$FPR, y = res_ss_ew_200sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) lines(x = res_prolif_ew_150sim$roc_stats$FPR, y = res_prolif_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[5]) lines(x = res_random_ew$roc_stats$FPR, y = res_random_ew$roc_stats$TPR, lwd = 3, col = my_palette[6]) legend(&#39;topleft&#39;, title = &#39;AUC&#39;, col = my_palette[1:6], pch = 19, legend = c(paste(round(res_ss_ew_50sim$AUC, digits = 2), &quot;Calibrated (50 sim)&quot;), paste(round(res_ss_ew_100sim$AUC, digits = 2), &quot;Calibrated (100 sim)&quot;), paste(round(res_ss_ew_150sim$AUC, digits = 2), &quot;Calibrated (150 sim)&quot;), paste(round(res_ss_ew_200sim$AUC, digits = 2), &quot;Calibrated (200 sim)&quot;), paste(round(res_prolif_ew_150sim$AUC, digits = 2), &quot;Proliferative (150 sim)&quot;), paste(round(res_random_ew$AUC, digits = 2), &quot;Random&quot;)), cex = 0.8) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) plot(x = res_ss_mw_50sim$roc_stats$FPR, y = res_ss_mw_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Model-wise synergies (Bliss)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = res_ss_mw_100sim$roc_stats$FPR, y = res_ss_mw_100sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = res_ss_mw_150sim$roc_stats$FPR, y = res_ss_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = res_ss_mw_200sim$roc_stats$FPR, y = res_ss_mw_200sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) lines(x = res_prolif_mw_150sim$roc_stats$FPR, y = res_prolif_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[5]) lines(x = res_random_mw$roc_stats$FPR, y = res_random_mw$roc_stats$TPR, lwd = 3, col = my_palette[6]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:6], pch = 19, cex = 0.9, legend = c(paste(round(res_ss_mw_50sim$AUC, digits = 2), &quot;Calibrated (50 sim)&quot;), paste(round(res_ss_mw_100sim$AUC, digits = 2), &quot;Calibrated (100 sim)&quot;), paste(round(res_ss_mw_150sim$AUC, digits = 2), &quot;Calibrated (150 sim)&quot;), paste(round(res_ss_mw_200sim$AUC, digits = 2), &quot;Calibrated (200 sim)&quot;), paste(round(res_prolif_mw_150sim$AUC, digits = 2), &quot;Proliferative (150 sim)&quot;), paste(round(res_random_mw$AUC, digits = 2), &quot;Random&quot;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) Figure 16: ROC curves (CASCADE 2.0, Bliss synergy method) PR curves pr_ss_ew_bliss_50sim = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(ss_score_50sim) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_ss_ew_bliss_100sim = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(ss_score_100sim) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_ss_ew_bliss_150sim = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(ss_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_ss_ew_bliss_200sim = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(ss_score_200sim) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_prolif_ew_bliss_150sim = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(prolif_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_random_ew_bliss = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(random_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_ss_mw_bliss_50sim = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(synergy_prob_ss_50sim), weights.class0 = pred_mw_bliss %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_ss_mw_bliss_100sim = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(synergy_prob_ss_100sim), weights.class0 = pred_mw_bliss %&gt;% pull(observed), curve = TRUE) pr_ss_mw_bliss_150sim = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(synergy_prob_ss_150sim), weights.class0 = pred_mw_bliss %&gt;% pull(observed), curve = TRUE) pr_ss_mw_bliss_200sim = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(synergy_prob_ss_200sim), weights.class0 = pred_mw_bliss %&gt;% pull(observed), curve = TRUE) pr_prolif_mw_bliss_150sim = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(synergy_prob_prolif_150sim), weights.class0 = pred_mw_bliss %&gt;% pull(observed), curve = TRUE) pr_random_mw_bliss = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(synergy_prob_random), weights.class0 = pred_mw_bliss %&gt;% pull(observed), curve = TRUE) plot(pr_ss_ew_bliss_50sim, main = &#39;PR curve, Ensemble-wise synergies (Bliss)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_ss_ew_bliss_100sim, add = TRUE, color = my_palette[2]) plot(pr_ss_ew_bliss_150sim, add = TRUE, color = my_palette[3]) plot(pr_ss_ew_bliss_200sim, add = TRUE, color = my_palette[4]) plot(pr_prolif_ew_bliss_150sim, add = TRUE, color = my_palette[5]) plot(pr_random_ew_bliss, add = TRUE, color = my_palette[6]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:6], pch = 19, legend = c(paste(round(pr_ss_ew_bliss_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_ss_ew_bliss_100sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (100 sim)&quot;), paste(round(pr_ss_ew_bliss_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_ss_ew_bliss_200sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (200 sim)&quot;), paste(round(pr_prolif_ew_bliss_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (150 sim)&quot;), paste(round(pr_random_ew_bliss$auc.davis.goadrich, digits = 3), &quot;Random&quot;))) grid(lwd = 0.5) plot(pr_ss_mw_bliss_50sim, main = &#39;PR curve, Model-wise synergies (Bliss)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_ss_mw_bliss_100sim, add = TRUE, color = my_palette[2]) plot(pr_ss_mw_bliss_150sim, add = TRUE, color = my_palette[3]) plot(pr_ss_mw_bliss_200sim, add = TRUE, color = my_palette[4]) plot(pr_prolif_mw_bliss_150sim, add = TRUE, color = my_palette[5]) plot(pr_random_mw_bliss, add = TRUE, color = my_palette[6]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:6], pch = 19, legend = c(paste(round(pr_ss_mw_bliss_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_ss_mw_bliss_100sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (100 sim)&quot;), paste(round(pr_ss_mw_bliss_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_ss_mw_bliss_200sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (200 sim)&quot;), paste(round(pr_prolif_mw_bliss_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (150 sim)&quot;), paste(round(pr_random_mw_bliss$auc.davis.goadrich, digits = 3), &quot;Random&quot;))) grid(lwd = 0.5) Figure 17: PR curves (CASCADE 2.0, Bliss synergy method) To minimize the resulting performance variance, \\(150\\) seems to be a good number of Gitsbe simulations to run for the CASCADE 2.0 network. Individual predictor model-wise results (when looking at the ROC curves) show good performance. Individual predictor ensemble-wise results show that proliferative and calibrated models have poor performance whereas random models perform like proper random models (\\(AUC\\sim0.5\\))) The PR curves show that the performance of all individual predictors is poor compared to the baseline. AUC sensitivity Investigate same thing as described in here. This is very crucial since the PR performance is poor for the individual predictors and the ensemble-wise predictors were really bad in terms for AUC-ROC, but a combined predictor might be able to counter this. We will combine the synergy scores from the random and proliferative simulations with the results from the calibrated Gitsbe simulations (\\(150\\)). # Ensemble-wise betas = seq(from = -10, to = 10, by = 0.1) random_roc = sapply(betas, function(beta) { pred_ew_bliss = pred_ew_bliss %&gt;% mutate(combined_score = ss_score_150sim + beta * random_score) res = roc.curve(scores.class0 = pred_ew_bliss %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed)) auc_value = res$auc }) prolif_roc = sapply(betas, function(beta) { pred_ew_bliss = pred_ew_bliss %&gt;% mutate(combined_score = ss_score_150sim + beta * prolif_score_150sim) res = roc.curve(scores.class0 = pred_ew_bliss %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed)) auc_value = res$auc }) random_pr = sapply(betas, function(beta) { pred_ew_bliss = pred_ew_bliss %&gt;% mutate(combined_score = ss_score_150sim + beta * random_score) res = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) prolif_pr = sapply(betas, function(beta) { pred_ew_bliss = pred_ew_bliss %&gt;% mutate(combined_score = ss_score_150sim + beta * prolif_score_150sim) res = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_ew = as_tibble(cbind(betas, random_roc, prolif_roc, random_pr, prolif_pr)) df_ew = df_ew %&gt;% tidyr::pivot_longer(-betas, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_ew, x = &quot;betas&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;$\\\\beta$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: calibrated + β x proliferative&quot;, &quot;ROC: calibrated + β x proliferative&quot;, &quot;PR: calibrated + β x random&quot;, &quot;ROC: calibrated + β x random&quot;)), title = TeX(&quot;AUC sensitivity to $\\\\beta$ parameter (Bliss, CASCADE 2.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + geom_vline(xintercept = 0) + geom_vline(xintercept = -1.6, color = &quot;red&quot;, size = 0.3, linetype = &quot;dashed&quot;) + geom_text(aes(x=-4, label=&quot;β = -1.6&quot;, y=0.15), colour=&quot;black&quot;) + grids() Figure 18: AUC sensitivity (CASCADE 2.0, Bliss synergy method, Ensemble-wise results) # Model-wise weights = seq(from = 0, to = 1, by = 0.05) random_roc_mw = sapply(weights, function(w) { pred_mw_bliss = pred_mw_bliss %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_bliss$synergy_prob_ss_150sim + w * pred_mw_bliss$synergy_prob_random) res = roc.curve(scores.class0 = pred_mw_bliss %&gt;% pull(weighted_prob), weights.class0 = pred_mw_bliss %&gt;% pull(observed)) auc_value = res$auc }) prolif_roc_mw = sapply(weights, function(w) { pred_mw_bliss = pred_mw_bliss %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_bliss$synergy_prob_ss_150sim + w * pred_mw_bliss$synergy_prob_prolif_150sim) res = roc.curve(scores.class0 = pred_mw_bliss %&gt;% pull(weighted_prob), weights.class0 = pred_mw_bliss %&gt;% pull(observed)) auc_value = res$auc }) random_pr_mw = sapply(weights, function(w) { pred_mw_bliss = pred_mw_bliss %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_bliss$synergy_prob_ss_150sim + w * pred_mw_bliss$synergy_prob_random) res = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(weighted_prob), weights.class0 = pred_mw_bliss %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) prolif_pr_mw = sapply(weights, function(w) { pred_mw_bliss = pred_mw_bliss %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_bliss$synergy_prob_ss_150sim + w * pred_mw_bliss$synergy_prob_prolif_150sim) res = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(weighted_prob), weights.class0 = pred_mw_bliss %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_mw = as_tibble(cbind(weights, random_roc_mw, prolif_roc_mw, random_pr_mw, prolif_pr_mw)) df_mw = df_mw %&gt;% tidyr::pivot_longer(-weights, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_mw, x = &quot;weights&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;weight $w$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: (1-w) x prob(ss) + w x prob(prolif)&quot;, &quot;ROC: (1-w) x prob(ss) + w x prob(prolif)&quot;, &quot;PR: (1-w) x prob(ss) + w x prob(random)&quot;, &quot;ROC: (1-w) x prob(ss) + w x prob(random)&quot;)), title.position = &quot;center&quot;, title = TeX(&quot;AUC sensitivity to weighted average score (Bliss, CASCADE 2.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + grids() Figure 19: AUC sensitivity (CASCADE 2.0, Bliss synergy method, Model-wise results) No added benefit when using the model-wise approach. The random models do not augment the prediction performance of the calibrated models at all. The proliferative models can be used to normalize against the predictions of the calibrated models and thus bring significant contribution to the calibrated models performance (both ROC-AUC and PR-AUC are increased). The \\(\\beta_{best}\\) that maximizes the ROC and PR AUC for the combination of proliferative and calibrated models and is equal to \\(\\beta_{best}=-1.6\\). For \\(\\beta=-1\\) we still see significant performance improvement. Correlation We test for correlation between some of the results shown in the ROC curves. The results tested are the ensemble-wise vs model-wise, random models vs calibrated (ss) models and HSA vs Bliss synergy assessment (the calibrated and proliferative models are from the \\(150\\) simulation results). P-values are represented at 3 significant levels: \\(0.05, 0.01, 0.001\\) (*, **, ***) and the correlation coefficient is calculated using Kendall’s tau statistic. synergy_scores = bind_cols( pred_ew_hsa %&gt;% select(ss_score_150sim, prolif_score_150sim, random_score) %&gt;% rename(ss_ew_hsa = ss_score_150sim, prolif_ew_hsa = prolif_score_150sim, random_ew_hsa = random_score), pred_ew_bliss %&gt;% select(ss_score_150sim, prolif_score_150sim, random_score) %&gt;% rename(ss_ew_bliss = ss_score_150sim, prolif_ew_bliss = prolif_score_150sim, random_ew_bliss = random_score), pred_mw_hsa %&gt;% select(synergy_prob_ss_150sim, synergy_prob_prolif_150sim, synergy_prob_random) %&gt;% rename(ss_mw_hsa = synergy_prob_ss_150sim, prolif_mw_hsa = synergy_prob_prolif_150sim, random_mw_hsa = synergy_prob_random), pred_mw_bliss %&gt;% select(synergy_prob_ss_150sim, synergy_prob_prolif_150sim, synergy_prob_random) %&gt;% rename(ss_mw_bliss = synergy_prob_ss_150sim, prolif_mw_bliss = synergy_prob_prolif_150sim, random_mw_bliss = synergy_prob_random) ) M = cor(synergy_scores, method = &quot;kendall&quot;) res = cor.mtest(synergy_scores, method = &quot;kendall&quot;) corrplot(corr = M, type = &quot;upper&quot;, p.mat = res$p, sig.level = c(.001, .01, .05), pch.cex = 1, pch.col = &quot;white&quot;, insig = &quot;label_sig&quot;, tl.col = &quot;black&quot;, tl.srt = 45) Figure 20: Correlation Plot for CASCADE 2.0 Results Bliss ensemble-wise results don’t correlate at all with the model-wise results (topright part of the correlation plot). The HSA ensemble-wise results do so (at some degree). Between the ensemble-wise results there is no strong correlation (topleft) while between the model-wise (bottomright) there is strong correlation. Ensemble-wise calibrated results seem to correlate more with the proliferative than with the random results (topleft). Fitness vs Performance The idea here is to generate many training data files from the steady state as used in the simulations above, where some of the nodes will have their states flipped to the opposite state (\\(0\\) to \\(1\\) and vice versa). That way, we can train models to different steady states, ranging from ones that differ to just a few nodes states up to a steady state that is the complete reversed version of the one used in the simulations. Using the gen_training_data.R script, we first choose a few number of flips (\\(11\\) flips) ranging from \\(1\\) to \\(24\\) (all nodes) in the steady state. Then, for each such flipping-nodes value, we generated \\(20\\) new steady states with a randomly chosen set of nodes whose value is going to flip. Thus, in total, \\(205\\) training data files were produced (\\(205 = 9 \\times 20 + 24 + 1\\), where from the \\(11\\) number of flips, the one flip happens for every node and flipping all the nodes simultaneously happens once). Running the script run_druglogics_synergy_training.sh from the druglogics-synergy repository root, we get the simulation results for each of these training data files. Note that in the CASCADE 2.0 configuration file we changed the number of simulations to (\\(15\\)) for each training data file, the attractor tool used was biolqm_stable_states (as is with every analysis in this report) and the synergy_method: hsa. We now load the data from these simulations: "],
["cascade-2-0-analysis-topology-mutations.html", "CASCADE 2.0 Analysis (Topology Mutations) ROC curves (HSA) PR curves (HSA) ROC-AUC sensitivity (HSA) PR-AUC sensitivity (HSA) ROC curves (Bliss) PR curves (Bliss) ROC-AUC sensitivity (Bliss) PR-AUC sensitivity (Bliss) ROC and PRC for best beta (Bliss)", " CASCADE 2.0 Analysis (Topology Mutations) We run Gitsbe simulations with \\(50\\) topology mutations (bootstrap value, reduced to \\(10\\) after models with stabla states have been found), both for \\(50\\) and \\(150\\) simulations and both fitting to steady state (calibrated models) and to a proliferative phenotype (so not random models but as close as it can get to that since we are discussing topology mutations). Results were assessed via Drabme’s ensemble and modelwise results, using both the HSA and Bliss method. Load the results: # &#39;ss&#39; =&gt; calibrated models, &#39;rand&#39; =&gt; proliferative models (so not random but kind of!) # &#39;ew&#39; =&gt; ensemble-wise, &#39;mw&#39; =&gt; modelwise ## HSA results ss topo_ss_hsa_ew_50sim_file = paste0(&quot;results/topology-only/cascade_2.0_ss_50sim_fixpoints_hsa_ensemblewise_synergies.tab&quot;) topo_ss_hsa_mw_50sim_file = paste0(&quot;results/topology-only/cascade_2.0_ss_50sim_fixpoints_hsa_modelwise_synergies.tab&quot;) topo_ss_hsa_ew_150sim_file = paste0(&quot;results/topology-only/cascade_2.0_ss_150sim_fixpoints_hsa_ensemblewise_synergies.tab&quot;) topo_ss_hsa_mw_150sim_file = paste0(&quot;results/topology-only/cascade_2.0_ss_150sim_fixpoints_hsa_modelwise_synergies.tab&quot;) topo_ss_hsa_ew_synergies_50sim = emba::get_synergy_scores(topo_ss_hsa_ew_50sim_file) topo_ss_hsa_mw_synergies_50sim = emba::get_synergy_scores(topo_ss_hsa_mw_50sim_file, file_type = &quot;modelwise&quot;) topo_ss_hsa_ew_synergies_150sim = emba::get_synergy_scores(topo_ss_hsa_ew_150sim_file) topo_ss_hsa_mw_synergies_150sim = emba::get_synergy_scores(topo_ss_hsa_mw_150sim_file, file_type = &quot;modelwise&quot;) ## HSA results rand topo_prolif_hsa_ew_50sim_file = paste0(&quot;results/topology-only/cascade_2.0_rand_50sim_fixpoints_hsa_ensemblewise_synergies.tab&quot;) topo_prolif_hsa_mw_50sim_file = paste0(&quot;results/topology-only/cascade_2.0_rand_50sim_fixpoints_hsa_modelwise_synergies.tab&quot;) topo_prolif_hsa_ew_150sim_file = paste0(&quot;results/topology-only/cascade_2.0_rand_150sim_fixpoints_hsa_ensemblewise_synergies.tab&quot;) topo_prolif_hsa_mw_150sim_file = paste0(&quot;results/topology-only/cascade_2.0_rand_150sim_fixpoints_hsa_modelwise_synergies.tab&quot;) topo_prolif_hsa_ew_synergies_50sim = emba::get_synergy_scores(topo_prolif_hsa_ew_50sim_file) topo_prolif_hsa_mw_synergies_50sim = emba::get_synergy_scores(topo_prolif_hsa_mw_50sim_file, file_type = &quot;modelwise&quot;) topo_prolif_hsa_ew_synergies_150sim = emba::get_synergy_scores(topo_prolif_hsa_ew_150sim_file) topo_prolif_hsa_mw_synergies_150sim = emba::get_synergy_scores(topo_prolif_hsa_mw_150sim_file, file_type = &quot;modelwise&quot;) ## Bliss results ss topo_ss_bliss_ew_50sim_file = paste0(&quot;results/topology-only/cascade_2.0_ss_50sim_fixpoints_bliss_ensemblewise_synergies.tab&quot;) topo_ss_bliss_mw_50sim_file = paste0(&quot;results/topology-only/cascade_2.0_ss_50sim_fixpoints_bliss_modelwise_synergies.tab&quot;) topo_ss_bliss_ew_150sim_file = paste0(&quot;results/topology-only/cascade_2.0_ss_150sim_fixpoints_bliss_ensemblewise_synergies.tab&quot;) topo_ss_bliss_mw_150sim_file = paste0(&quot;results/topology-only/cascade_2.0_ss_150sim_fixpoints_bliss_modelwise_synergies.tab&quot;) topo_ss_bliss_ew_synergies_50sim = emba::get_synergy_scores(topo_ss_bliss_ew_50sim_file) topo_ss_bliss_mw_synergies_50sim = emba::get_synergy_scores(topo_ss_bliss_mw_50sim_file, file_type = &quot;modelwise&quot;) topo_ss_bliss_ew_synergies_150sim = emba::get_synergy_scores(topo_ss_bliss_ew_150sim_file) topo_ss_bliss_mw_synergies_150sim = emba::get_synergy_scores(topo_ss_bliss_mw_150sim_file, file_type = &quot;modelwise&quot;) ## Bliss results rand topo_prolif_bliss_ew_50sim_file = paste0(&quot;results/topology-only/cascade_2.0_rand_50sim_fixpoints_bliss_ensemblewise_synergies.tab&quot;) topo_prolif_bliss_mw_50sim_file = paste0(&quot;results/topology-only/cascade_2.0_rand_50sim_fixpoints_bliss_modelwise_synergies.tab&quot;) topo_prolif_bliss_ew_150sim_file = paste0(&quot;results/topology-only/cascade_2.0_rand_150sim_fixpoints_bliss_ensemblewise_synergies.tab&quot;) topo_prolif_bliss_mw_150sim_file = paste0(&quot;results/topology-only/cascade_2.0_rand_150sim_fixpoints_bliss_modelwise_synergies.tab&quot;) topo_prolif_bliss_ew_synergies_50sim = emba::get_synergy_scores(topo_prolif_bliss_ew_50sim_file) topo_prolif_bliss_mw_synergies_50sim = emba::get_synergy_scores(topo_prolif_bliss_mw_50sim_file, file_type = &quot;modelwise&quot;) topo_prolif_bliss_ew_synergies_150sim = emba::get_synergy_scores(topo_prolif_bliss_ew_150sim_file) topo_prolif_bliss_mw_synergies_150sim = emba::get_synergy_scores(topo_prolif_bliss_mw_150sim_file, file_type = &quot;modelwise&quot;) # calculate probability of synergy in the modelwise results topo_ss_hsa_mw_synergies_50sim = topo_ss_hsa_mw_synergies_50sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topo_ss_hsa_mw_synergies_150sim = topo_ss_hsa_mw_synergies_150sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topo_prolif_hsa_mw_synergies_50sim = topo_prolif_hsa_mw_synergies_50sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topo_prolif_hsa_mw_synergies_150sim = topo_prolif_hsa_mw_synergies_150sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topo_ss_bliss_mw_synergies_50sim = topo_ss_bliss_mw_synergies_50sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topo_ss_bliss_mw_synergies_150sim = topo_ss_bliss_mw_synergies_150sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topo_prolif_bliss_mw_synergies_50sim = topo_prolif_bliss_mw_synergies_50sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topo_prolif_bliss_mw_synergies_150sim = topo_prolif_bliss_mw_synergies_150sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) # Tidy the data pred_topo_ew_hsa = bind_cols( topo_ss_hsa_ew_synergies_50sim %&gt;% rename(ss_score_50sim = score), topo_ss_hsa_ew_synergies_150sim %&gt;% select(score) %&gt;% rename(ss_score_150sim = score), topo_prolif_hsa_ew_synergies_50sim %&gt;% select(score) %&gt;% rename(prolif_score_50sim = score), topo_prolif_hsa_ew_synergies_150sim %&gt;% select(score) %&gt;% rename(prolif_score_150sim = score), as_tibble_col(observed, column_name = &quot;observed&quot;)) pred_topo_mw_hsa = bind_cols( topo_ss_hsa_mw_synergies_50sim %&gt;% select(perturbation, synergy_prob_ss) %&gt;% rename(synergy_prob_ss_50sim = synergy_prob_ss), topo_ss_hsa_mw_synergies_150sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_ss_150sim = synergy_prob_ss), topo_prolif_hsa_mw_synergies_50sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_prolif_50sim = synergy_prob_ss), topo_prolif_hsa_mw_synergies_150sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_prolif_150sim = synergy_prob_ss), as_tibble_col(observed, column_name = &quot;observed&quot;)) pred_topo_ew_bliss = bind_cols( topo_ss_bliss_ew_synergies_50sim %&gt;% rename(ss_score_50sim = score), topo_ss_bliss_ew_synergies_150sim %&gt;% select(score) %&gt;% rename(ss_score_150sim = score), topo_prolif_bliss_ew_synergies_50sim %&gt;% select(score) %&gt;% rename(prolif_score_50sim = score), topo_prolif_bliss_ew_synergies_150sim %&gt;% select(score) %&gt;% rename(prolif_score_150sim = score), as_tibble_col(observed, column_name = &quot;observed&quot;)) pred_topo_mw_bliss = bind_cols( topo_ss_bliss_mw_synergies_50sim %&gt;% select(perturbation, synergy_prob_ss) %&gt;% rename(synergy_prob_ss_50sim = synergy_prob_ss), topo_ss_bliss_mw_synergies_150sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_ss_150sim = synergy_prob_ss), topo_prolif_bliss_mw_synergies_50sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_prolif_50sim = synergy_prob_ss), topo_prolif_bliss_mw_synergies_150sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_prolif_150sim = synergy_prob_ss), as_tibble_col(observed, column_name = &quot;observed&quot;)) ROC curves (HSA) topo_res_ss_ew_50sim = get_roc_stats(df = pred_topo_ew_hsa, pred_col = &quot;ss_score_50sim&quot;, label_col = &quot;observed&quot;) topo_res_ss_ew_150sim = get_roc_stats(df = pred_topo_ew_hsa, pred_col = &quot;ss_score_150sim&quot;, label_col = &quot;observed&quot;) topo_res_prolif_ew_50sim = get_roc_stats(df = pred_topo_ew_hsa, pred_col = &quot;prolif_score_50sim&quot;, label_col = &quot;observed&quot;) topo_res_prolif_ew_150sim = get_roc_stats(df = pred_topo_ew_hsa, pred_col = &quot;prolif_score_150sim&quot;, label_col = &quot;observed&quot;) topo_res_ss_mw_50sim = get_roc_stats(df = pred_topo_mw_hsa, pred_col = &quot;synergy_prob_ss_50sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topo_res_ss_mw_150sim = get_roc_stats(df = pred_topo_mw_hsa, pred_col = &quot;synergy_prob_ss_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topo_res_prolif_mw_50sim = get_roc_stats(df = pred_topo_mw_hsa, pred_col = &quot;synergy_prob_prolif_50sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topo_res_prolif_mw_150sim = get_roc_stats(df = pred_topo_mw_hsa, pred_col = &quot;synergy_prob_prolif_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) # Plot ROCs plot(x = topo_res_ss_ew_50sim$roc_stats$FPR, y = topo_res_ss_ew_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Ensemble-wise synergies (HSA)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = topo_res_ss_ew_150sim$roc_stats$FPR, y = topo_res_ss_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = topo_res_prolif_ew_50sim$roc_stats$FPR, y = topo_res_prolif_ew_50sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = topo_res_prolif_ew_150sim$roc_stats$FPR, y = topo_res_prolif_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(topo_res_ss_ew_50sim$AUC, digits = 2), &quot;Calibrated (50 sim)&quot;), paste(round(topo_res_ss_ew_150sim$AUC, digits = 2), &quot;Calibrated (150 sim)&quot;), paste(round(topo_res_prolif_ew_50sim$AUC, digits = 2), &quot;Proliferative (50 sim)&quot;), paste(round(topo_res_prolif_ew_150sim$AUC, digits = 2), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) plot(x = topo_res_ss_mw_50sim$roc_stats$FPR, y = topo_res_ss_mw_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Model-wise synergies (HSA)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = topo_res_ss_mw_150sim$roc_stats$FPR, y = topo_res_ss_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = topo_res_prolif_mw_50sim$roc_stats$FPR, y = topo_res_prolif_mw_50sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = topo_res_prolif_mw_150sim$roc_stats$FPR, y = topo_res_prolif_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(topo_res_ss_mw_50sim$AUC, digits = 2), &quot;Calibrated (50 sim)&quot;), paste(round(topo_res_ss_mw_150sim$AUC, digits = 2), &quot;Calibrated (150 sim)&quot;), paste(round(topo_res_prolif_mw_50sim$AUC, digits = 2), &quot;Proliferative (50 sim)&quot;), paste(round(topo_res_prolif_mw_150sim$AUC, digits = 2), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) PR curves (HSA) pr_topo_res_ss_ew_50sim = pr.curve(scores.class0 = pred_topo_ew_hsa %&gt;% pull(ss_score_50sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_hsa %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_topo_res_ss_ew_150sim = pr.curve(scores.class0 = pred_topo_ew_hsa %&gt;% pull(ss_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_topo_res_prolif_ew_50sim = pr.curve(scores.class0 = pred_topo_ew_hsa %&gt;% pull(prolif_score_50sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_topo_res_prolif_ew_150sim = pr.curve(scores.class0 = pred_topo_ew_hsa %&gt;% pull(prolif_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_topo_res_ss_mw_50sim = pr.curve(scores.class0 = pred_topo_mw_hsa %&gt;% pull(synergy_prob_ss_50sim), weights.class0 = pred_topo_mw_hsa %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_topo_res_ss_mw_150sim = pr.curve(scores.class0 = pred_topo_mw_hsa %&gt;% pull(synergy_prob_ss_150sim), weights.class0 = pred_topo_mw_hsa %&gt;% pull(observed), curve = TRUE) pr_topo_res_prolif_mw_50sim = pr.curve(scores.class0 = pred_topo_mw_hsa %&gt;% pull(synergy_prob_prolif_50sim), weights.class0 = pred_topo_mw_hsa %&gt;% pull(observed), curve = TRUE) pr_topo_res_prolif_mw_150sim = pr.curve(scores.class0 = pred_topo_mw_hsa %&gt;% pull(synergy_prob_prolif_150sim), weights.class0 = pred_topo_mw_hsa %&gt;% pull(observed), curve = TRUE) plot(pr_topo_res_ss_ew_50sim, main = &#39;PR curve, Ensemble-wise synergies (HSA)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_topo_res_ss_ew_150sim, add = TRUE, color = my_palette[2]) plot(pr_topo_res_prolif_ew_50sim, add = TRUE, color = my_palette[3]) plot(pr_topo_res_prolif_ew_150sim, add = TRUE, color = my_palette[4]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(pr_topo_res_ss_ew_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_topo_res_ss_ew_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_topo_res_prolif_ew_50sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (50 sim)&quot;), paste(round(pr_topo_res_prolif_ew_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) plot(pr_topo_res_ss_mw_50sim, main = &#39;PR curve, Model-wise synergies (HSA)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_topo_res_ss_mw_150sim, add = TRUE, color = my_palette[2]) plot(pr_topo_res_prolif_mw_50sim, add = TRUE, color = my_palette[3]) plot(pr_topo_res_prolif_mw_150sim, add = TRUE, color = my_palette[4]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(pr_topo_res_ss_mw_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_topo_res_ss_mw_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_topo_res_prolif_mw_50sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (50 sim)&quot;), paste(round(pr_topo_res_prolif_mw_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) ROC-AUC sensitivity (HSA) Combine the \\(150\\) simulation results (calibrated + proliferative) # Ensemble-wise betas = seq(from = -10, to = 10, by = 0.1) auc_values_ew = sapply(betas, function(beta) { pred_topo_ew_hsa = pred_topo_ew_hsa %&gt;% mutate(combined_score = ss_score_150sim + beta * prolif_score_150sim) res = get_roc_stats(df = pred_topo_ew_hsa, pred_col = &quot;combined_score&quot;, label_col = &quot;observed&quot;) auc_value = res$AUC }) df_ew = as_tibble(cbind(betas, auc_values_ew)) ggline(data = df_ew, x = &quot;betas&quot;, y = &quot;auc_values_ew&quot;, numeric.x.axis = TRUE, plot_type = &quot;l&quot;, xlab = TeX(&quot;$\\\\beta$&quot;), ylab = &quot;AUC (Area Under ROC Curve)&quot;, title = TeX(&quot;AUC sensitivity to $\\\\beta$ parameter: $calibrated + \\\\beta \\\\times random$&quot;), color = my_palette[2]) + geom_vline(xintercept = 0) + grids() # Model-wise weights = seq(from = 0, to = 1, by = 0.05) auc_values_mw = sapply(weights, function(w) { pred_topo_mw_hsa = pred_topo_mw_hsa %&gt;% mutate(weighted_prob = (1 - w) * pred_topo_mw_hsa$synergy_prob_ss_150sim + w * pred_topo_mw_hsa$synergy_prob_prolif_150sim) res = get_roc_stats(df = pred_topo_mw_hsa, pred_col = &quot;weighted_prob&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) auc_value = res$AUC }) df_mw = as_tibble(cbind(weights, auc_values_mw)) ggline(data = df_mw, x = &quot;weights&quot;, y = &quot;auc_values_mw&quot;, numeric.x.axis = TRUE, plot_type = &quot;l&quot;, xlab = TeX(&quot;weight $w$&quot;), ylab = &quot;AUC (Area Under ROC Curve)&quot;, title = TeX(&quot;AUC sensitivity to weighted average score: $(1-w) \\\\times prob_{ss} + w \\\\times prob_{rand}$&quot;), color = my_palette[3]) + grids() PR-AUC sensitivity (HSA) Combine the \\(150\\) simulation results (calibrated + proliferative) # Ensemble-wise betas = seq(from = -10, to = 10, by = 0.1) auc_values_ew = sapply(betas, function(beta) { pred_topo_ew_hsa = pred_topo_ew_hsa %&gt;% mutate(combined_score = ss_score_150sim + beta * prolif_score_150sim) res = pr.curve(scores.class0 = pred_topo_ew_hsa %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_hsa %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_ew = as_tibble(cbind(betas, auc_values_ew)) ggline(data = df_ew, x = &quot;betas&quot;, y = &quot;auc_values_ew&quot;, numeric.x.axis = TRUE, plot_type = &quot;l&quot;, xlab = TeX(&quot;$\\\\beta$&quot;), ylab = &quot;AUC (Area Under PR Curve)&quot;, title = TeX(&quot;AUC sensitivity to $\\\\beta$ parameter: $calibrated + \\\\beta \\\\times random$&quot;), color = my_palette[2], label = &quot;betas&quot;, repel = TRUE, label.select = list(criteria = &quot;`y` == max(`y`)&quot;), font.label = list(size = 14)) + geom_vline(xintercept = 0) + grids() ROC curves (Bliss) topo_res_ss_ew_50sim = get_roc_stats(df = pred_topo_ew_bliss, pred_col = &quot;ss_score_50sim&quot;, label_col = &quot;observed&quot;) topo_res_ss_ew_150sim = get_roc_stats(df = pred_topo_ew_bliss, pred_col = &quot;ss_score_150sim&quot;, label_col = &quot;observed&quot;) topo_res_prolif_ew_50sim = get_roc_stats(df = pred_topo_ew_bliss, pred_col = &quot;prolif_score_50sim&quot;, label_col = &quot;observed&quot;) topo_res_prolif_ew_150sim = get_roc_stats(df = pred_topo_ew_bliss, pred_col = &quot;prolif_score_150sim&quot;, label_col = &quot;observed&quot;) topo_res_ss_mw_50sim = get_roc_stats(df = pred_topo_mw_bliss, pred_col = &quot;synergy_prob_ss_50sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topo_res_ss_mw_150sim = get_roc_stats(df = pred_topo_mw_bliss, pred_col = &quot;synergy_prob_ss_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topo_res_prolif_mw_50sim = get_roc_stats(df = pred_topo_mw_bliss, pred_col = &quot;synergy_prob_prolif_50sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topo_res_prolif_mw_150sim = get_roc_stats(df = pred_topo_mw_bliss, pred_col = &quot;synergy_prob_prolif_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) # Plot ROCs plot(x = topo_res_ss_ew_50sim$roc_stats$FPR, y = topo_res_ss_ew_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Ensemble-wise synergies (Bliss)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = topo_res_ss_ew_150sim$roc_stats$FPR, y = topo_res_ss_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = topo_res_prolif_ew_50sim$roc_stats$FPR, y = topo_res_prolif_ew_50sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = topo_res_prolif_ew_150sim$roc_stats$FPR, y = topo_res_prolif_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(topo_res_ss_ew_50sim$AUC, digits = 2), &quot;Calibrated (50 sim)&quot;), paste(round(topo_res_ss_ew_150sim$AUC, digits = 2), &quot;Calibrated (150 sim)&quot;), paste(round(topo_res_prolif_ew_50sim$AUC, digits = 2), &quot;Proliferative (50 sim)&quot;), paste(round(topo_res_prolif_ew_150sim$AUC, digits = 2), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) plot(x = topo_res_ss_mw_50sim$roc_stats$FPR, y = topo_res_ss_mw_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Model-wise synergies (Bliss)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = topo_res_ss_mw_150sim$roc_stats$FPR, y = topo_res_ss_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = topo_res_prolif_mw_50sim$roc_stats$FPR, y = topo_res_prolif_mw_50sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = topo_res_prolif_mw_150sim$roc_stats$FPR, y = topo_res_prolif_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(topo_res_ss_mw_50sim$AUC, digits = 2), &quot;Calibrated (50 sim)&quot;), paste(round(topo_res_ss_mw_150sim$AUC, digits = 2), &quot;Calibrated (150 sim)&quot;), paste(round(topo_res_prolif_mw_50sim$AUC, digits = 2), &quot;Proliferative (50 sim)&quot;), paste(round(topo_res_prolif_mw_150sim$AUC, digits = 2), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) PR curves (Bliss) pr_topo_res_ss_ew_50sim = pr.curve(scores.class0 = pred_topo_ew_bliss %&gt;% pull(ss_score_50sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_bliss %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_topo_res_ss_ew_150sim = pr.curve(scores.class0 = pred_topo_ew_bliss %&gt;% pull(ss_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_topo_res_prolif_ew_50sim = pr.curve(scores.class0 = pred_topo_ew_bliss %&gt;% pull(prolif_score_50sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_topo_res_prolif_ew_150sim = pr.curve(scores.class0 = pred_topo_ew_bliss %&gt;% pull(prolif_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_topo_res_ss_mw_50sim = pr.curve(scores.class0 = pred_topo_mw_bliss %&gt;% pull(synergy_prob_ss_50sim), weights.class0 = pred_topo_mw_bliss %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_topo_res_ss_mw_150sim = pr.curve(scores.class0 = pred_topo_mw_bliss %&gt;% pull(synergy_prob_ss_150sim), weights.class0 = pred_topo_mw_bliss %&gt;% pull(observed), curve = TRUE) pr_topo_res_prolif_mw_50sim = pr.curve(scores.class0 = pred_topo_mw_bliss %&gt;% pull(synergy_prob_prolif_50sim), weights.class0 = pred_topo_mw_bliss %&gt;% pull(observed), curve = TRUE) pr_topo_res_prolif_mw_150sim = pr.curve(scores.class0 = pred_topo_mw_bliss %&gt;% pull(synergy_prob_prolif_150sim), weights.class0 = pred_topo_mw_bliss %&gt;% pull(observed), curve = TRUE) plot(pr_topo_res_ss_ew_50sim, main = &#39;PR curve, Ensemble-wise synergies (Bliss)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_topo_res_ss_ew_150sim, add = TRUE, color = my_palette[2]) plot(pr_topo_res_prolif_ew_50sim, add = TRUE, color = my_palette[3]) plot(pr_topo_res_prolif_ew_150sim, add = TRUE, color = my_palette[4]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(pr_topo_res_ss_ew_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_topo_res_ss_ew_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_topo_res_prolif_ew_50sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (50 sim)&quot;), paste(round(pr_topo_res_prolif_ew_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) plot(pr_topo_res_ss_mw_50sim, main = &#39;PR curve, Model-wise synergies (Bliss)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_topo_res_ss_mw_150sim, add = TRUE, color = my_palette[2]) plot(pr_topo_res_prolif_mw_50sim, add = TRUE, color = my_palette[3]) plot(pr_topo_res_prolif_mw_150sim, add = TRUE, color = my_palette[4]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(pr_topo_res_ss_mw_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_topo_res_ss_mw_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_topo_res_prolif_mw_50sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (50 sim)&quot;), paste(round(pr_topo_res_prolif_mw_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) ROC-AUC sensitivity (Bliss) betas = seq(from = -10, to = 10, by = 0.1) auc_values_ew = sapply(betas, function(beta) { pred_topo_ew_bliss = pred_topo_ew_bliss %&gt;% mutate(combined_score = ss_score_150sim + beta * prolif_score_150sim) res = get_roc_stats(df = pred_topo_ew_bliss, pred_col = &quot;combined_score&quot;, label_col = &quot;observed&quot;) auc_value = res$AUC }) df_ew = as_tibble(cbind(betas, auc_values_ew)) ggline(data = df_ew, x = &quot;betas&quot;, y = &quot;auc_values_ew&quot;, numeric.x.axis = TRUE, plot_type = &quot;l&quot;, xlab = TeX(&quot;$\\\\beta$&quot;), ylab = &quot;AUC (Area Under ROC Curve)&quot;, title = TeX(&quot;AUC sensitivity to $\\\\beta$ parameter: $calibrated + \\\\beta \\\\times random$&quot;), color = my_palette[2], label = &quot;betas&quot;, repel = TRUE, label.select = list(criteria = &quot;`y` == max(`y`)&quot;), font.label = list(size = 14)) + geom_vline(xintercept = 0) + grids() PR-AUC sensitivity (Bliss) # Ensemble-wise betas = seq(from = -10, to = 10, by = 0.1) auc_values_ew = sapply(betas, function(beta) { pred_topo_ew_bliss = pred_topo_ew_bliss %&gt;% mutate(combined_score = ss_score_150sim + beta * prolif_score_150sim) res = pr.curve(scores.class0 = pred_topo_ew_bliss %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_bliss %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_ew = as_tibble(cbind(betas, auc_values_ew)) ggline(data = df_ew, x = &quot;betas&quot;, y = &quot;auc_values_ew&quot;, numeric.x.axis = TRUE, plot_type = &quot;l&quot;, xlab = TeX(&quot;$\\\\beta$&quot;), ylab = &quot;AUC (Area Under PR Curve)&quot;, title = TeX(&quot;AUC sensitivity to $\\\\beta$ parameter: $calibrated + \\\\beta \\\\times random$&quot;), color = my_palette[2], label = &quot;betas&quot;, repel = TRUE, label.select = list(criteria = &quot;`y` == max(`y`)&quot;), font.label = list(size = 14)) + geom_vline(xintercept = 0) + grids() ROC and PRC for best beta (Bliss) best_beta = -1 pred_topo_ew_bliss = pred_topo_ew_bliss %&gt;% mutate(best_score = ss_score_150sim + best_beta * prolif_score_150sim) roc_best_res = get_roc_stats(df = pred_topo_ew_bliss, pred_col = &quot;best_score&quot;, label_col = &quot;observed&quot;) pr_best_res = pr.curve(scores.class0 = pred_topo_ew_bliss %&gt;% pull(best_score) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_bliss %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) # Plot best ROC plot(x = roc_best_res$roc_stats$FPR, y = roc_best_res$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = TeX(&#39;ROC curve (Ensemble-wise), $calibrated + \\\\beta \\\\times proliferative$&#39;), xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) legend(&#39;bottomright&#39;, title = TeX(&#39;AUC ($\\\\beta$ = -1)&#39;), col = my_palette[1], pch = 19, legend = paste(round(roc_best_res$AUC, digits = 2), &#39;Bliss (150 sim)&#39;)) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) # Plot best PRC plot(pr_best_res, main = TeX(&#39;PR curve (Ensemble-wise), $calibrated + \\\\beta \\\\times proliferative$&#39;), auc.main = FALSE, color = my_palette[2], rand.plot = TRUE) legend(&#39;topright&#39;, title = TeX(&#39;AUC ($\\\\beta$ = -1)&#39;), col = my_palette[2], pch = 19, legend = paste(round(pr_best_res$auc.davis.goadrich, digits = 3), &#39;Bliss (150 sim)&#39;)) grid(lwd = 0.5) "],
["cascade-2-0-analysis-topology-and-link-operator-mutations.html", "CASCADE 2.0 Analysis (Topology and Link Operator Mutations)", " CASCADE 2.0 Analysis (Topology and Link Operator Mutations) We run Gitsbe simulations with \\(50\\) topology mutations and \\(3000\\) link operator mutations (bootstrap values, reduced to \\(10\\) and \\(3\\) respectively after models with stabla states have been found), both for \\(50\\) and \\(150\\) simulations and both fitting to steady state (calibrated models) and to a proliferative phenotype (so not random models but as close as it can get to that since we are discussing topology mutations). Results were assessed via Drabme’s ensemble and modelwise results, using both the HSA and Bliss method. # &#39;ss&#39; =&gt; calibrated models, &#39;rand&#39; =&gt; proliferative models (so not random but kind of!) # &#39;ew&#39; =&gt; ensemble-wise, &#39;mw&#39; =&gt; modelwise ## HSA results ss topolink_ss_hsa_ew_50sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_ss_50sim_fixpoints_hsa_ensemblewise_synergies.tab&quot;) topolink_ss_hsa_mw_50sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_ss_50sim_fixpoints_hsa_modelwise_synergies.tab&quot;) topolink_ss_hsa_ew_150sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_ss_150sim_fixpoints_hsa_ensemblewise_synergies.tab&quot;) topolink_ss_hsa_mw_150sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_ss_150sim_fixpoints_hsa_modelwise_synergies.tab&quot;) topolink_ss_hsa_ew_synergies_50sim = emba::get_synergy_scores(topolink_ss_hsa_ew_50sim_file) topolink_ss_hsa_mw_synergies_50sim = emba::get_synergy_scores(topolink_ss_hsa_mw_50sim_file, file_type = &quot;modelwise&quot;) topolink_ss_hsa_ew_synergies_150sim = emba::get_synergy_scores(topolink_ss_hsa_ew_150sim_file) topolink_ss_hsa_mw_synergies_150sim = emba::get_synergy_scores(topolink_ss_hsa_mw_150sim_file, file_type = &quot;modelwise&quot;) ## HSA results rand topolink_prolif_hsa_ew_50sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_rand_50sim_fixpoints_hsa_ensemblewise_synergies.tab&quot;) topolink_prolif_hsa_mw_50sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_rand_50sim_fixpoints_hsa_modelwise_synergies.tab&quot;) topolink_prolif_hsa_ew_150sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_rand_150sim_fixpoints_hsa_ensemblewise_synergies.tab&quot;) topolink_prolif_hsa_mw_150sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_rand_150sim_fixpoints_hsa_modelwise_synergies.tab&quot;) topolink_prolif_hsa_ew_synergies_50sim = emba::get_synergy_scores(topolink_prolif_hsa_ew_50sim_file) topolink_prolif_hsa_mw_synergies_50sim = emba::get_synergy_scores(topolink_prolif_hsa_mw_50sim_file, file_type = &quot;modelwise&quot;) topolink_prolif_hsa_ew_synergies_150sim = emba::get_synergy_scores(topolink_prolif_hsa_ew_150sim_file) topolink_prolif_hsa_mw_synergies_150sim = emba::get_synergy_scores(topolink_prolif_hsa_mw_150sim_file, file_type = &quot;modelwise&quot;) ## Bliss results ss topolink_ss_bliss_ew_50sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_ss_50sim_fixpoints_bliss_ensemblewise_synergies.tab&quot;) topolink_ss_bliss_mw_50sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_ss_50sim_fixpoints_bliss_modelwise_synergies.tab&quot;) topolink_ss_bliss_ew_150sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_ss_150sim_fixpoints_bliss_ensemblewise_synergies.tab&quot;) topolink_ss_bliss_mw_150sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_ss_150sim_fixpoints_bliss_modelwise_synergies.tab&quot;) topolink_ss_bliss_ew_synergies_50sim = emba::get_synergy_scores(topolink_ss_bliss_ew_50sim_file) topolink_ss_bliss_mw_synergies_50sim = emba::get_synergy_scores(topolink_ss_bliss_mw_50sim_file, file_type = &quot;modelwise&quot;) topolink_ss_bliss_ew_synergies_150sim = emba::get_synergy_scores(topolink_ss_bliss_ew_150sim_file) topolink_ss_bliss_mw_synergies_150sim = emba::get_synergy_scores(topolink_ss_bliss_mw_150sim_file, file_type = &quot;modelwise&quot;) ## Bliss results rand topolink_prolif_bliss_ew_50sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_rand_50sim_fixpoints_bliss_ensemblewise_synergies.tab&quot;) topolink_prolif_bliss_mw_50sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_rand_50sim_fixpoints_bliss_modelwise_synergies.tab&quot;) topolink_prolif_bliss_ew_150sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_rand_150sim_fixpoints_bliss_ensemblewise_synergies.tab&quot;) topolink_prolif_bliss_mw_150sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_rand_150sim_fixpoints_bliss_modelwise_synergies.tab&quot;) topolink_prolif_bliss_ew_synergies_50sim = emba::get_synergy_scores(topolink_prolif_bliss_ew_50sim_file) topolink_prolif_bliss_mw_synergies_50sim = emba::get_synergy_scores(topolink_prolif_bliss_mw_50sim_file, file_type = &quot;modelwise&quot;) topolink_prolif_bliss_ew_synergies_150sim = emba::get_synergy_scores(topolink_prolif_bliss_ew_150sim_file) topolink_prolif_bliss_mw_synergies_150sim = emba::get_synergy_scores(topolink_prolif_bliss_mw_150sim_file, file_type = &quot;modelwise&quot;) # calculate probability of synergy in the modelwise results topolink_ss_hsa_mw_synergies_50sim = topolink_ss_hsa_mw_synergies_50sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topolink_ss_hsa_mw_synergies_150sim = topolink_ss_hsa_mw_synergies_150sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topolink_prolif_hsa_mw_synergies_50sim = topolink_prolif_hsa_mw_synergies_50sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topolink_prolif_hsa_mw_synergies_150sim = topolink_prolif_hsa_mw_synergies_150sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topolink_ss_bliss_mw_synergies_50sim = topolink_ss_bliss_mw_synergies_50sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topolink_ss_bliss_mw_synergies_150sim = topolink_ss_bliss_mw_synergies_150sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topolink_prolif_bliss_mw_synergies_50sim = topolink_prolif_bliss_mw_synergies_50sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topolink_prolif_bliss_mw_synergies_150sim = topolink_prolif_bliss_mw_synergies_150sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) # Tidy the data pred_topolink_ew_hsa = bind_cols( topolink_ss_hsa_ew_synergies_50sim %&gt;% rename(ss_score_50sim = score), topolink_ss_hsa_ew_synergies_150sim %&gt;% select(score) %&gt;% rename(ss_score_150sim = score), topolink_prolif_hsa_ew_synergies_50sim %&gt;% select(score) %&gt;% rename(prolif_score_50sim = score), topolink_prolif_hsa_ew_synergies_150sim %&gt;% select(score) %&gt;% rename(prolif_score_150sim = score), as_tibble_col(observed, column_name = &quot;observed&quot;)) pred_topolink_mw_hsa = bind_cols( topolink_ss_hsa_mw_synergies_50sim %&gt;% select(perturbation, synergy_prob_ss) %&gt;% rename(synergy_prob_ss_50sim = synergy_prob_ss), topolink_ss_hsa_mw_synergies_150sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_ss_150sim = synergy_prob_ss), topolink_prolif_hsa_mw_synergies_50sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_prolif_50sim = synergy_prob_ss), topolink_prolif_hsa_mw_synergies_150sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_prolif_150sim = synergy_prob_ss), as_tibble_col(observed, column_name = &quot;observed&quot;)) pred_topolink_ew_bliss = bind_cols( topolink_ss_bliss_ew_synergies_50sim %&gt;% rename(ss_score_50sim = score), topolink_ss_bliss_ew_synergies_150sim %&gt;% select(score) %&gt;% rename(ss_score_150sim = score), topolink_prolif_bliss_ew_synergies_50sim %&gt;% select(score) %&gt;% rename(prolif_score_50sim = score), topolink_prolif_bliss_ew_synergies_150sim %&gt;% select(score) %&gt;% rename(prolif_score_150sim = score), as_tibble_col(observed, column_name = &quot;observed&quot;)) pred_topolink_mw_bliss = bind_cols( topolink_ss_bliss_mw_synergies_50sim %&gt;% select(perturbation, synergy_prob_ss) %&gt;% rename(synergy_prob_ss_50sim = synergy_prob_ss), topolink_ss_bliss_mw_synergies_150sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_ss_150sim = synergy_prob_ss), topolink_prolif_bliss_mw_synergies_50sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_prolif_50sim = synergy_prob_ss), topolink_prolif_bliss_mw_synergies_150sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_prolif_150sim = synergy_prob_ss), as_tibble_col(observed, column_name = &quot;observed&quot;)) ROC curves (HSA) topolink_res_ss_ew_50sim = get_roc_stats(df = pred_topolink_ew_hsa, pred_col = &quot;ss_score_50sim&quot;, label_col = &quot;observed&quot;) topolink_res_ss_ew_150sim = get_roc_stats(df = pred_topolink_ew_hsa, pred_col = &quot;ss_score_150sim&quot;, label_col = &quot;observed&quot;) topolink_res_prolif_ew_50sim = get_roc_stats(df = pred_topolink_ew_hsa, pred_col = &quot;prolif_score_50sim&quot;, label_col = &quot;observed&quot;) topolink_res_prolif_ew_150sim = get_roc_stats(df = pred_topolink_ew_hsa, pred_col = &quot;prolif_score_150sim&quot;, label_col = &quot;observed&quot;) topolink_res_ss_mw_50sim = get_roc_stats(df = pred_topolink_mw_hsa, pred_col = &quot;synergy_prob_ss_50sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topolink_res_ss_mw_150sim = get_roc_stats(df = pred_topolink_mw_hsa, pred_col = &quot;synergy_prob_ss_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topolink_res_prolif_mw_50sim = get_roc_stats(df = pred_topolink_mw_hsa, pred_col = &quot;synergy_prob_prolif_50sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topolink_res_prolif_mw_150sim = get_roc_stats(df = pred_topolink_mw_hsa, pred_col = &quot;synergy_prob_prolif_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) # Plot ROCs plot(x = topolink_res_ss_ew_50sim$roc_stats$FPR, y = topolink_res_ss_ew_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Ensemble-wise synergies (HSA)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = topolink_res_ss_ew_150sim$roc_stats$FPR, y = topolink_res_ss_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = topolink_res_prolif_ew_50sim$roc_stats$FPR, y = topolink_res_prolif_ew_50sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = topolink_res_prolif_ew_150sim$roc_stats$FPR, y = topolink_res_prolif_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(topolink_res_ss_ew_50sim$AUC, digits = 2), &quot;Calibrated (50 sim)&quot;), paste(round(topolink_res_ss_ew_150sim$AUC, digits = 2), &quot;Calibrated (150 sim)&quot;), paste(round(topolink_res_prolif_ew_50sim$AUC, digits = 2), &quot;Proliferative (50 sim)&quot;), paste(round(topolink_res_prolif_ew_150sim$AUC, digits = 2), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) plot(x = topolink_res_ss_mw_50sim$roc_stats$FPR, y = topolink_res_ss_mw_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Model-wise synergies (HSA)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = topolink_res_ss_mw_150sim$roc_stats$FPR, y = topolink_res_ss_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = topolink_res_prolif_mw_50sim$roc_stats$FPR, y = topolink_res_prolif_mw_50sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = topolink_res_prolif_mw_150sim$roc_stats$FPR, y = topolink_res_prolif_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(topolink_res_ss_mw_50sim$AUC, digits = 2), &quot;Calibrated (50 sim)&quot;), paste(round(topolink_res_ss_mw_150sim$AUC, digits = 2), &quot;Calibrated (150 sim)&quot;), paste(round(topolink_res_prolif_mw_50sim$AUC, digits = 2), &quot;Proliferative (50 sim)&quot;), paste(round(topolink_res_prolif_mw_150sim$AUC, digits = 2), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) PR curves (HSA) pr_topolink_res_ss_ew_50sim = pr.curve(scores.class0 = pred_topolink_ew_hsa %&gt;% pull(ss_score_50sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_hsa %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_topolink_res_ss_ew_150sim = pr.curve(scores.class0 = pred_topolink_ew_hsa %&gt;% pull(ss_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_topolink_res_prolif_ew_50sim = pr.curve(scores.class0 = pred_topolink_ew_hsa %&gt;% pull(prolif_score_50sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_topolink_res_prolif_ew_150sim = pr.curve(scores.class0 = pred_topolink_ew_hsa %&gt;% pull(prolif_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_topolink_res_ss_mw_50sim = pr.curve(scores.class0 = pred_topolink_mw_hsa %&gt;% pull(synergy_prob_ss_50sim), weights.class0 = pred_topolink_mw_hsa %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_topolink_res_ss_mw_150sim = pr.curve(scores.class0 = pred_topolink_mw_hsa %&gt;% pull(synergy_prob_ss_150sim), weights.class0 = pred_topolink_mw_hsa %&gt;% pull(observed), curve = TRUE) pr_topolink_res_prolif_mw_50sim = pr.curve(scores.class0 = pred_topolink_mw_hsa %&gt;% pull(synergy_prob_prolif_50sim), weights.class0 = pred_topolink_mw_hsa %&gt;% pull(observed), curve = TRUE) pr_topolink_res_prolif_mw_150sim = pr.curve(scores.class0 = pred_topolink_mw_hsa %&gt;% pull(synergy_prob_prolif_150sim), weights.class0 = pred_topolink_mw_hsa %&gt;% pull(observed), curve = TRUE) plot(pr_topolink_res_ss_ew_50sim, main = &#39;PR curve, Ensemble-wise synergies (HSA)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_topolink_res_ss_ew_150sim, add = TRUE, color = my_palette[2]) plot(pr_topolink_res_prolif_ew_50sim, add = TRUE, color = my_palette[3]) plot(pr_topolink_res_prolif_ew_150sim, add = TRUE, color = my_palette[4]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(pr_topolink_res_ss_ew_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_topolink_res_ss_ew_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_topolink_res_prolif_ew_50sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (50 sim)&quot;), paste(round(pr_topolink_res_prolif_ew_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) plot(pr_topolink_res_ss_mw_50sim, main = &#39;PR curve, Model-wise synergies (HSA)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_topolink_res_ss_mw_150sim, add = TRUE, color = my_palette[2]) plot(pr_topolink_res_prolif_mw_50sim, add = TRUE, color = my_palette[3]) plot(pr_topolink_res_prolif_mw_150sim, add = TRUE, color = my_palette[4]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(pr_topolink_res_ss_mw_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_topolink_res_ss_mw_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_topolink_res_prolif_mw_50sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (50 sim)&quot;), paste(round(pr_topolink_res_prolif_mw_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) ROC-AUC sensitivity (HSA) Combine the \\(150\\) simulation results (calibrated + proliferative) # Ensemble-wise betas = seq(from = -10, to = 10, by = 0.1) auc_values_ew = sapply(betas, function(beta) { pred_topolink_ew_hsa = pred_topolink_ew_hsa %&gt;% mutate(combined_score = ss_score_150sim + beta * prolif_score_150sim) res = get_roc_stats(df = pred_topolink_ew_hsa, pred_col = &quot;combined_score&quot;, label_col = &quot;observed&quot;) auc_value = res$AUC }) df_ew = as_tibble(cbind(betas, auc_values_ew)) ggline(data = df_ew, x = &quot;betas&quot;, y = &quot;auc_values_ew&quot;, numeric.x.axis = TRUE, plot_type = &quot;l&quot;, xlab = TeX(&quot;$\\\\beta$&quot;), ylab = &quot;AUC (Area Under ROC Curve)&quot;, title = TeX(&quot;AUC sensitivity to $\\\\beta$ parameter: $calibrated + \\\\beta \\\\times random$&quot;), color = my_palette[2], label = &quot;betas&quot;, label.rectangle = TRUE, repel = TRUE, label.select = list(criteria = &quot;`y` == max(`y`)&quot;), font.label = list(size = 14)) + geom_vline(xintercept = 0) + grids() # Model-wise weights = seq(from = 0, to = 1, by = 0.05) auc_values_mw = sapply(weights, function(w) { pred_topolink_mw_hsa = pred_topolink_mw_hsa %&gt;% mutate(weighted_prob = (1 - w) * pred_topolink_mw_hsa$synergy_prob_ss_150sim + w * pred_topolink_mw_hsa$synergy_prob_prolif_150sim) res = get_roc_stats(df = pred_topolink_mw_hsa, pred_col = &quot;weighted_prob&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) auc_value = res$AUC }) df_mw = as_tibble(cbind(weights, auc_values_mw)) ggline(data = df_mw, x = &quot;weights&quot;, y = &quot;auc_values_mw&quot;, numeric.x.axis = TRUE, plot_type = &quot;l&quot;, xlab = TeX(&quot;weight $w$&quot;), ylab = &quot;AUC (Area Under ROC Curve)&quot;, title = TeX(&quot;AUC sensitivity to weighted average score: $(1-w) \\\\times prob_{ss} + w \\\\times prob_{rand}$&quot;), color = my_palette[3]) + grids() PR-AUC sensitivity (HSA) Combine the \\(150\\) simulation results (calibrated + proliferative) # Ensemble-wise betas = seq(from = -10, to = 10, by = 0.1) auc_values_ew = sapply(betas, function(beta) { pred_topolink_ew_hsa = pred_topolink_ew_hsa %&gt;% mutate(combined_score = ss_score_150sim + beta * prolif_score_150sim) res = pr.curve(scores.class0 = pred_topolink_ew_hsa %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_hsa %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_ew = as_tibble(cbind(betas, auc_values_ew)) ggline(data = df_ew, x = &quot;betas&quot;, y = &quot;auc_values_ew&quot;, numeric.x.axis = TRUE, plot_type = &quot;l&quot;, xlab = TeX(&quot;$\\\\beta$&quot;), ylab = &quot;AUC (Area Under PR Curve)&quot;, title = TeX(&quot;AUC sensitivity to $\\\\beta$ parameter: $calibrated + \\\\beta \\\\times random$&quot;), color = my_palette[2], label = &quot;betas&quot;, label.rectangle = TRUE, repel = TRUE, label.select = list(criteria = &quot;`y` == max(`y`)&quot;), font.label = list(size = 14)) + geom_vline(xintercept = 0) + grids() # Model-wise weights = seq(from = 0, to = 1, by = 0.05) auc_values_mw = sapply(weights, function(w) { pred_topolink_mw_hsa = pred_topolink_mw_hsa %&gt;% mutate(weighted_prob = (1 - w) * pred_topolink_mw_hsa$synergy_prob_ss_150sim + w * pred_topolink_mw_hsa$synergy_prob_prolif_150sim) res = pr.curve(scores.class0 = pred_topolink_mw_hsa %&gt;% pull(weighted_prob), weights.class0 = pred_topolink_mw_hsa %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_mw = as_tibble(cbind(weights, auc_values_mw)) ggline(data = df_mw, x = &quot;weights&quot;, y = &quot;auc_values_mw&quot;, numeric.x.axis = TRUE, plot_type = &quot;l&quot;, xlab = TeX(&quot;weight $w$&quot;), ylab = &quot;AUC (Area Under PR Curve)&quot;, title = TeX(&quot;AUC sensitivity to weighted average score: $(1-w) \\\\times prob_{ss} + w \\\\times prob_{rand}$&quot;), color = my_palette[3]) + grids() ROC curves (Bliss) topolink_res_ss_ew_50sim = get_roc_stats(df = pred_topolink_ew_bliss, pred_col = &quot;ss_score_50sim&quot;, label_col = &quot;observed&quot;) topolink_res_ss_ew_150sim = get_roc_stats(df = pred_topolink_ew_bliss, pred_col = &quot;ss_score_150sim&quot;, label_col = &quot;observed&quot;) topolink_res_prolif_ew_50sim = get_roc_stats(df = pred_topolink_ew_bliss, pred_col = &quot;prolif_score_50sim&quot;, label_col = &quot;observed&quot;) topolink_res_prolif_ew_150sim = get_roc_stats(df = pred_topolink_ew_bliss, pred_col = &quot;prolif_score_150sim&quot;, label_col = &quot;observed&quot;) topolink_res_ss_mw_50sim = get_roc_stats(df = pred_topolink_mw_bliss, pred_col = &quot;synergy_prob_ss_50sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topolink_res_ss_mw_150sim = get_roc_stats(df = pred_topolink_mw_bliss, pred_col = &quot;synergy_prob_ss_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topolink_res_prolif_mw_50sim = get_roc_stats(df = pred_topolink_mw_bliss, pred_col = &quot;synergy_prob_prolif_50sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topolink_res_prolif_mw_150sim = get_roc_stats(df = pred_topolink_mw_bliss, pred_col = &quot;synergy_prob_prolif_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) # Plot ROCs plot(x = topolink_res_ss_ew_50sim$roc_stats$FPR, y = topolink_res_ss_ew_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Ensemble-wise synergies (Bliss)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = topolink_res_ss_ew_150sim$roc_stats$FPR, y = topolink_res_ss_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = topolink_res_prolif_ew_50sim$roc_stats$FPR, y = topolink_res_prolif_ew_50sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = topolink_res_prolif_ew_150sim$roc_stats$FPR, y = topolink_res_prolif_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(topolink_res_ss_ew_50sim$AUC, digits = 2), &quot;Calibrated (50 sim)&quot;), paste(round(topolink_res_ss_ew_150sim$AUC, digits = 2), &quot;Calibrated (150 sim)&quot;), paste(round(topolink_res_prolif_ew_50sim$AUC, digits = 2), &quot;Proliferative (50 sim)&quot;), paste(round(topolink_res_prolif_ew_150sim$AUC, digits = 2), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) plot(x = topolink_res_ss_mw_50sim$roc_stats$FPR, y = topolink_res_ss_mw_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Model-wise synergies (Bliss)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = topolink_res_ss_mw_150sim$roc_stats$FPR, y = topolink_res_ss_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = topolink_res_prolif_mw_50sim$roc_stats$FPR, y = topolink_res_prolif_mw_50sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = topolink_res_prolif_mw_150sim$roc_stats$FPR, y = topolink_res_prolif_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(topolink_res_ss_mw_50sim$AUC, digits = 2), &quot;Calibrated (50 sim)&quot;), paste(round(topolink_res_ss_mw_150sim$AUC, digits = 2), &quot;Calibrated (150 sim)&quot;), paste(round(topolink_res_prolif_mw_50sim$AUC, digits = 2), &quot;Proliferative (50 sim)&quot;), paste(round(topolink_res_prolif_mw_150sim$AUC, digits = 2), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) PR curves (Bliss) pr_topolink_res_ss_ew_50sim = pr.curve(scores.class0 = pred_topolink_ew_bliss %&gt;% pull(ss_score_50sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_bliss %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_topolink_res_ss_ew_150sim = pr.curve(scores.class0 = pred_topolink_ew_bliss %&gt;% pull(ss_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_topolink_res_prolif_ew_50sim = pr.curve(scores.class0 = pred_topolink_ew_bliss %&gt;% pull(prolif_score_50sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_topolink_res_prolif_ew_150sim = pr.curve(scores.class0 = pred_topolink_ew_bliss %&gt;% pull(prolif_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_topolink_res_ss_mw_50sim = pr.curve(scores.class0 = pred_topolink_mw_bliss %&gt;% pull(synergy_prob_ss_50sim), weights.class0 = pred_topolink_mw_bliss %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_topolink_res_ss_mw_150sim = pr.curve(scores.class0 = pred_topolink_mw_bliss %&gt;% pull(synergy_prob_ss_150sim), weights.class0 = pred_topolink_mw_bliss %&gt;% pull(observed), curve = TRUE) pr_topolink_res_prolif_mw_50sim = pr.curve(scores.class0 = pred_topolink_mw_bliss %&gt;% pull(synergy_prob_prolif_50sim), weights.class0 = pred_topolink_mw_bliss %&gt;% pull(observed), curve = TRUE) pr_topolink_res_prolif_mw_150sim = pr.curve(scores.class0 = pred_topolink_mw_bliss %&gt;% pull(synergy_prob_prolif_150sim), weights.class0 = pred_topolink_mw_bliss %&gt;% pull(observed), curve = TRUE) plot(pr_topolink_res_ss_ew_50sim, main = &#39;PR curve, Ensemble-wise synergies (Bliss)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_topolink_res_ss_ew_150sim, add = TRUE, color = my_palette[2]) plot(pr_topolink_res_prolif_ew_50sim, add = TRUE, color = my_palette[3]) plot(pr_topolink_res_prolif_ew_150sim, add = TRUE, color = my_palette[4]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(pr_topolink_res_ss_ew_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_topolink_res_ss_ew_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_topolink_res_prolif_ew_50sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (50 sim)&quot;), paste(round(pr_topolink_res_prolif_ew_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) plot(pr_topolink_res_ss_mw_50sim, main = &#39;PR curve, Model-wise synergies (Bliss)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_topolink_res_ss_mw_150sim, add = TRUE, color = my_palette[2]) plot(pr_topolink_res_prolif_mw_50sim, add = TRUE, color = my_palette[3]) plot(pr_topolink_res_prolif_mw_150sim, add = TRUE, color = my_palette[4]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(pr_topolink_res_ss_mw_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_topolink_res_ss_mw_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_topolink_res_prolif_mw_50sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (50 sim)&quot;), paste(round(pr_topolink_res_prolif_mw_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) ROC-AUC sensitivity (Bliss) Combine the \\(150\\) simulation results (calibrated + proliferative) # Ensemble-wise betas = seq(from = -10, to = 10, by = 0.1) auc_values_ew = sapply(betas, function(beta) { pred_topolink_ew_bliss = pred_topolink_ew_bliss %&gt;% mutate(combined_score = ss_score_150sim + beta * prolif_score_150sim) res = get_roc_stats(df = pred_topolink_ew_bliss, pred_col = &quot;combined_score&quot;, label_col = &quot;observed&quot;) auc_value = res$AUC }) df_ew = as_tibble(cbind(betas, auc_values_ew)) ggline(data = df_ew, x = &quot;betas&quot;, y = &quot;auc_values_ew&quot;, numeric.x.axis = TRUE, plot_type = &quot;l&quot;, xlab = TeX(&quot;$\\\\beta$&quot;), ylab = &quot;AUC (Area Under ROC Curve)&quot;, title = TeX(&quot;AUC sensitivity to $\\\\beta$ parameter: $calibrated + \\\\beta \\\\times random$&quot;), color = my_palette[2], label = &quot;betas&quot;, repel = TRUE, label.select = list(criteria = &quot;`y` == max(`y`)&quot;), font.label = list(size = 14)) + geom_vline(xintercept = 0) + grids() # Model-wise weights = seq(from = 0, to = 1, by = 0.05) auc_values_mw = sapply(weights, function(w) { pred_topolink_mw_bliss = pred_topolink_mw_bliss %&gt;% mutate(weighted_prob = (1 - w) * pred_topolink_mw_bliss$synergy_prob_ss_150sim + w * pred_topolink_mw_bliss$synergy_prob_prolif_150sim) res = get_roc_stats(df = pred_topolink_mw_bliss, pred_col = &quot;weighted_prob&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) auc_value = res$AUC }) df_mw = as_tibble(cbind(weights, auc_values_mw)) ggline(data = df_mw, x = &quot;weights&quot;, y = &quot;auc_values_mw&quot;, numeric.x.axis = TRUE, plot_type = &quot;l&quot;, xlab = TeX(&quot;weight $w$&quot;), ylab = &quot;AUC (Area Under ROC Curve)&quot;, title = TeX(&quot;AUC sensitivity to weighted average score: $(1-w) \\\\times prob_{ss} + w \\\\times prob_{rand}$&quot;), color = my_palette[3]) + grids() PR-AUC sensitivity (Bliss) Combine the \\(150\\) simulation results (calibrated + proliferative) # Ensemble-wise betas = seq(from = -10, to = 10, by = 0.1) auc_values_ew = sapply(betas, function(beta) { pred_topolink_ew_bliss = pred_topolink_ew_bliss %&gt;% mutate(combined_score = ss_score_150sim + beta * prolif_score_150sim) res = pr.curve(scores.class0 = pred_topolink_ew_bliss %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_bliss %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_ew = as_tibble(cbind(betas, auc_values_ew)) ggline(data = df_ew, x = &quot;betas&quot;, y = &quot;auc_values_ew&quot;, numeric.x.axis = TRUE, plot_type = &quot;l&quot;, xlab = TeX(&quot;$\\\\beta$&quot;), ylab = &quot;AUC (Area Under PR Curve)&quot;, title = TeX(&quot;AUC sensitivity to $\\\\beta$ parameter: $calibrated + \\\\beta \\\\times random$&quot;), color = my_palette[2], label = &quot;betas&quot;, repel = TRUE, label.select = list(criteria = &quot;`y` == max(`y`)&quot;), font.label = list(size = 14)) + geom_vline(xintercept = 0) + grids() # Model-wise weights = seq(from = 0, to = 1, by = 0.05) auc_values_mw = sapply(weights, function(w) { pred_topolink_mw_bliss = pred_topolink_mw_bliss %&gt;% mutate(weighted_prob = (1 - w) * pred_topolink_mw_bliss$synergy_prob_ss_150sim + w * pred_topolink_mw_bliss$synergy_prob_prolif_150sim) res = pr.curve(scores.class0 = pred_topolink_mw_bliss %&gt;% pull(weighted_prob), weights.class0 = pred_topolink_mw_bliss %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_mw = as_tibble(cbind(weights, auc_values_mw)) ggline(data = df_mw, x = &quot;weights&quot;, y = &quot;auc_values_mw&quot;, numeric.x.axis = TRUE, plot_type = &quot;l&quot;, xlab = TeX(&quot;weight $w$&quot;), ylab = &quot;AUC (Area Under PR Curve)&quot;, title = TeX(&quot;AUC sensitivity to weighted average score: $(1-w) \\\\times prob_{ss} + w \\\\times prob_{rand}$&quot;), color = my_palette[3]) + grids() ROC and PRC for best beta (HSA &amp; Bliss) Use the best betas from the PR-AUC sensitivity graphs (separately for Bliss and HSA)! best_beta_hsa = -1 best_best_bliss = -1.3 pred_topolink_ew_hsa = pred_topolink_ew_hsa %&gt;% mutate(best_score = ss_score_150sim + best_beta_hsa * prolif_score_150sim) pred_topolink_ew_bliss = pred_topolink_ew_bliss %&gt;% mutate(best_score = ss_score_150sim + best_best_bliss * prolif_score_150sim) roc_best_res_hsa = get_roc_stats(df = pred_topolink_ew_hsa, pred_col = &quot;best_score&quot;, label_col = &quot;observed&quot;) roc_best_res_bliss = get_roc_stats(df = pred_topolink_ew_bliss, pred_col = &quot;best_score&quot;, label_col = &quot;observed&quot;) pr_best_res_hsa = pr.curve(scores.class0 = pred_topolink_ew_hsa %&gt;% pull(best_score) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_hsa %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_best_res_bliss = pr.curve(scores.class0 = pred_topolink_ew_bliss %&gt;% pull(best_score) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_bliss %&gt;% pull(observed), curve = TRUE) # Plot best ROCs plot(x = roc_best_res_hsa$roc_stats$FPR, y = roc_best_res_hsa$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = TeX(&#39;ROC curve (Ensemble-wise), $calibrated + \\\\beta \\\\times proliferative$&#39;), xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = roc_best_res_bliss$roc_stats$FPR, y = roc_best_res_bliss$roc_stats$TPR, lwd = 3, col = my_palette[3]) legend(&#39;bottomright&#39;, title = TeX(&#39;AUC ($\\\\beta_{HSA}$ = -1, $\\\\beta_{Bliss}$ = -1.3)&#39;), col = c(my_palette[1], my_palette[3]), pch = 19, legend = c(paste(round(roc_best_res_hsa$AUC, digits = 2), &#39;HSA (150 sim)&#39;), paste(round(roc_best_res_bliss$AUC, digits = 2), &#39;Bliss (150 sim)&#39;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) # Plot best PRCs plot(pr_best_res_hsa, main = TeX(&#39;PR curve (Ensemble-wise), $calibrated + \\\\beta \\\\times proliferative$&#39;), auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_best_res_bliss, add = TRUE, color = my_palette[3]) legend(&#39;topright&#39;, title = TeX(&#39;AUC ($\\\\beta_{HSA}$ = -1, $\\\\beta_{Bliss}$ = -1.3)&#39;), col = c(my_palette[1], my_palette[3]), pch = 19, legend = c(paste(round(pr_best_res_hsa$auc.davis.goadrich, digits = 2), &#39;HSA (150 sim)&#39;), paste(round(pr_best_res_bliss$auc.davis.goadrich, digits = 2), &#39;Bliss (150 sim)&#39;))) grid(lwd = 0.5) "],
["reproduce-simulation-results.html", "Reproduce simulation results ROC curves Random model results", " Reproduce simulation results ROC curves Install druglogics-synergy Run the script run_druglogics_synergy.sh in the above repo using the configuration settings: simulations: 50 attractor_tool: biolqm_stable_states synergy_method: hsa (also rerun the script chaning the synergy method bliss) Thus you will get a directory per simulation and inside will be several result files. To generate the ROC curves, we use the ensemble-wise and model-wise synergies found in each respective simulation. Random model results Use the druglogics-synergy module, version 1.2.0: git checkout v1.2.0 and the abmlog module, version 1.5.0: git checkout v1.5.0. The CASCADE 1.0 and 2.0 .sif network files can be found at the directories ags_cascade_1.0 and ags_cascade_2.0 on the druglogics-synergy repository. Copy these two network files inside the test dir of the abmlog repository root. Run the abmlog for the CASCADE 2.0 topology: java -cp target/abmlog-1.5.0-jar-with-dependencies.jar eu.druglogics.abmlog.RandomBooleanModelGenerator --file=test/cascade_2_0.sif --num=3000 Next, prune the resulting models to only the ones that have 1 stable state (should be \\(1292\\)) using the simple bash script process_models.sh inside the generated models directory from abmlog. cd pathTo/druglogics-synergy/ags_cascade_2.0 Move the abmlog-generated models dir inside the ags_cascade_2.0 dir Use attractor_tool: biolqm_stable_states in the config file Use synergy_method: hsa or synergy_method: bliss in the config file (run twice below command, changing the project to cascade_2.0_random_bliss) Run Drabme via druglogics-synergy: java -cp ../target/synergy-1.2.0-jar-with-dependencies.jar eu.druglogics.drabme.Launcher --project=cascade_2.0_random_hsa --modelsDir=models --drugs=drugpanel --perturbations=perturbations --config=config --modeloutputs=modeloutputs The above procedure is the same for CASCADE 1.0. Changes: The abmlog-generated models directory should be put inside the ags_cascade_1.0 of druglogics-synergy The network file is now for the CASCADE 1.0 (network.sif inside the ags_cascade_1.0) The Drabme command should be run with --project=cascade_1.0_random_hsa and --project=cascade_1.0_random_bliss respectively "],
["r-session-info.html", "R session info", " R session info xfun::session_info() R version 3.6.3 (2020-02-29) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 18.04.4 LTS Locale: LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 LC_PAPER=en_US.UTF-8 LC_NAME=C LC_ADDRESS=C LC_TELEPHONE=C LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C Package version: assertthat_0.2.1 backports_1.1.6 base64enc_0.1.3 BH_1.72.0.3 bibtex_0.4.2.2 bookdown_0.18 broom_0.5.6 callr_3.4.3 Ckmeans.1d.dp_4.3.2 cli_2.0.2 clipr_0.7.0 codetools_0.2-16 colorspace_1.4-1 compiler_3.6.3 corrplot_0.84 cowplot_1.0.0 crayon_1.3.4 crosstalk_1.1.0.1 desc_1.2.0 digest_0.6.25 dplyr_0.8.5 DT_0.13 ellipsis_0.3.0 emba_0.1.4 equatiomatic_0.0.0.9000 evaluate_0.14 fansi_0.4.1 farver_2.0.3 foreach_1.5.0 gbRd_0.4-11 generics_0.0.2 ggplot2_3.3.0 ggpubr_0.2.5 ggrepel_0.8.2 ggsci_2.9 ggsignif_0.6.0 glmnet_3.0-2 glue_1.4.0 graphics_3.6.3 grDevices_3.6.3 grid_3.6.3 gridExtra_2.3 gtable_0.3.0 highr_0.8 hms_0.5.3 htmltools_0.4.0 htmlwidgets_1.5.1 igraph_1.2.5 isoband_0.2.1 iterators_1.0.12 jsonlite_1.6.1 knitr_1.28 labeling_0.3 later_1.0.0 latex2exp_0.4.0 lattice_0.20-41 lazyeval_0.2.2 lifecycle_0.2.0 magrittr_1.5 MAMSE_0.2-1 markdown_1.1 MASS_7.3.51.5 Matrix_1.2-18 methods_3.6.3 mgcv_1.8.31 mime_0.9 munsell_0.5.0 nlme_3.1-145 pillar_1.4.3 pkgbuild_1.0.6 pkgconfig_2.0.3 pkgload_1.0.2 plogr_0.2.0 plyr_1.8.6 polynom_1.4.0 praise_1.0.0 prettyunits_1.1.1 processx_3.4.2 promises_1.1.0 PRROC_1.3.1 ps_1.3.2 purrr_0.3.3 R6_2.4.1 RColorBrewer_1.1-2 Rcpp_1.0.4.6 Rdpack_0.11-1 readr_1.3.1 reshape2_1.4.4 rje_1.10.15 rlang_0.4.5 rmarkdown_2.1 rprojroot_1.3.2 rstudioapi_0.11 scales_1.1.0 shape_1.4.4 splines_3.6.3 stats_3.6.3 stringi_1.4.6 stringr_1.4.0 testthat_2.3.2 tibble_3.0.0 tidyr_1.0.2 tidyselect_1.0.0 tinytex_0.21 tools_3.6.3 usefun_0.4.5 utf8_1.1.4 utils_3.6.3 vctrs_0.2.4 viridisLite_0.3.0 visNetwork_2.0.9 withr_2.1.2 xfun_0.12 yaml_2.2.1 "],
["references.html", "References", " References Flobak, Åsmund, Anaïs Baudot, Elisabeth Remy, Liv Thommesen, Denis Thieffry, Martin Kuiper, and Astrid Lægreid. 2015. “Discovery of Drug Synergies in Gastric Cancer Cells Predicted by Logical Modeling.” Edited by Ioannis Xenarios. PLOS Computational Biology 11 (8): e1004426. https://doi.org/10.1371/journal.pcbi.1004426. Flobak, Åsmund, Barbara Niederdorfer, Vu To Nakstad, Liv Thommesen, Geir Klinkenberg, and Astrid Lægreid. 2019. “A high-throughput drug combination screen of targeted small molecule inhibitors in cancer cell lines.” Scientific Data 6 (1): 237. https://doi.org/10.1038/s41597-019-0255-7. Friedman, Jerome, Trevor Hastie, Rob Tibshirani, Balasubramanian Narasimhan, and Noah Simon. 2019. Glmnet: Lasso and Elastic-Net Regularized Generalized Linear Models. https://CRAN.R-project.org/package=glmnet. Grau, Jan, Ivo Grosse, and Jens Keilwagen. 2015. “PRROC: computing and visualizing precision-recall and receiver operating characteristic curves in R.” Bioinformatics 31 (15): 2595–7. https://doi.org/10.1093/bioinformatics/btv153. Grau, Jan, and Jens Keilwagen. 2018. PRROC: Precision-Recall and Roc Curves for Weighted and Unweighted Data. https://CRAN.R-project.org/package=PRROC. Plante, Jean-Francois. 2017. MAMSE: Calculation of Minimum Averaged Mean Squared Error (Mamse) Weights. https://CRAN.R-project.org/package=MAMSE. Zobolas, John. 2020a. Rtemps: R Templates for Reproducible Data Analyses. https://github.com/bblodfon/rtemps. ———. 2020b. Usefun: A Collection of Useful Functions by John. https://CRAN.R-project.org/package=usefun. "]
]
