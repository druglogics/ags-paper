[
["index.html", "AGS paper I - Supplementary Information (SI) Intro Methodology/Input Overview Summary", " AGS paper I - Supplementary Information (SI) John Zobolas Last updated: 31 July, 2020 Intro This report is the supplementary material for the AGS I Paper and has all the simulation results and investigations related to that paper, as well as instructions for reproducing the results. Methodology/Input Overview A list of things that change between the simulations and the presented graphs are: The number of Gitsbe simulations: more simulations, more models generated. The type of mutation that Gitsbe models have: unless otherwise specified, the Gitsbe models have only link operator mutations. Topology mutations were also tested as well as a combination of topology and link operator mutations. The training data for the Gitsbe models: steady state (calibrated models) vs proliferative profile (random models). The type of mathematical model (HSA or Bliss) used in Drabme to evaluate the synergies either from the (Flobak et al. 2015) for the CASCADE 1.0 analysis or from the (Flobak et al. 2019) dataset for the CASCADE 2.0 analysis. More info on the calcualtions that Drabme does see here. The type of output used from Drabme: ensemble-wise or model-wise synergy results. Summary Observing the results across the whole report, we reach the following conclusions: To minimize the expected performance variance, executing \\(150\\) Gitsbe simulations is a good choice (no need for more, no matter the other input parameters). Ensemble-wise results do not correlate with model-wise results (see correlation results for CASCADE 1.0 and CASCADE 2.0). This happens because some drug perturbed models do not have stable states and thus cannot be evaluated for synergy.1 Model-wise ROC results are always better compared to ensemble-wise ROC results for the single predictor models (e.g. the calibrated non-normalized model results). When using a combined model predictor (see here) to augment/correct the calibrated models results, Drabme’s Bliss synergy assessement always brings significant performance benefit for the ensemble-wise results. When using HSA, that is not always the case (see one example and another). The model-wise results do not bring any performance benefit when used in a combined predictor. The value of \\(\\beta = -1\\) is a good estimation for the value that maximizes the combined predictor’s performance (\\(calibrated + \\beta \\times random\\)) across all of the report’s relevant investigations. Comparing the different parameterization schemes for the CASCADE 2.0 analysis (using the combined predictors with \\(\\beta = -1\\)), we observe that topology mutations outperform link operator mutations. Using minimal trapspaces, where there is almost always an attractor found and the global output of the model can be calculated, we observed higher correlation between ensemble-wise and model-wise results (as expected)↩︎ "],
["r-libraries.html", "R Libraries", " R Libraries For the ROC curves we used the function get_roc_stats() from (Zobolas 2020b) and for the PR curves the pr.curve() from (Grau and Keilwagen 2018) (see also (Grau, Grosse, and Keilwagen 2015)). The AUC sensitivity analysis (for a description see here) was inspired by work from (Pepe 2000). The report template is from the rtemps R package (Zobolas 2020a). Loading libraries that are used in this report: library(DT) library(ggpubr) library(RColorBrewer) library(xfun) library(dplyr) library(tidyr) library(tibble) library(emba) library(usefun) library(readr) library(stringr) library(latex2exp) library(corrplot) library(PRROC) library(equatiomatic) library(glmnet) library(knitr) library(MAMSE) "],
["cascade-1-0-analysis.html", "CASCADE 1.0 Analysis HSA results Bliss results Best ROC and PRC Correlation Fitness Evolution", " CASCADE 1.0 Analysis Performance of automatically parameterized models against published data in (Flobak et al. 2015) HSA results HSA refers to the synergy method used in Drabme to assess the synergies from the gitsbe models We test performance using ROC and PR AUC for both the ensemble-wise and model-wise synergies from Drabme Calibrated models: fitted to steady state (\\(50\\) simulations) Random models: fitted to proliferation profile (\\(50\\) simulations) Gitsbe models have mutations on link operator only Load results: # &#39;ss&#39; =&gt; calibrated models, &#39;prolif&#39; =&gt; proliferative random models # &#39;ew&#39; =&gt; ensemble-wise, &#39;mw&#39; =&gt; model-wise ## HSA results ss_hsa_ew_file = paste0(&quot;results/link-only/hsa/cascade_1.0_ss_50sim_fixpoints_ensemblewise_synergies.tab&quot;) ss_hsa_mw_file = paste0(&quot;results/link-only/hsa/cascade_1.0_ss_50sim_fixpoints_modelwise_synergies.tab&quot;) prolif_hsa_ew_file = paste0(&quot;results/link-only/hsa/cascade_1.0_prolif_50sim_fixpoints_ensemblewise_synergies.tab&quot;) prolif_hsa_mw_file = paste0(&quot;results/link-only/hsa/cascade_1.0_prolif_50sim_fixpoints_modelwise_synergies.tab&quot;) ss_hsa_ensemblewise_synergies = emba::get_synergy_scores(ss_hsa_ew_file) ss_hsa_modelwise_synergies = emba::get_synergy_scores(ss_hsa_mw_file, file_type = &quot;modelwise&quot;) prolif_hsa_ensemblewise_synergies = emba::get_synergy_scores(prolif_hsa_ew_file) prolif_hsa_modelwise_synergies = emba::get_synergy_scores(prolif_hsa_mw_file, file_type = &quot;modelwise&quot;) # calculate probability of synergy in the modelwise results ss_hsa_modelwise_synergies = ss_hsa_modelwise_synergies %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) prolif_hsa_modelwise_synergies = prolif_hsa_modelwise_synergies %&gt;% mutate(synergy_prob_prolif = synergies/(synergies + `non-synergies`)) observed_synergies_file = paste0(&quot;results/observed_synergies_cascade_1.0&quot;) observed_synergies = get_observed_synergies(observed_synergies_file) # 1 (positive/observed synergy) or 0 (negative/not observed) for all tested drug combinations observed = sapply(prolif_hsa_modelwise_synergies$perturbation %in% observed_synergies, as.integer) # &#39;ew&#39; =&gt; ensemble-wise, &#39;mw&#39; =&gt; model-wise pred_ew_hsa = bind_cols(ss_hsa_ensemblewise_synergies %&gt;% rename(ss_score = score), prolif_hsa_ensemblewise_synergies %&gt;% select(score) %&gt;% rename(prolif_score = score), as_tibble_col(observed, column_name = &quot;observed&quot;)) pred_mw_hsa = bind_cols( ss_hsa_modelwise_synergies %&gt;% select(perturbation, synergy_prob_ss), prolif_hsa_modelwise_synergies %&gt;% select(synergy_prob_prolif), as_tibble_col(observed, column_name = &quot;observed&quot;)) ROC curves res_ss_ew = get_roc_stats(df = pred_ew_hsa, pred_col = &quot;ss_score&quot;, label_col = &quot;observed&quot;) res_prolif_ew = get_roc_stats(df = pred_ew_hsa, pred_col = &quot;prolif_score&quot;, label_col = &quot;observed&quot;) res_ss_mw = get_roc_stats(df = pred_mw_hsa, pred_col = &quot;synergy_prob_ss&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_prolif_mw = get_roc_stats(df = pred_mw_hsa, pred_col = &quot;synergy_prob_prolif&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) # Plot ROCs my_palette = RColorBrewer::brewer.pal(n = 9, name = &quot;Set1&quot;) plot(x = res_ss_ew$roc_stats$FPR, y = res_ss_ew$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Ensemble-wise synergies (HSA)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = res_prolif_ew$roc_stats$FPR, y = res_prolif_ew$roc_stats$TPR, lwd = 3, col = my_palette[2]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:2], pch = 19, legend = c(paste(round(res_ss_ew$AUC, digits = 3), &quot;Calibrated&quot;), paste(round(res_prolif_ew$AUC, digits = 3), &quot;Random&quot;)), cex = 1.3) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) plot(x = res_ss_mw$roc_stats$FPR, y = res_ss_mw$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Model-wise synergies (HSA)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = res_prolif_mw$roc_stats$FPR, y = res_prolif_mw$roc_stats$TPR, lwd = 3, col = my_palette[2]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:3], pch = 19, legend = c(paste(round(res_ss_mw$AUC, digits = 3), &quot;Calibrated&quot;), paste(round(res_prolif_mw$AUC, digits = 3), &quot;Random&quot;)), cex = 1.3) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) Figure 1: ROC curves (CASCADE 1.0, HSA synergy method) PR curves pr_ss_ew_hsa = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(ss_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_prolif_ew_hsa = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(prolif_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_ss_mw_hsa = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(synergy_prob_ss), weights.class0 = pred_mw_hsa %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_prolif_mw_hsa = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(synergy_prob_prolif), weights.class0 = pred_mw_hsa %&gt;% pull(observed), curve = TRUE) plot(pr_ss_ew_hsa, main = &#39;PR curve, Ensemble-wise synergies (HSA)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_prolif_ew_hsa, add = TRUE, color = my_palette[2]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:2], pch = 19, legend = c(paste(round(pr_ss_ew_hsa$auc.davis.goadrich, digits = 3), &quot;Calibrated&quot;), paste(round(pr_prolif_ew_hsa$auc.davis.goadrich, digits = 3), &quot;Random&quot;))) grid(lwd = 0.5) plot(pr_ss_mw_hsa, main = &#39;PR curve, Model-wise synergies (HSA)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_prolif_mw_hsa, add = TRUE, color = my_palette[2]) legend(&#39;left&#39;, title = &#39;AUC&#39;, col = my_palette[1:3], pch = 19, legend = c(paste(round(pr_ss_mw_hsa$auc.davis.goadrich, digits = 3), &quot;Calibrated&quot;), paste(round(pr_prolif_mw_hsa$auc.davis.goadrich, digits = 3), &quot;Random&quot;))) grid(lwd = 0.5) Figure 2: PR curves (CASCADE 1.0, HSA synergy method) Calibrated models perform a lot better than the random ones AUC sensitivity Investigate combining the synergy results of calibrated and proliferative (random) models Quantify the amount of information from the proliferative (random) models that can be used to augment the calibrated results? Ensemble-wise scenario: \\(score = calibrated + \\beta \\times random\\) \\(\\beta \\rightarrow +\\infty\\): mostly proliferative (random) model predictions \\(\\beta \\rightarrow -\\infty\\): mostly reverse proliferative (random) model predictions \\(\\beta \\simeq -1\\): calibrated models are normalized against proliferative (random) model predictions. Model-wise scenario: \\((1-w) \\times prob_{cal} + w \\times prob_{rand}, w \\in[0,1]\\) \\(w=0\\): only calibrated model predictions \\(w=1\\): only proliferative (random) model predictions # Ensemble-wise betas = seq(from = -20, to = 20, by = 0.1) prolif_roc = sapply(betas, function(beta) { pred_ew_hsa = pred_ew_hsa %&gt;% mutate(combined_score = ss_score + beta * prolif_score) res = roc.curve(scores.class0 = pred_ew_hsa %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed)) auc_value = res$auc }) prolif_pr = sapply(betas, function(beta) { pred_ew_hsa = pred_ew_hsa %&gt;% mutate(combined_score = ss_score + beta * prolif_score) res = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_ew = as_tibble(cbind(betas, prolif_roc, prolif_pr)) df_ew = df_ew %&gt;% tidyr::pivot_longer(-betas, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_ew, x = &quot;betas&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;$\\\\beta$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: calibrated + β x random&quot;, &quot;ROC: calibrated + β x random&quot;)), title = TeX(&quot;AUC sensitivity to $\\\\beta$ parameter (HSA, CASCADE 1.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + geom_vline(xintercept = 0) + geom_vline(xintercept = -1, color = &quot;red&quot;, size = 0.3, linetype = &quot;dashed&quot;) + geom_text(aes(x=-2, label=&quot;β = -1&quot;, y=0.25), colour=&quot;black&quot;, angle=90) + grids() Figure 3: AUC sensitivity (CASCADE 1.0, HSA synergy method, Ensemble-wise results) # Model-wise weights = seq(from = 0, to = 1, by = 0.05) prolif_roc_mw = sapply(weights, function(w) { pred_mw_hsa = pred_mw_hsa %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_hsa$synergy_prob_ss + w * pred_mw_hsa$synergy_prob_prolif) res = roc.curve(scores.class0 = pred_mw_hsa %&gt;% pull(weighted_prob), weights.class0 = pred_mw_hsa %&gt;% pull(observed)) auc_value = res$auc }) prolif_pr_mw = sapply(weights, function(w) { pred_mw_hsa = pred_mw_hsa %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_hsa$synergy_prob_ss + w * pred_mw_hsa$synergy_prob_prolif) res = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(weighted_prob), weights.class0 = pred_mw_hsa %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_mw = as_tibble(cbind(weights, prolif_roc_mw, prolif_pr_mw)) df_mw = df_mw %&gt;% tidyr::pivot_longer(-weights, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_mw, x = &quot;weights&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;weight $w$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: (1-w) x prob(cal) + w x prob(rand)&quot;, &quot;ROC: (1-w) x prob(cal) + w x prob(prolif)&quot;)), title.position = &quot;center&quot;, title = TeX(&quot;AUC sensitivity to weighted average score (HSA, CASCADE 1.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + grids() Figure 4: AUC sensitivity (CASCADE 1.0, HSA synergy method, Model-wise results) There are \\(\\beta\\) values that can boost the predictive performance of the calibrated models (ensemble-wise) but no \\(w\\) weight in the model-wise case. \\(\\beta=-1\\) seems to be a common value that maximizes both the ROC-AUC and the PR-AUC. The PR-AUC is more sensitive than the ROC-AUC, so a better indicator of performance. Bliss results Bliss refers to the synergy method used in Drabme to assess the synergies from the gitsbe models We test performance using ROC and PR AUC for both the ensemble-wise and model-wise synergies from Drabme Calibrated models: fitted to steady state (\\(50\\) simulations) Random models: fitted to proliferation profile (\\(50\\) simulations) Gitsbe models have mutations on link operator only Load results: # &#39;ss&#39; =&gt; calibrated models, &#39;prolif&#39; =&gt; random models ## Bliss results ss_bliss_ensemblewise_file = paste0(&quot;results/link-only/bliss/cascade_1.0_ss_50sim_fixpoints_ensemblewise_synergies.tab&quot;) ss_bliss_modelwise_file = paste0(&quot;results/link-only/bliss/cascade_1.0_ss_50sim_fixpoints_modelwise_synergies.tab&quot;) prolif_bliss_ensemblewise_file = paste0(&quot;results/link-only/bliss/cascade_1.0_prolif_50sim_fixpoints_ensemblewise_synergies.tab&quot;) prolif_bliss_modelwise_file = paste0(&quot;results/link-only/bliss/cascade_1.0_prolif_50sim_fixpoints_modelwise_synergies.tab&quot;) ss_bliss_ensemblewise_synergies = emba::get_synergy_scores(ss_bliss_ensemblewise_file) ss_bliss_modelwise_synergies = emba::get_synergy_scores(ss_bliss_modelwise_file, file_type = &quot;modelwise&quot;) prolif_bliss_ensemblewise_synergies = emba::get_synergy_scores(prolif_bliss_ensemblewise_file) prolif_bliss_modelwise_synergies = emba::get_synergy_scores(prolif_bliss_modelwise_file, file_type = &quot;modelwise&quot;) # calculate probability of synergy in the modelwise results ss_bliss_modelwise_synergies = ss_bliss_modelwise_synergies %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) prolif_bliss_modelwise_synergies = prolif_bliss_modelwise_synergies %&gt;% mutate(synergy_prob_prolif = synergies/(synergies + `non-synergies`)) # &#39;ew&#39; =&gt; ensemble-wise, &#39;mw&#39; =&gt; model-wise pred_ew_bliss = bind_cols(ss_bliss_ensemblewise_synergies %&gt;% rename(ss_score = score), prolif_bliss_ensemblewise_synergies %&gt;% select(score) %&gt;% rename(prolif_score = score), as_tibble_col(observed, column_name = &quot;observed&quot;)) pred_mw_bliss = bind_cols( ss_bliss_modelwise_synergies %&gt;% select(perturbation, synergy_prob_ss), prolif_bliss_modelwise_synergies %&gt;% select(synergy_prob_prolif), as_tibble_col(observed, column_name = &quot;observed&quot;)) ROC curves res_ss_ew = get_roc_stats(df = pred_ew_bliss, pred_col = &quot;ss_score&quot;, label_col = &quot;observed&quot;) res_prolif_ew = get_roc_stats(df = pred_ew_bliss, pred_col = &quot;prolif_score&quot;, label_col = &quot;observed&quot;) res_ss_mw = get_roc_stats(df = pred_mw_bliss, pred_col = &quot;synergy_prob_ss&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_prolif_mw = get_roc_stats(df = pred_mw_bliss, pred_col = &quot;synergy_prob_prolif&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) # Plot ROCs plot(x = res_ss_ew$roc_stats$FPR, y = res_ss_ew$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Ensemble-wise synergies (Bliss)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = res_prolif_ew$roc_stats$FPR, y = res_prolif_ew$roc_stats$TPR, lwd = 3, col = my_palette[2]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:2], pch = 19, legend = c(paste(round(res_ss_ew$AUC, digits = 3), &quot;Calibrated&quot;), paste(round(res_prolif_ew$AUC, digits = 3), &quot;Random&quot;)), cex = 1.3) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) plot(x = res_ss_mw$roc_stats$FPR, y = res_ss_mw$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Model-wise synergies (Bliss)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = res_prolif_mw$roc_stats$FPR, y = res_prolif_mw$roc_stats$TPR, lwd = 3, col = my_palette[2]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:2], pch = 19, legend = c(paste(round(res_ss_mw$AUC, digits = 3), &quot;Calibrated&quot;), paste(round(res_prolif_mw$AUC, digits = 3), &quot;Random&quot;)), cex = 1.3) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) Figure 5: ROC curves (CASCADE 1.0, Bliss synergy method) The ROC statistics data for the calibrated models are as follows: DT::datatable(data = res_ss_ew$roc_stats, options = list(pageLength = 5, lengthMenu = c(5, 10, 16), searching = FALSE)) %&gt;% formatRound(c(1,6,7,8,9), digits = 3) Figure 6: ROC data for Calibrated Models (CASCADE 1.0, Bliss synergy method) PR curves pr_ss_ew_bliss = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(ss_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_prolif_ew_bliss = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(prolif_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_ss_mw_bliss = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(synergy_prob_ss), weights.class0 = pred_mw_bliss %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_prolif_mw_bliss = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(synergy_prob_prolif), weights.class0 = pred_mw_bliss %&gt;% pull(observed), curve = TRUE) plot(pr_ss_ew_bliss, main = &#39;PR curve, Ensemble-wise synergies (Bliss)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_prolif_ew_bliss, add = TRUE, color = my_palette[2]) legend(x = 0, y = 0.9, title = &#39;AUC&#39;, col = my_palette[1:2], pch = 19, cex = 1.3, legend = c(paste(round(pr_ss_ew_bliss$auc.davis.goadrich, digits = 3), &quot;Calibrated&quot;), paste(round(pr_prolif_ew_bliss$auc.davis.goadrich, digits = 3), &quot;Random&quot;))) grid(lwd = 0.5) plot(pr_ss_mw_bliss, main = &#39;PR curve, Model-wise synergies (Bliss)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_prolif_mw_bliss, add = TRUE, color = my_palette[2]) legend(x = 0, y = 0.9, title = &#39;AUC&#39;, col = my_palette[1:3], pch = 19, cex = 1.3, legend = c(paste(round(pr_ss_mw_bliss$auc.davis.goadrich, digits = 3), &quot;Calibrated&quot;), paste(round(pr_prolif_mw_bliss$auc.davis.goadrich, digits = 3), &quot;Random&quot;))) grid(lwd = 0.5) Figure 7: PR curves (CASCADE 1.0, Bliss synergy method) Calibrated models perform a lot better than the random ones AUC sensitivity Investigate same thing as described in here. # Ensemble-wise betas = seq(from = -20, to = 20, by = 0.1) prolif_roc = sapply(betas, function(beta) { pred_ew_bliss = pred_ew_bliss %&gt;% mutate(combined_score = ss_score + beta * prolif_score) res = roc.curve(scores.class0 = pred_ew_bliss %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed)) auc_value = res$auc }) prolif_pr = sapply(betas, function(beta) { pred_ew_bliss = pred_ew_bliss %&gt;% mutate(combined_score = ss_score + beta * prolif_score) res = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_ew = as_tibble(cbind(betas, prolif_roc, prolif_pr)) df_ew = df_ew %&gt;% tidyr::pivot_longer(-betas, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_ew, x = &quot;betas&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;$\\\\beta$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: calibrated + β x random&quot;, &quot;ROC: calibrated + β x random&quot;)), title = TeX(&quot;AUC sensitivity to $\\\\beta$ parameter (Bliss, CASCADE 1.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + geom_vline(xintercept = 0) + geom_vline(xintercept = -1, color = &quot;red&quot;, size = 0.3, linetype = &quot;dashed&quot;) + geom_text(aes(x=-2, label=&quot;β = -1&quot;, y=0.25), colour=&quot;black&quot;, angle=90) + grids() Figure 8: AUC sensitivity (CASCADE 1.0, Bliss synergy method, Ensemble-wise results) # Model-wise weights = seq(from = 0, to = 1, by = 0.05) prolif_roc_mw = sapply(weights, function(w) { pred_mw_bliss = pred_mw_bliss %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_bliss$synergy_prob_ss + w * pred_mw_bliss$synergy_prob_prolif) res = roc.curve(scores.class0 = pred_mw_bliss %&gt;% pull(weighted_prob), weights.class0 = pred_mw_bliss %&gt;% pull(observed)) auc_value = res$auc }) prolif_pr_mw = sapply(weights, function(w) { pred_mw_bliss = pred_mw_bliss %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_bliss$synergy_prob_ss + w * pred_mw_bliss$synergy_prob_prolif) res = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(weighted_prob), weights.class0 = pred_mw_bliss %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_mw = as_tibble(cbind(weights, prolif_roc_mw, prolif_pr_mw)) df_mw = df_mw %&gt;% tidyr::pivot_longer(-weights, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_mw, x = &quot;weights&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;weight $w$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: (1-w) x prob(cal) + w x prob(rand)&quot;, &quot;ROC: (1-w) x prob(cal) + w x prob(rand)&quot;)), title.position = &quot;center&quot;, title = TeX(&quot;AUC sensitivity to weighted average score (Bliss, CASCADE 1.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + grids() Figure 9: AUC sensitivity (CASCADE 1.0, Bliss synergy method, Model-wise results) There are \\(\\beta\\) values that can boost the predictive performance of the calibrated models (ensemble-wise) but no \\(w\\) weight in the model-wise case. The PR-AUC is more sensitive than the ROC-AUC, so a better indicator of performance. A value very close to \\(\\beta=-1\\) seems to be the one maximizes both the ROC-AUC and the PR-AUC. The ROC ensemble-wise statistics data for the combined predictor \\(calibrated + \\beta \\times random, \\beta=-1\\) are: beta = -1 pred_ew_bliss = pred_ew_bliss %&gt;% mutate(combined_score = ss_score + beta * prolif_score) res_comb_pred = get_roc_stats(df = pred_ew_bliss, pred_col = &quot;combined_score&quot;, label_col = &quot;observed&quot;) DT::datatable(data = res_comb_pred$roc_stats, options = list(pageLength = 5, lengthMenu = c(5, 10, 16), searching = FALSE)) %&gt;% formatRound(c(1,6,7,8,9), digits = 3) Figure 10: ROC data for Combined Predictor (CASCADE 1.0, Bliss synergy method) Best ROC and PRC In the next plot, Calibrated stands for the combined predictor results, i.e. \\(calibrated + \\beta \\times random, \\beta=-1\\). plot(x = res_comb_pred$roc_stats$FPR, y = res_comb_pred$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Ensemble-wise synergies (Bliss)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = res_prolif_ew$roc_stats$FPR, y = res_prolif_ew$roc_stats$TPR, lwd = 3, col = my_palette[2]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:2], pch = 19, legend = c(paste(round(res_comb_pred$AUC, digits = 3), &quot;Calibrated&quot;), paste(round(res_prolif_ew$AUC, digits = 3), &quot;Random&quot;)), cex = 1.3) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) res_comb_pred_pr = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) plot(res_comb_pred_pr, main = &#39;PR curve, Ensemble-wise synergies (Bliss)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_prolif_ew_bliss, add = TRUE, color = my_palette[2]) legend(x = 0, y = 0.9, title = &#39;AUC&#39;, col = my_palette[1:2], pch = 19, cex = 1.3, legend = c(paste(round(res_comb_pred_pr$auc.davis.goadrich, digits = 3), &quot;Calibrated&quot;), paste(round(pr_prolif_ew_bliss$auc.davis.goadrich, digits = 3), &quot;Random&quot;))) grid(lwd = 0.5) Figure 11: ROC and PR curves for Random and Best Combined Predictor (CASCADE 1.0, Bliss synergy method) Correlation We test for correlation between all the synergy predictor results shown in the previous curves. This means ensemble-wise vs model-wise, random proliferative models vs calibrated models and HSA vs Bliss synergy assessment. P-values are represented at 3 significant levels: \\(0.05, 0.01, 0.001\\) (*, **, ***) and the correlation coefficient is calculated using Kendall’s tau statistic. synergy_scores = bind_cols( pred_ew_hsa %&gt;% select(ss_score, prolif_score) %&gt;% rename(cal_ew_hsa = ss_score, random_ew_hsa = prolif_score), pred_ew_bliss %&gt;% select(ss_score, prolif_score) %&gt;% rename(cal_ew_bliss = ss_score, random_ew_bliss = prolif_score), pred_mw_hsa %&gt;% select(synergy_prob_ss, synergy_prob_prolif) %&gt;% rename(cal_mw_hsa = synergy_prob_ss, random_mw_hsa = synergy_prob_prolif), pred_mw_bliss %&gt;% select(synergy_prob_ss, synergy_prob_prolif) %&gt;% rename(cal_mw_bliss = synergy_prob_ss, random_mw_bliss = synergy_prob_prolif) ) M = cor(synergy_scores, method = &quot;kendall&quot;) res = cor.mtest(synergy_scores, method = &quot;kendall&quot;) corrplot(corr = M, type = &quot;upper&quot;, p.mat = res$p, sig.level = c(.001, .01, .05), pch.cex = 1, pch.col = &quot;white&quot;, insig = &quot;label_sig&quot;, tl.col = &quot;black&quot;, tl.srt = 45) Figure 12: Correlation Plot for CASCADE 1.0 Results Model-wise don’t correlate a lot with ensemble-wise results (topright part of the correlation plot). HSA and Bliss results correlate, higher for the model-wise (bottomright) than the ensemble-wise results (topleft). Calibrated results also show some correlation with the random results Fitness Evolution We did a test run of Gitsbe with \\(1000\\) simulations, fitting to steady state (generating thus calibrated models). The only difference between the following results and the ones above is the total number of simulations specified in the configuration and that the option bootstrap_mutations_factor was set to \\(1\\) (to avoid reaching good fitness models in the earlier generations). Firstly, we show the fitness evolution of the first \\(20\\) simulations. Each data point is the average fitness in that generation out of \\(20\\) models. Note that some simulations end because the target fitness is reached by some of the models (\\(0.99\\)). read_summary_file = function(file_name) { lines = readr::read_lines(file = file_name, skip = 5, skip_empty_rows = TRUE) data_list = list() index = 1 gen_fit_list = list() gen_index = 1 for (line_index in 1:length(lines)) { line = lines[line_index] if (stringr::str_detect(string = line, pattern = &quot;Simulation&quot;)) { data_list[[index]] = bind_cols(gen_fit_list) index = index + 1 gen_fit_list = list() gen_index = 1 } else { # read fitness values gen_fit_list[[gen_index]] = as_tibble_col(as.numeric(unlist(strsplit(line, split = &#39;\\t&#39;)))) gen_index = gen_index + 1 } } # add the last simulation&#39;s values data_list[[index]] = bind_cols(gen_fit_list) return(data_list) } fitness_summary_file = &quot;results/link-only/hsa/cascade_1.0_ss_1000sim_fixpoints_hsa_summary.txt&quot; # rows = simulations, columns = generations # value in (sim,gen) cell = average fitness of models in that particular (sim,gen) combination fit_res = read_summary_file(file_name = fitness_summary_file) first_sim_data = colMeans(fit_res[[1]]) plot(1:length(first_sim_data), y = first_sim_data, ylim = c(0,1), xlim = c(0,20), type = &#39;l&#39;, lwd = 1.5, main = &#39;Fitness Evolution across Generations&#39;, xlab = &#39;Generations&#39;, ylab = &#39;Average Fitness&#39;, col = usefun:::colors.100[1]) index = 2 for (fit_data in fit_res) { if (index &gt; 20) break #if (ncol(fit_data) != 20) next mean_fit_per_gen = colMeans(fit_data) lines(x = 1:length(mean_fit_per_gen), y = mean_fit_per_gen, lwd = 1.5, col = usefun:::colors.100[index]) index = index + 1 } grid(lwd = 0.5) Figure 13: Fitness Evolution (10 simulations, CASCADE 1.0) Next, we plot the average fitness + standard deviation per generation across all \\(1000\\) simulations: avg_fit = do.call(dplyr::bind_rows, sapply(fit_res, colMeans)) colnames(avg_fit) = 1:ncol(avg_fit) avg_fit_long = avg_fit %&gt;% pivot_longer(cols = everything()) %&gt;% mutate(name = as.integer(name)) ggline(data = avg_fit_long, x = &quot;name&quot;, y = &quot;value&quot;, color = my_palette[2], add = &quot;mean_sd&quot;, add.params = list(color = &quot;black&quot;), ylim = c(0, 1), main = &quot;Fitness Evolution across Generations&quot;, xlab = &quot;Generations&quot;, ylab = &quot;Fitness&quot;) + theme(plot.title = element_text(hjust = 0.5)) + grids() Figure 14: Fitness Evolution (1000 simulations, CASCADE 1.0) # DIY way: # df = avg_fit_long %&gt;% group_by(name) %&gt;% # summarise(median = median(value, na.rm = TRUE), # mean = mean(value, na.rm = TRUE), # sd = sd(value, na.rm = TRUE)) # # ggplot(data = df, aes(x=name, y=mean)) + # ggtitle(&quot;Fitness Evolution across Generations&quot;) + # xlab(&quot;Generations&quot;) + ylab(&quot;Fitness&quot;) + # geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=.2) + # geom_line(color=&#39;steelblue&#39;) + # geom_point(color=&#39;steelblue&#39;) + # theme_pubr() + theme(plot.title = element_text(hjust = 0.5)) + # grids() The average fitness stabilizes after \\(\\approx 10-15\\) generations but also the standard deviation: new models are still being created through the crossover genetic algorithm phase to explore various model parameterization while keeping the fitness score relatively high. The S-shaped (sigmoid) curve is in agreement with Holland’s schema theorem (Holland 1992). "],
["cascade-2-0-analysis-link-operator-mutations.html", "CASCADE 2.0 Analysis (Link Operator Mutations) HSA results Bliss results Best ROC and PRC Correlation Fitness Evolution", " CASCADE 2.0 Analysis (Link Operator Mutations) Performance of automatically parameterized models against SINTEF dataset (Flobak et al. 2019) HSA results HSA refers to the synergy method used in Drabme to assess the synergies from the gitsbe models We test performance using ROC and PR AUC for both the ensemble-wise and model-wise synergies from Drabme Calibrated models: fitted to steady state (\\(50,100,150,200\\) simulations) Proliferative models: fitted to proliferation profile (\\(150\\) simulations) Random models: produced via abmlog (see here and used in Drabme with synergy_method: hsa Gitsbe models have mutations on link operator only Load results: # &#39;ss&#39; =&gt; calibrated models, &#39;random&#39; =&gt; random models, &#39;prolif&#39; =&gt; proliferative models # &#39;ew&#39; =&gt; ensemble-wise, &#39;mw&#39; =&gt; model-wise ## HSA results ss_hsa_ensemblewise_50sim_file = paste0(&quot;results/link-only/hsa/cascade_2.0_ss_50sim_fixpoints_ensemblewise_synergies.tab&quot;) ss_hsa_modelwise_50sim_file = paste0(&quot;results/link-only/hsa/cascade_2.0_ss_50sim_fixpoints_modelwise_synergies.tab&quot;) ss_hsa_ensemblewise_100sim_file = paste0(&quot;results/link-only/hsa/cascade_2.0_ss_100sim_fixpoints_ensemblewise_synergies.tab&quot;) ss_hsa_modelwise_100sim_file = paste0(&quot;results/link-only/hsa/cascade_2.0_ss_100sim_fixpoints_modelwise_synergies.tab&quot;) ss_hsa_ensemblewise_150sim_file = paste0(&quot;results/link-only/hsa/cascade_2.0_ss_150sim_fixpoints_ensemblewise_synergies.tab&quot;) ss_hsa_modelwise_150sim_file = paste0(&quot;results/link-only/hsa/cascade_2.0_ss_150sim_fixpoints_modelwise_synergies.tab&quot;) ss_hsa_ensemblewise_200sim_file = paste0(&quot;results/link-only/hsa/cascade_2.0_ss_200sim_fixpoints_ensemblewise_synergies.tab&quot;) ss_hsa_modelwise_200sim_file = paste0(&quot;results/link-only/hsa/cascade_2.0_ss_200sim_fixpoints_modelwise_synergies.tab&quot;) prolif_hsa_ensemblewise_file = paste0(&quot;results/link-only/hsa/cascade_2.0_prolif_150sim_fixpoints_hsa_ensemblewise_synergies.tab&quot;) prolif_hsa_modelwise_file = paste0(&quot;results/link-only/hsa/cascade_2.0_prolif_150sim_fixpoints_hsa_modelwise_synergies.tab&quot;) random_hsa_ensemblewise_file = paste0(&quot;results/link-only/hsa/cascade_2.0_random_ensemblewise_synergies.tab&quot;) random_hsa_modelwise_file = paste0(&quot;results/link-only/hsa/cascade_2.0_random_modelwise_synergies.tab&quot;) ss_hsa_ensemblewise_synergies_50sim = emba::get_synergy_scores(ss_hsa_ensemblewise_50sim_file) ss_hsa_modelwise_synergies_50sim = emba::get_synergy_scores(ss_hsa_modelwise_50sim_file, file_type = &quot;modelwise&quot;) ss_hsa_ensemblewise_synergies_100sim = emba::get_synergy_scores(ss_hsa_ensemblewise_100sim_file) ss_hsa_modelwise_synergies_100sim = emba::get_synergy_scores(ss_hsa_modelwise_100sim_file, file_type = &quot;modelwise&quot;) ss_hsa_ensemblewise_synergies_150sim = emba::get_synergy_scores(ss_hsa_ensemblewise_150sim_file) ss_hsa_modelwise_synergies_150sim = emba::get_synergy_scores(ss_hsa_modelwise_150sim_file, file_type = &quot;modelwise&quot;) ss_hsa_ensemblewise_synergies_200sim = emba::get_synergy_scores(ss_hsa_ensemblewise_200sim_file) ss_hsa_modelwise_synergies_200sim = emba::get_synergy_scores(ss_hsa_modelwise_200sim_file, file_type = &quot;modelwise&quot;) prolif_hsa_ensemblewise_synergies_150sim = emba::get_synergy_scores(prolif_hsa_ensemblewise_file) prolif_hsa_modelwise_synergies_150sim = emba::get_synergy_scores(prolif_hsa_modelwise_file, file_type = &quot;modelwise&quot;) random_hsa_ensemblewise_synergies = emba::get_synergy_scores(random_hsa_ensemblewise_file) random_hsa_modelwise_synergies = emba::get_synergy_scores(random_hsa_modelwise_file, file_type = &quot;modelwise&quot;) # calculate probability of synergy in the modelwise results ss_hsa_modelwise_synergies_50sim = ss_hsa_modelwise_synergies_50sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) ss_hsa_modelwise_synergies_100sim = ss_hsa_modelwise_synergies_100sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) ss_hsa_modelwise_synergies_150sim = ss_hsa_modelwise_synergies_150sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) ss_hsa_modelwise_synergies_200sim = ss_hsa_modelwise_synergies_200sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) prolif_hsa_modelwise_synergies_150sim = prolif_hsa_modelwise_synergies_150sim %&gt;% mutate(synergy_prob_prolif = synergies/(synergies + `non-synergies`)) random_hsa_modelwise_synergies = random_hsa_modelwise_synergies %&gt;% mutate(synergy_prob_random = synergies/(synergies + `non-synergies`)) observed_synergies_file = paste0(&quot;results/observed_synergies_cascade_2.0&quot;) observed_synergies = get_observed_synergies(observed_synergies_file) # 1 (positive/observed synergy) or 0 (negative/not observed) for all tested drug combinations observed = sapply(random_hsa_modelwise_synergies$perturbation %in% observed_synergies, as.integer) # &#39;ew&#39; =&gt; ensemble-wise, &#39;mw&#39; =&gt; model-wise pred_ew_hsa = bind_cols( ss_hsa_ensemblewise_synergies_50sim %&gt;% select(score) %&gt;% rename(ss_score_50sim = score), ss_hsa_ensemblewise_synergies_100sim %&gt;% select(score) %&gt;% rename(ss_score_100sim = score), ss_hsa_ensemblewise_synergies_150sim %&gt;% select(score) %&gt;% rename(ss_score_150sim = score), ss_hsa_ensemblewise_synergies_200sim %&gt;% select(score) %&gt;% rename(ss_score_200sim = score), prolif_hsa_ensemblewise_synergies_150sim %&gt;% select(score) %&gt;% rename(prolif_score_150sim = score), random_hsa_ensemblewise_synergies %&gt;% select(score) %&gt;% rename(random_score = score), as_tibble_col(observed, column_name = &quot;observed&quot;)) pred_mw_hsa = bind_cols( ss_hsa_modelwise_synergies_50sim %&gt;% select(perturbation, synergy_prob_ss) %&gt;% rename(synergy_prob_ss_50sim = synergy_prob_ss), ss_hsa_modelwise_synergies_100sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_ss_100sim = synergy_prob_ss), ss_hsa_modelwise_synergies_150sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_ss_150sim = synergy_prob_ss), ss_hsa_modelwise_synergies_200sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_ss_200sim = synergy_prob_ss), prolif_hsa_modelwise_synergies_150sim %&gt;% select(synergy_prob_prolif) %&gt;% rename(synergy_prob_prolif_150sim = synergy_prob_prolif), random_hsa_modelwise_synergies %&gt;% select(synergy_prob_random), as_tibble_col(observed, column_name = &quot;observed&quot;)) ROC curves res_ss_ew_50sim = get_roc_stats(df = pred_ew_hsa, pred_col = &quot;ss_score_50sim&quot;, label_col = &quot;observed&quot;) res_ss_ew_100sim = get_roc_stats(df = pred_ew_hsa, pred_col = &quot;ss_score_100sim&quot;, label_col = &quot;observed&quot;) res_ss_ew_150sim = get_roc_stats(df = pred_ew_hsa, pred_col = &quot;ss_score_150sim&quot;, label_col = &quot;observed&quot;) res_ss_ew_200sim = get_roc_stats(df = pred_ew_hsa, pred_col = &quot;ss_score_200sim&quot;, label_col = &quot;observed&quot;) res_prolif_ew_150sim = get_roc_stats(df = pred_ew_hsa, pred_col = &quot;prolif_score_150sim&quot;, label_col = &quot;observed&quot;) res_random_ew = get_roc_stats(df = pred_ew_hsa, pred_col = &quot;random_score&quot;, label_col = &quot;observed&quot;) res_ss_mw_50sim = get_roc_stats(df = pred_mw_hsa, pred_col = &quot;synergy_prob_ss_50sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_ss_mw_100sim = get_roc_stats(df = pred_mw_hsa, pred_col = &quot;synergy_prob_ss_100sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_ss_mw_150sim = get_roc_stats(df = pred_mw_hsa, pred_col = &quot;synergy_prob_ss_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_ss_mw_200sim = get_roc_stats(df = pred_mw_hsa, pred_col = &quot;synergy_prob_ss_200sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_prolif_mw_150sim = get_roc_stats(df = pred_mw_hsa, pred_col = &quot;synergy_prob_prolif_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_random_mw = get_roc_stats(df = pred_mw_hsa, pred_col = &quot;synergy_prob_random&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) # Plot ROCs plot(x = res_ss_ew_50sim$roc_stats$FPR, y = res_ss_ew_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Ensemble-wise synergies (HSA)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = res_ss_ew_100sim$roc_stats$FPR, y = res_ss_ew_100sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = res_ss_ew_150sim$roc_stats$FPR, y = res_ss_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = res_ss_ew_200sim$roc_stats$FPR, y = res_ss_ew_200sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) lines(x = res_prolif_ew_150sim$roc_stats$FPR, y = res_prolif_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[5]) lines(x = res_random_ew$roc_stats$FPR, y = res_random_ew$roc_stats$TPR, lwd = 3, col = my_palette[6]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:6], pch = 19, legend = c(paste(round(res_ss_ew_50sim$AUC, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(res_ss_ew_100sim$AUC, digits = 3), &quot;Calibrated (100 sim)&quot;), paste(round(res_ss_ew_150sim$AUC, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(res_ss_ew_200sim$AUC, digits = 3), &quot;Calibrated (200 sim)&quot;), paste(round(res_prolif_ew_150sim$AUC, digits = 3), &quot;Proliferative (150 sim)&quot;), paste(round(res_random_ew$AUC, digits = 3), &quot;Random&quot;)), cex = 0.9) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) plot(x = res_ss_mw_50sim$roc_stats$FPR, y = res_ss_mw_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Model-wise synergies (HSA)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = res_ss_mw_100sim$roc_stats$FPR, y = res_ss_mw_100sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = res_ss_mw_150sim$roc_stats$FPR, y = res_ss_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = res_ss_mw_200sim$roc_stats$FPR, y = res_ss_mw_200sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) lines(x = res_prolif_mw_150sim$roc_stats$FPR, y = res_prolif_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[5]) lines(x = res_random_mw$roc_stats$FPR, y = res_random_mw$roc_stats$TPR, lwd = 3, col = my_palette[6]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:6], pch = 19, legend = c(paste(round(res_ss_mw_50sim$AUC, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(res_ss_mw_100sim$AUC, digits = 3), &quot;Calibrated (100 sim)&quot;), paste(round(res_ss_mw_150sim$AUC, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(res_ss_mw_200sim$AUC, digits = 3), &quot;Calibrated (200 sim)&quot;), paste(round(res_prolif_mw_150sim$AUC, digits = 3), &quot;Proliferative (150 sim)&quot;), paste(round(res_random_mw$AUC, digits = 3), &quot;Random&quot;)), cex = 0.9) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) Figure 15: ROC curves (CASCADE 2.0, HSA synergy method) PR curves pr_ss_ew_hsa_50sim = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(ss_score_50sim) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_ss_ew_hsa_100sim = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(ss_score_100sim) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_ss_ew_hsa_150sim = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(ss_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_ss_ew_hsa_200sim = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(ss_score_200sim) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_prolif_ew_hsa_150sim = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(prolif_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_random_ew_hsa = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(random_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_ss_mw_hsa_50sim = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(synergy_prob_ss_50sim), weights.class0 = pred_mw_hsa %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_ss_mw_hsa_100sim = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(synergy_prob_ss_100sim), weights.class0 = pred_mw_hsa %&gt;% pull(observed), curve = TRUE) pr_ss_mw_hsa_150sim = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(synergy_prob_ss_150sim), weights.class0 = pred_mw_hsa %&gt;% pull(observed), curve = TRUE) pr_ss_mw_hsa_200sim = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(synergy_prob_ss_200sim), weights.class0 = pred_mw_hsa %&gt;% pull(observed), curve = TRUE) pr_prolif_mw_hsa_150sim = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(synergy_prob_prolif_150sim), weights.class0 = pred_mw_hsa %&gt;% pull(observed), curve = TRUE) pr_random_mw_hsa = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(synergy_prob_random), weights.class0 = pred_mw_hsa %&gt;% pull(observed), curve = TRUE) plot(pr_ss_ew_hsa_50sim, main = &#39;PR curve, Ensemble-wise synergies (HSA)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_ss_ew_hsa_100sim, add = TRUE, color = my_palette[2]) plot(pr_ss_ew_hsa_150sim, add = TRUE, color = my_palette[3]) plot(pr_ss_ew_hsa_200sim, add = TRUE, color = my_palette[4]) plot(pr_prolif_ew_hsa_150sim, add = TRUE, color = my_palette[5]) plot(pr_random_ew_hsa, add = TRUE, color = my_palette[6]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:6], pch = 19, legend = c(paste(round(pr_ss_ew_hsa_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_ss_ew_hsa_100sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (100 sim)&quot;), paste(round(pr_ss_ew_hsa_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_ss_ew_hsa_200sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (200 sim)&quot;), paste(round(pr_prolif_ew_hsa_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (150 sim)&quot;), paste(round(pr_random_ew_hsa$auc.davis.goadrich, digits = 3), &quot;Random&quot;))) grid(lwd = 0.5) plot(pr_ss_mw_hsa_50sim, main = &#39;PR curve, Model-wise synergies (HSA)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_ss_mw_hsa_100sim, add = TRUE, color = my_palette[2]) plot(pr_ss_mw_hsa_150sim, add = TRUE, color = my_palette[3]) plot(pr_ss_mw_hsa_200sim, add = TRUE, color = my_palette[4]) plot(pr_prolif_mw_hsa_150sim, add = TRUE, color = my_palette[5]) plot(pr_random_mw_hsa, add = TRUE, color = my_palette[6]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:6], pch = 19, legend = c(paste(round(pr_ss_mw_hsa_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_ss_mw_hsa_100sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (100 sim)&quot;), paste(round(pr_ss_mw_hsa_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_ss_mw_hsa_200sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (200 sim)&quot;), paste(round(pr_prolif_mw_hsa_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (200 sim)&quot;), paste(round(pr_random_mw_hsa$auc.davis.goadrich, digits = 3), &quot;Random&quot;))) grid(lwd = 0.5) Figure 16: PR curves (CASCADE 2.0, HSA synergy method) To minimize the resulting performance variance, \\(150\\) seems to be a good number of Gitsbe simulations to run for the CASCADE 2.0 network. The PR curves show that the performance of each individual predictor is poor compared to the baseline. Someone looking at the ROC curves only might reach a different conclusion. Proliferative and random models perform almost equally well to calibrated models. The model-wise approach produces slightly better ROC results than the ensemble-wise approach AUC sensitivity Investigate same thing as described in here. This is very crucial since the PR performance is poor for the individual predictors, but a combined predictor might be able to counter this. We will combine the synergy scores from the random and proliferative simulations with the results from the calibrated Gitsbe simulations (number of simulations: \\(150\\)). # Ensemble-wise betas = seq(from = -7.5, to = 7.5, by = 0.1) random_roc = sapply(betas, function(beta) { pred_ew_hsa = pred_ew_hsa %&gt;% mutate(combined_score = ss_score_150sim + beta * random_score) res = roc.curve(scores.class0 = pred_ew_hsa %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed)) auc_value = res$auc }) prolif_roc = sapply(betas, function(beta) { pred_ew_hsa = pred_ew_hsa %&gt;% mutate(combined_score = ss_score_150sim + beta * prolif_score_150sim) res = roc.curve(scores.class0 = pred_ew_hsa %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed)) auc_value = res$auc }) random_pr = sapply(betas, function(beta) { pred_ew_hsa = pred_ew_hsa %&gt;% mutate(combined_score = ss_score_150sim + beta * random_score) res = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) prolif_pr = sapply(betas, function(beta) { pred_ew_hsa = pred_ew_hsa %&gt;% mutate(combined_score = ss_score_150sim + beta * prolif_score_150sim) res = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_ew = as_tibble(cbind(betas, random_roc, prolif_roc, random_pr, prolif_pr)) df_ew = df_ew %&gt;% tidyr::pivot_longer(-betas, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_ew, x = &quot;betas&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;$\\\\beta$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: calibrated + β x proliferative&quot;, &quot;ROC: calibrated + β x proliferative&quot;, &quot;PR: calibrated + β x random&quot;, &quot;ROC: calibrated + β x random&quot;)), title = TeX(&quot;AUC sensitivity to $\\\\beta$ parameter (HSA, CASCADE 2.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + geom_vline(xintercept = 0) + geom_vline(xintercept = -1, color = &quot;red&quot;, size = 0.3, linetype = &quot;dashed&quot;) + geom_text(aes(x=-1.5, label=&quot;β = -1&quot;, y=0.25), colour=&quot;black&quot;, angle=90) + grids() Figure 17: AUC sensitivity (CASCADE 2.0, HSA synergy method, Ensemble-wise results) # Model-wise weights = seq(from = 0, to = 1, by = 0.05) random_roc_mw = sapply(weights, function(w) { pred_mw_hsa = pred_mw_hsa %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_hsa$synergy_prob_ss_150sim + w * pred_mw_hsa$synergy_prob_random) res = roc.curve(scores.class0 = pred_mw_hsa %&gt;% pull(weighted_prob), weights.class0 = pred_mw_hsa %&gt;% pull(observed)) auc_value = res$auc }) prolif_roc_mw = sapply(weights, function(w) { pred_mw_hsa = pred_mw_hsa %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_hsa$synergy_prob_ss_150sim + w * pred_mw_hsa$synergy_prob_prolif_150sim) res = roc.curve(scores.class0 = pred_mw_hsa %&gt;% pull(weighted_prob), weights.class0 = pred_mw_hsa %&gt;% pull(observed)) auc_value = res$auc }) random_pr_mw = sapply(weights, function(w) { pred_mw_hsa = pred_mw_hsa %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_hsa$synergy_prob_ss_150sim + w * pred_mw_hsa$synergy_prob_random) res = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(weighted_prob), weights.class0 = pred_mw_hsa %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) prolif_pr_mw = sapply(weights, function(w) { pred_mw_hsa = pred_mw_hsa %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_hsa$synergy_prob_ss_150sim + w * pred_mw_hsa$synergy_prob_prolif_150sim) res = pr.curve(scores.class0 = pred_mw_hsa %&gt;% pull(weighted_prob), weights.class0 = pred_mw_hsa %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_mw = as_tibble(cbind(weights, random_roc_mw, prolif_roc_mw, random_pr_mw, prolif_pr_mw)) df_mw = df_mw %&gt;% tidyr::pivot_longer(-weights, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_mw, x = &quot;weights&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;weight $w$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: (1-w) x prob(ss) + w x prob(prolif)&quot;, &quot;ROC: (1-w) x prob(ss) + w x prob(prolif)&quot;, &quot;PR: (1-w) x prob(ss) + w x prob(random)&quot;, &quot;ROC: (1-w) x prob(ss) + w x prob(random)&quot;)), title.position = &quot;center&quot;, title = TeX(&quot;AUC sensitivity to weighted average score (HSA, CASCADE 2.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + grids() Figure 18: AUC sensitivity (CASCADE 2.0, HSA synergy method, Model-wise results) No added benefit when using the model-wise approach. Neither the random nor the proliferative models bring any significant change to the prediction performance of the calibrated models (ensemble-wise). Only the proliferative models seem to add a small contribution to the calibrated models performance (top-right panel =&gt; ROC-AUC increases, PR-AUC is insignificantly changed nonetheless). The \\(\\beta_{best}\\) that maximizes the ROC and PR AUC for the combination of proliferative and calibrated models and is equal to \\(\\beta_{best}=-0.3\\). For \\(\\beta=-1\\) we do not observe performance improvement in this case. Logistic Regression Analysis We tried fitting a model using logistic regression as a different approach to combine/augment the results from calibrated simulations with the proliferative ones (for the HSA-assessed ensemble-wise results where there was a minimal benefit). model = glm(formula = observed ~ ss_score_150sim + prolif_score_150sim - 1, data = pred_ew_hsa, family = binomial()) model_tidy = broom::tidy(model) coef1 = model_tidy %&gt;% filter(term == &quot;ss_score_150sim&quot;) %&gt;% pull(estimate) coef2 = model_tidy %&gt;% filter(term == &quot;prolif_score_150sim&quot;) %&gt;% pull(estimate) pred_ew_hsa = pred_ew_hsa %&gt;% mutate(glm = coef1 * ss_score_150sim + coef2 * prolif_score_150sim) res_roc = get_roc_stats(df = pred_ew_hsa, pred_col = &quot;glm&quot;, label_col = &quot;observed&quot;) res_pr = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(glm) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed)) The model with the coefficients is as follows (note that adding an intercept makes ROC AUC result considerably worse): extract_eq(model, use_coefs = TRUE) \\[ \\log\\left[ \\frac { P( \\text{observed} = \\text{1} ) }{ 1 - P( \\text{observed} = \\text{1} ) } \\right] = -10.63(\\text{ss\\_score\\_150sim}) + 42.92(\\text{prolif\\_score\\_150sim}) + \\epsilon \\] The ROC AUC produced with a logistic regression model is lower than the calibrated models (with \\(150\\) Gitsbe simulations): 0.5782313 (PR-AUC is also lower: 0.0527052). Regularized Logistic Regression Analysis Because the coefficient values found from the above approach are large, we try a regularized logistic regression approach using the glmnet R package (Friedman et al. 2020). We cross validate the \\(\\lambda\\) parameter and try with different \\(\\alpha \\in [0,1]\\) (\\(\\alpha=0\\) means Ridge regression, \\(\\alpha=1\\) means LASSO, in between means Elastic net) while either minimizing the missclassification error (type.measure=\"class\") or maximizing the ROC-AUC (type.measure = \"auc\"). For each respective \\(\\alpha\\) we choose the \\(\\lambda_{min}\\) as the one the minimizes the average CV error. The intercept was again excluded as it resulted in worse AUC performance. x = pred_ew_hsa %&gt;% select(ss_score_150sim, prolif_score_150sim) %&gt;% as.matrix() y = pred_ew_hsa %&gt;% pull(observed) data_list = list() index = 1 for (i in 0:10) { # from Ridge to LASSO a = i/10 for (measure in c(&quot;auc&quot;, &quot;class&quot;)) { set.seed(42) # for reproducibility cvfit = cv.glmnet(x, y, family = &quot;binomial&quot;, type.measure = measure, intercept = FALSE, alpha = a) coef_mat = coef(cvfit, s = &quot;lambda.min&quot;) pred_ew_hsa = pred_ew_hsa %&gt;% mutate(glm_reg = coef_mat[1] + coef_mat[2] * ss_score_150sim + coef_mat[3] * random_score) res_roc = get_roc_stats(df = pred_ew_hsa, pred_col = &quot;glm_reg&quot;, label_col = &quot;observed&quot;) pr_roc = pr.curve(scores.class0 = pred_ew_hsa %&gt;% pull(glm_reg) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_hsa %&gt;% pull(observed)) data_list[[index]] = as_tibble_row(list(alpha = a, measure = measure, ROC_AUC = res_roc$AUC, PR_AUC = pr_roc$auc.davis.goadrich)) index = index + 1 } } data = bind_rows(data_list) # List the best two results data %&gt;% arrange(desc(ROC_AUC)) %&gt;% slice(1:4) %&gt;% kable() alpha measure ROC_AUC PR_AUC 0.0 auc 0.6916100 0.0643565 0.0 class 0.6916100 0.0643565 0.3 auc 0.6768707 0.0655809 0.5 auc 0.6746032 0.0645385 The best ROC AUC produced with a regularized logistic regression model is also lower than the one using calibrated models alone (with \\(150\\) Gitsbe simulations). Note that we get warnings when using glmnet because of the small number of observations for the positive class (observed synergies). Resulting coefficients vary, but tend to be either all too small or larger on the proliferative model predictor. MAMSE ROC Analysis Using the MAMSE R package (Plante 2017) we try another method to combine the predictor values from the calibrated and proliferative models. The resulting ROC curve gets a little bit distored and AUC is not statistically better from the reference sample population (i.e. the calibrated Gitsbe models with \\(150\\) simulations): # healthy =&gt; non-synergy, diseased =&gt; synergy healthy = list() healthy[[1]] = pred_ew_hsa %&gt;% filter(observed == 0) %&gt;% pull(ss_score_150sim) healthy[[2]] = pred_ew_hsa %&gt;% filter(observed == 0) %&gt;% pull(prolif_score_150sim) diseased = list() diseased[[1]] = pred_ew_hsa %&gt;% filter(observed == 1) %&gt;% pull(ss_score_150sim) diseased[[2]] = pred_ew_hsa %&gt;% filter(observed == 1) %&gt;% pull(prolif_score_150sim) plot(roc(healthy = healthy, diseased = diseased, smalldiseased=TRUE, AUC=TRUE, wh=NULL, wd=NULL, FPR=NULL, method=&quot;np&quot;)) Figure 19: Combined Ensemble-wise Classifier using MAMSE ROC (CASCADE 2.0, HSA) Bliss results Bliss refers to the synergy method used in Drabme to assess the synergies from the gitsbe models We test performance using ROC and PR AUC for both the ensemble-wise and model-wise synergies from Drabme Calibrated models: fitted to steady state (\\(50,100,150,200\\) simulations) Proliferative models: fitted to proliferation profile (\\(150\\) simulations) Random models: produced via abmlog (see here and used in Drabme with synergy_method: bliss Gitsbe models have mutations on link operator only Load results: # &#39;ss&#39; =&gt; calibrated models, &#39;random&#39; =&gt; random models ## Bliss results ss_bliss_ensemblewise_50sim_file = paste0(&quot;results/link-only/bliss/cascade_2.0_ss_50sim_fixpoints_ensemblewise_synergies.tab&quot;) ss_bliss_modelwise_50sim_file = paste0(&quot;results/link-only/bliss/cascade_2.0_ss_50sim_fixpoints_modelwise_synergies.tab&quot;) ss_bliss_ensemblewise_100sim_file = paste0(&quot;results/link-only/bliss/cascade_2.0_ss_100sim_fixpoints_ensemblewise_synergies.tab&quot;) ss_bliss_modelwise_100sim_file = paste0(&quot;results/link-only/bliss/cascade_2.0_ss_100sim_fixpoints_modelwise_synergies.tab&quot;) ss_bliss_ensemblewise_150sim_file = paste0(&quot;results/link-only/bliss/cascade_2.0_ss_150sim_fixpoints_ensemblewise_synergies.tab&quot;) ss_bliss_modelwise_150sim_file = paste0(&quot;results/link-only/bliss/cascade_2.0_ss_150sim_fixpoints_modelwise_synergies.tab&quot;) ss_bliss_ensemblewise_200sim_file = paste0(&quot;results/link-only/bliss/cascade_2.0_ss_200sim_fixpoints_ensemblewise_synergies.tab&quot;) ss_bliss_modelwise_200sim_file = paste0(&quot;results/link-only/bliss/cascade_2.0_ss_200sim_fixpoints_modelwise_synergies.tab&quot;) prolif_bliss_ensemblewise_150sim_file = paste0(&quot;results/link-only/bliss/cascade_2.0_prolif_150sim_fixpoints_bliss_ensemblewise_synergies.tab&quot;) prolif_bliss_modelwise_150sim_file = paste0(&quot;results/link-only/bliss/cascade_2.0_prolif_150sim_fixpoints_bliss_modelwise_synergies.tab&quot;) random_bliss_ensemblewise_file = paste0(&quot;results/link-only/bliss/cascade_2.0_random_bliss_ensemblewise_synergies.tab&quot;) random_bliss_modelwise_file = paste0(&quot;results/link-only/bliss/cascade_2.0_random_bliss_modelwise_synergies.tab&quot;) ss_bliss_ensemblewise_synergies_50sim = emba::get_synergy_scores(ss_bliss_ensemblewise_50sim_file) ss_bliss_modelwise_synergies_50sim = emba::get_synergy_scores(ss_bliss_modelwise_50sim_file, file_type = &quot;modelwise&quot;) ss_bliss_ensemblewise_synergies_100sim = emba::get_synergy_scores(ss_bliss_ensemblewise_100sim_file) ss_bliss_modelwise_synergies_100sim = emba::get_synergy_scores(ss_bliss_modelwise_100sim_file, file_type = &quot;modelwise&quot;) ss_bliss_ensemblewise_synergies_150sim = emba::get_synergy_scores(ss_bliss_ensemblewise_150sim_file) ss_bliss_modelwise_synergies_150sim = emba::get_synergy_scores(ss_bliss_modelwise_150sim_file, file_type = &quot;modelwise&quot;) ss_bliss_ensemblewise_synergies_200sim = emba::get_synergy_scores(ss_bliss_ensemblewise_200sim_file) ss_bliss_modelwise_synergies_200sim = emba::get_synergy_scores(ss_bliss_modelwise_200sim_file, file_type = &quot;modelwise&quot;) prolif_bliss_ensemblewise_synergies_150sim = emba::get_synergy_scores(prolif_bliss_ensemblewise_150sim_file) prolif_bliss_modelwise_synergies_150sim = emba::get_synergy_scores(prolif_bliss_modelwise_150sim_file, file_type = &quot;modelwise&quot;) random_bliss_ensemblewise_synergies = emba::get_synergy_scores(random_bliss_ensemblewise_file) random_bliss_modelwise_synergies = emba::get_synergy_scores(random_bliss_modelwise_file, file_type = &quot;modelwise&quot;) # calculate probability of synergy in the modelwise results ss_bliss_modelwise_synergies_50sim = ss_bliss_modelwise_synergies_50sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) ss_bliss_modelwise_synergies_100sim = ss_bliss_modelwise_synergies_100sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) ss_bliss_modelwise_synergies_150sim = ss_bliss_modelwise_synergies_150sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) ss_bliss_modelwise_synergies_200sim = ss_bliss_modelwise_synergies_200sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) prolif_bliss_modelwise_synergies_150sim = prolif_bliss_modelwise_synergies_150sim %&gt;% mutate(synergy_prob_prolif = synergies/(synergies + `non-synergies`)) random_bliss_modelwise_synergies = random_bliss_modelwise_synergies %&gt;% mutate(synergy_prob_random = synergies/(synergies + `non-synergies`)) # tidy data pred_ew_bliss = bind_cols( ss_bliss_ensemblewise_synergies_50sim %&gt;% select(perturbation, score) %&gt;% rename(ss_score_50sim = score), ss_bliss_ensemblewise_synergies_100sim %&gt;% select(score) %&gt;% rename(ss_score_100sim = score), ss_bliss_ensemblewise_synergies_150sim %&gt;% select(score) %&gt;% rename(ss_score_150sim = score), ss_bliss_ensemblewise_synergies_200sim %&gt;% select(score) %&gt;% rename(ss_score_200sim = score), prolif_bliss_ensemblewise_synergies_150sim %&gt;% select(score) %&gt;% rename(prolif_score_150sim = score), random_bliss_ensemblewise_synergies %&gt;% select(score) %&gt;% rename(random_score = score), as_tibble_col(observed, column_name = &quot;observed&quot;)) pred_mw_bliss = bind_cols( ss_bliss_modelwise_synergies_50sim %&gt;% select(perturbation, synergy_prob_ss) %&gt;% rename(synergy_prob_ss_50sim = synergy_prob_ss), ss_bliss_modelwise_synergies_100sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_ss_100sim = synergy_prob_ss), ss_bliss_modelwise_synergies_150sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_ss_150sim = synergy_prob_ss), ss_bliss_modelwise_synergies_200sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_ss_200sim = synergy_prob_ss), prolif_bliss_modelwise_synergies_150sim %&gt;% select(synergy_prob_prolif) %&gt;% rename(synergy_prob_prolif_150sim = synergy_prob_prolif), random_bliss_modelwise_synergies %&gt;% select(synergy_prob_random), as_tibble_col(observed, column_name = &quot;observed&quot;)) ROC curves # &#39;ew&#39; =&gt; ensemble-wise, &#39;mw&#39; =&gt; model-wise res_ss_ew_50sim = get_roc_stats(df = pred_ew_bliss, pred_col = &quot;ss_score_50sim&quot;, label_col = &quot;observed&quot;) res_ss_ew_100sim = get_roc_stats(df = pred_ew_bliss, pred_col = &quot;ss_score_100sim&quot;, label_col = &quot;observed&quot;) res_ss_ew_150sim = get_roc_stats(df = pred_ew_bliss, pred_col = &quot;ss_score_150sim&quot;, label_col = &quot;observed&quot;) res_ss_ew_200sim = get_roc_stats(df = pred_ew_bliss, pred_col = &quot;ss_score_200sim&quot;, label_col = &quot;observed&quot;) res_prolif_ew_150sim = get_roc_stats(df = pred_ew_bliss, pred_col = &quot;prolif_score_150sim&quot;, label_col = &quot;observed&quot;) res_random_ew = get_roc_stats(df = pred_ew_bliss, pred_col = &quot;random_score&quot;, label_col = &quot;observed&quot;) res_ss_mw_50sim = get_roc_stats(df = pred_mw_bliss, pred_col = &quot;synergy_prob_ss_50sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_ss_mw_100sim = get_roc_stats(df = pred_mw_bliss, pred_col = &quot;synergy_prob_ss_100sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_ss_mw_150sim = get_roc_stats(df = pred_mw_bliss, pred_col = &quot;synergy_prob_ss_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_ss_mw_200sim = get_roc_stats(df = pred_mw_bliss, pred_col = &quot;synergy_prob_ss_200sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_prolif_mw_150sim = get_roc_stats(df = pred_mw_bliss, pred_col = &quot;synergy_prob_prolif_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) res_random_mw = get_roc_stats(df = pred_mw_bliss, pred_col = &quot;synergy_prob_random&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) # Plot ROCs plot(x = res_ss_ew_50sim$roc_stats$FPR, y = res_ss_ew_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Ensemble-wise synergies (Bliss)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = res_ss_ew_100sim$roc_stats$FPR, y = res_ss_ew_100sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = res_ss_ew_150sim$roc_stats$FPR, y = res_ss_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = res_ss_ew_200sim$roc_stats$FPR, y = res_ss_ew_200sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) lines(x = res_prolif_ew_150sim$roc_stats$FPR, y = res_prolif_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[5]) lines(x = res_random_ew$roc_stats$FPR, y = res_random_ew$roc_stats$TPR, lwd = 3, col = my_palette[6]) legend(&#39;topleft&#39;, title = &#39;AUC&#39;, col = my_palette[1:6], pch = 19, legend = c(paste(round(res_ss_ew_50sim$AUC, digits = 2), &quot;Calibrated (50 sim)&quot;), paste(round(res_ss_ew_100sim$AUC, digits = 2), &quot;Calibrated (100 sim)&quot;), paste(round(res_ss_ew_150sim$AUC, digits = 2), &quot;Calibrated (150 sim)&quot;), paste(round(res_ss_ew_200sim$AUC, digits = 2), &quot;Calibrated (200 sim)&quot;), paste(round(res_prolif_ew_150sim$AUC, digits = 2), &quot;Proliferative (150 sim)&quot;), paste(round(res_random_ew$AUC, digits = 2), &quot;Random&quot;)), cex = 0.8) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) plot(x = res_ss_mw_50sim$roc_stats$FPR, y = res_ss_mw_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Model-wise synergies (Bliss)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = res_ss_mw_100sim$roc_stats$FPR, y = res_ss_mw_100sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = res_ss_mw_150sim$roc_stats$FPR, y = res_ss_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = res_ss_mw_200sim$roc_stats$FPR, y = res_ss_mw_200sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) lines(x = res_prolif_mw_150sim$roc_stats$FPR, y = res_prolif_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[5]) lines(x = res_random_mw$roc_stats$FPR, y = res_random_mw$roc_stats$TPR, lwd = 3, col = my_palette[6]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:6], pch = 19, cex = 0.9, legend = c(paste(round(res_ss_mw_50sim$AUC, digits = 2), &quot;Calibrated (50 sim)&quot;), paste(round(res_ss_mw_100sim$AUC, digits = 2), &quot;Calibrated (100 sim)&quot;), paste(round(res_ss_mw_150sim$AUC, digits = 2), &quot;Calibrated (150 sim)&quot;), paste(round(res_ss_mw_200sim$AUC, digits = 2), &quot;Calibrated (200 sim)&quot;), paste(round(res_prolif_mw_150sim$AUC, digits = 2), &quot;Proliferative (150 sim)&quot;), paste(round(res_random_mw$AUC, digits = 2), &quot;Random&quot;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) Figure 20: ROC curves (CASCADE 2.0, Bliss synergy method) PR curves pr_ss_ew_bliss_50sim = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(ss_score_50sim) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_ss_ew_bliss_100sim = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(ss_score_100sim) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_ss_ew_bliss_150sim = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(ss_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_ss_ew_bliss_200sim = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(ss_score_200sim) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_prolif_ew_bliss_150sim = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(prolif_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_random_ew_bliss = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(random_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_ss_mw_bliss_50sim = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(synergy_prob_ss_50sim), weights.class0 = pred_mw_bliss %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_ss_mw_bliss_100sim = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(synergy_prob_ss_100sim), weights.class0 = pred_mw_bliss %&gt;% pull(observed), curve = TRUE) pr_ss_mw_bliss_150sim = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(synergy_prob_ss_150sim), weights.class0 = pred_mw_bliss %&gt;% pull(observed), curve = TRUE) pr_ss_mw_bliss_200sim = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(synergy_prob_ss_200sim), weights.class0 = pred_mw_bliss %&gt;% pull(observed), curve = TRUE) pr_prolif_mw_bliss_150sim = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(synergy_prob_prolif_150sim), weights.class0 = pred_mw_bliss %&gt;% pull(observed), curve = TRUE) pr_random_mw_bliss = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(synergy_prob_random), weights.class0 = pred_mw_bliss %&gt;% pull(observed), curve = TRUE) plot(pr_ss_ew_bliss_50sim, main = &#39;PR curve, Ensemble-wise synergies (Bliss)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_ss_ew_bliss_100sim, add = TRUE, color = my_palette[2]) plot(pr_ss_ew_bliss_150sim, add = TRUE, color = my_palette[3]) plot(pr_ss_ew_bliss_200sim, add = TRUE, color = my_palette[4]) plot(pr_prolif_ew_bliss_150sim, add = TRUE, color = my_palette[5]) plot(pr_random_ew_bliss, add = TRUE, color = my_palette[6]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:6], pch = 19, legend = c(paste(round(pr_ss_ew_bliss_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_ss_ew_bliss_100sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (100 sim)&quot;), paste(round(pr_ss_ew_bliss_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_ss_ew_bliss_200sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (200 sim)&quot;), paste(round(pr_prolif_ew_bliss_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (150 sim)&quot;), paste(round(pr_random_ew_bliss$auc.davis.goadrich, digits = 3), &quot;Random&quot;))) grid(lwd = 0.5) plot(pr_ss_mw_bliss_50sim, main = &#39;PR curve, Model-wise synergies (Bliss)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_ss_mw_bliss_100sim, add = TRUE, color = my_palette[2]) plot(pr_ss_mw_bliss_150sim, add = TRUE, color = my_palette[3]) plot(pr_ss_mw_bliss_200sim, add = TRUE, color = my_palette[4]) plot(pr_prolif_mw_bliss_150sim, add = TRUE, color = my_palette[5]) plot(pr_random_mw_bliss, add = TRUE, color = my_palette[6]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:6], pch = 19, legend = c(paste(round(pr_ss_mw_bliss_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_ss_mw_bliss_100sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (100 sim)&quot;), paste(round(pr_ss_mw_bliss_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_ss_mw_bliss_200sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (200 sim)&quot;), paste(round(pr_prolif_mw_bliss_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (150 sim)&quot;), paste(round(pr_random_mw_bliss$auc.davis.goadrich, digits = 3), &quot;Random&quot;))) grid(lwd = 0.5) Figure 21: PR curves (CASCADE 2.0, Bliss synergy method) To minimize the resulting performance variance, \\(150\\) seems to be a good number of Gitsbe simulations to run for the CASCADE 2.0 network. Individual predictor model-wise results (when looking at the ROC curves) show good performance. Individual predictor ensemble-wise results show that proliferative and calibrated models have poor performance whereas random models perform like proper random models (\\(AUC\\sim0.5\\))) The PR curves show that the performance of all individual predictors is poor compared to the baseline. AUC sensitivity Investigate same thing as described in here. This is very crucial since the PR performance is poor for the individual predictors and the ensemble-wise predictors were really bad in terms of AUC-ROC, but a combined predictor might be able to counter this. We will combine the synergy scores from the random and proliferative simulations with the results from the calibrated Gitsbe simulations (number of simulations: \\(150\\)). # Ensemble-wise betas = seq(from = -10, to = 10, by = 0.1) random_roc = sapply(betas, function(beta) { pred_ew_bliss = pred_ew_bliss %&gt;% mutate(combined_score = ss_score_50sim + beta * random_score) res = roc.curve(scores.class0 = pred_ew_bliss %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed)) auc_value = res$auc }) prolif_roc = sapply(betas, function(beta) { pred_ew_bliss = pred_ew_bliss %&gt;% mutate(combined_score = ss_score_50sim + beta * prolif_score_150sim) res = roc.curve(scores.class0 = pred_ew_bliss %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed)) auc_value = res$auc }) random_pr = sapply(betas, function(beta) { pred_ew_bliss = pred_ew_bliss %&gt;% mutate(combined_score = ss_score_50sim + beta * random_score) res = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) prolif_pr = sapply(betas, function(beta) { pred_ew_bliss = pred_ew_bliss %&gt;% mutate(combined_score = ss_score_50sim + beta * prolif_score_150sim) res = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_ew = as_tibble(cbind(betas, random_roc, prolif_roc, random_pr, prolif_pr)) df_ew = df_ew %&gt;% tidyr::pivot_longer(-betas, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_ew, x = &quot;betas&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;$\\\\beta$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: calibrated + β x proliferative&quot;, &quot;ROC: calibrated + β x proliferative&quot;, &quot;PR: calibrated + β x random&quot;, &quot;ROC: calibrated + β x random&quot;)), title = TeX(&quot;AUC sensitivity to $\\\\beta$ parameter (Bliss, CASCADE 2.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + geom_vline(xintercept = 0) + geom_vline(xintercept = -1.6, color = &quot;red&quot;, size = 0.3, linetype = &quot;dashed&quot;) + geom_text(aes(x=-4, label=&quot;β = -1.6&quot;, y=0.15), colour=&quot;black&quot;) + grids() Figure 22: AUC sensitivity (CASCADE 2.0, Bliss synergy method, Ensemble-wise results) # Model-wise weights = seq(from = 0, to = 1, by = 0.05) random_roc_mw = sapply(weights, function(w) { pred_mw_bliss = pred_mw_bliss %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_bliss$synergy_prob_ss_150sim + w * pred_mw_bliss$synergy_prob_random) res = roc.curve(scores.class0 = pred_mw_bliss %&gt;% pull(weighted_prob), weights.class0 = pred_mw_bliss %&gt;% pull(observed)) auc_value = res$auc }) prolif_roc_mw = sapply(weights, function(w) { pred_mw_bliss = pred_mw_bliss %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_bliss$synergy_prob_ss_150sim + w * pred_mw_bliss$synergy_prob_prolif_150sim) res = roc.curve(scores.class0 = pred_mw_bliss %&gt;% pull(weighted_prob), weights.class0 = pred_mw_bliss %&gt;% pull(observed)) auc_value = res$auc }) random_pr_mw = sapply(weights, function(w) { pred_mw_bliss = pred_mw_bliss %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_bliss$synergy_prob_ss_150sim + w * pred_mw_bliss$synergy_prob_random) res = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(weighted_prob), weights.class0 = pred_mw_bliss %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) prolif_pr_mw = sapply(weights, function(w) { pred_mw_bliss = pred_mw_bliss %&gt;% mutate(weighted_prob = (1 - w) * pred_mw_bliss$synergy_prob_ss_150sim + w * pred_mw_bliss$synergy_prob_prolif_150sim) res = pr.curve(scores.class0 = pred_mw_bliss %&gt;% pull(weighted_prob), weights.class0 = pred_mw_bliss %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_mw = as_tibble(cbind(weights, random_roc_mw, prolif_roc_mw, random_pr_mw, prolif_pr_mw)) df_mw = df_mw %&gt;% tidyr::pivot_longer(-weights, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_mw, x = &quot;weights&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;weight $w$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: (1-w) x prob(ss) + w x prob(prolif)&quot;, &quot;ROC: (1-w) x prob(ss) + w x prob(prolif)&quot;, &quot;PR: (1-w) x prob(ss) + w x prob(random)&quot;, &quot;ROC: (1-w) x prob(ss) + w x prob(random)&quot;)), title.position = &quot;center&quot;, title = TeX(&quot;AUC sensitivity to weighted average score (Bliss, CASCADE 2.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + grids() Figure 23: AUC sensitivity (CASCADE 2.0, Bliss synergy method, Model-wise results) No added benefit when using the model-wise approach. The random models do not augment the prediction performance of the calibrated models at all. The proliferative models can be used to normalize against the predictions of the calibrated models and thus bring significant contribution to the calibrated models performance (both ROC-AUC and PR-AUC are increased). The \\(\\beta_{best}\\) that maximizes the ROC and PR AUC for the combination of proliferative and calibrated models and is equal to \\(\\beta_{best}=-1.6\\). For \\(\\beta=-1\\) we still see significant performance improvement. Best ROC and PRC For the Bliss ensemble-wise results we demonstrated above that a value of \\(\\beta_{best}=-1.6\\) can result in significant performance gain of the combined predictor (\\(calibrated + \\beta \\times proliferative\\)). So, the best ROC and PR curves we can get with our simulations when using models with link operator mutations are (we also include the single predictor curves and the combined predictor for \\(\\beta=-1\\) which is the fold-change normalization): best_beta1 = -1.6 best_beta2 = -1 pred_ew_bliss = pred_ew_bliss %&gt;% mutate(best_score1 = ss_score_150sim + best_beta1 * prolif_score_150sim, best_score2 = ss_score_150sim + best_beta2 * prolif_score_150sim) roc_best_res1 = get_roc_stats(df = pred_ew_bliss, pred_col = &quot;best_score1&quot;, label_col = &quot;observed&quot;) roc_best_res2 = get_roc_stats(df = pred_ew_bliss, pred_col = &quot;best_score2&quot;, label_col = &quot;observed&quot;) pr_best_res1 = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(best_score1) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_best_res2 = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(best_score2) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed), curve = TRUE) # Plot best ROCs plot(x = roc_best_res1$roc_stats$FPR, y = roc_best_res1$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = (&#39;ROC curves: Combined vs Single Predictors (Bliss)&#39;), xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = roc_best_res2$roc_stats$FPR, y = roc_best_res2$roc_stats$TPR, lwd = 2, col = my_palette[2]) lines(x = res_ss_ew_150sim$roc_stats$FPR, y = res_ss_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = res_prolif_ew_150sim$roc_stats$FPR, y = res_prolif_ew_150sim$roc_stats$TPR, lwd = 2, col = my_palette[4]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, cex = 0.65, legend = c(paste(round(roc_best_res1$AUC, digits = 2), &#39;Calibrated + β * Proliferative (β = -1.6)&#39;), paste(round(roc_best_res2$AUC, digits = 2), &#39;Fold-Change Normalization&#39;), paste(round(res_ss_ew_150sim$AUC, digits = 2), &#39;Calibrated (150 sim)&#39;), paste(round(res_prolif_ew_150sim$AUC, digits = 2), &#39;Proliferative (150 sim)&#39;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) # Plot best PRCs plot(pr_best_res1, main = &#39;PR curves: Combined vs Single Predictors (Bliss)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_best_res2, add = TRUE, color = my_palette[2], lwd = 2) plot(pr_ss_ew_bliss_150sim, add = TRUE, color = my_palette[3], lwd = 1.5) plot(pr_prolif_ew_bliss_150sim, add = TRUE, color = my_palette[4], lwd = 1.5) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(pr_best_res1$auc.davis.goadrich, digits = 2), &#39;Calibrated + β * Proliferative (β = -1.6)&#39;), paste(round(pr_best_res2$auc.davis.goadrich, digits = 2), &#39;Fold-Change Normalization&#39;), paste(round(pr_ss_ew_bliss_150sim$auc.davis.goadrich, digits = 2), &#39;Calibrated (150 sim)&#39;), paste(round(pr_prolif_ew_bliss_150sim$auc.davis.goadrich, digits = 2), &#39;Proliferative (150 sim)&#39;))) grid(lwd = 0.5) Figure 24: ROC and PR curves for single and best combined predictor (CASCADE 2.0, Link Operator Mutations) The ROC ensemble-wise statistics data for the combined predictor (\\(\\beta_{best}=-1.6\\)) are as follows: DT::datatable(data = roc_best_res1$roc_stats, options = list(pageLength = 5, lengthMenu = c(5, 20, 40), searching = FALSE)) %&gt;% formatRound(c(1,6,7,8,9), digits = 3) Figure 25: ROC data for Best Combined Predictor (CASCADE 2.0, Link Operator Mutations, Bliss synergy method) Correlation We test for correlation between some of the results shown in the ROC curves. The results tested are the ensemble-wise vs model-wise, random models vs calibrated (ss) models and HSA vs Bliss synergy assessment (the calibrated and proliferative models are from the \\(150\\) simulation results). P-values are represented at 3 significant levels: \\(0.05, 0.01, 0.001\\) (*, **, ***) and the correlation coefficient is calculated using Kendall’s tau statistic. synergy_scores = bind_cols( pred_ew_hsa %&gt;% select(ss_score_150sim, prolif_score_150sim, random_score) %&gt;% rename(ss_ew_hsa = ss_score_150sim, prolif_ew_hsa = prolif_score_150sim, random_ew_hsa = random_score), pred_ew_bliss %&gt;% select(ss_score_150sim, prolif_score_150sim, random_score) %&gt;% rename(ss_ew_bliss = ss_score_150sim, prolif_ew_bliss = prolif_score_150sim, random_ew_bliss = random_score), pred_mw_hsa %&gt;% select(synergy_prob_ss_150sim, synergy_prob_prolif_150sim, synergy_prob_random) %&gt;% rename(ss_mw_hsa = synergy_prob_ss_150sim, prolif_mw_hsa = synergy_prob_prolif_150sim, random_mw_hsa = synergy_prob_random), pred_mw_bliss %&gt;% select(synergy_prob_ss_150sim, synergy_prob_prolif_150sim, synergy_prob_random) %&gt;% rename(ss_mw_bliss = synergy_prob_ss_150sim, prolif_mw_bliss = synergy_prob_prolif_150sim, random_mw_bliss = synergy_prob_random) ) M = cor(synergy_scores, method = &quot;kendall&quot;) res = cor.mtest(synergy_scores, method = &quot;kendall&quot;) corrplot(corr = M, type = &quot;upper&quot;, p.mat = res$p, sig.level = c(.001, .01, .05), pch.cex = 1, pch.col = &quot;white&quot;, insig = &quot;label_sig&quot;, tl.col = &quot;black&quot;, tl.srt = 45) Figure 26: Correlation Plot for CASCADE 2.0 Results Bliss ensemble-wise results don’t correlate at all with the model-wise results (topright part of the correlation plot). The HSA ensemble-wise results do so (at some degree). Between the ensemble-wise results there is no strong correlation (topleft) while between the model-wise (bottomright) there is strong correlation. Ensemble-wise calibrated results seem to correlate more with the proliferative than with the random results (topleft). Fitness Evolution Results are from the run with \\(200\\) Gitsbe simulations, fitting to steady state (calibrated models). fitness_summary_file = paste0(&quot;results/link-only/hsa/cascade_2.0_ss_200sim_fixpoints_hsa_summary.txt&quot;) fit_res = read_summary_file(file_name = fitness_summary_file) # rows = simulations, columns = generations # value in (sim,gen) cell = average fitness of models in that particular (sim,gen) combination avg_fit_link = do.call(dplyr::bind_rows, sapply(fit_res, colMeans)) colnames(avg_fit_link) = 1:ncol(avg_fit_link) avg_fit_long_link = avg_fit_link %&gt;% pivot_longer(cols = everything()) %&gt;% mutate(name = as.integer(name)) ggline(data = avg_fit_long_link, x = &quot;name&quot;, y = &quot;value&quot;, color = my_palette[2], add = &quot;mean_sd&quot;, add.params = list(color = &quot;black&quot;), main = &quot;Fitness Evolution across Generations&quot;, xlab = &quot;Generations&quot;, ylab = &quot;Fitness&quot;) + theme(plot.title = element_text(hjust = 0.5)) + grids() Figure 27: Fitness Evolution (150 simulations, link operator mutations, CASCADE 2.0) "],
["cascade-2-0-analysis-topology-mutations.html", "CASCADE 2.0 Analysis (Topology Mutations) HSA Results Bliss Results Best ROC and PRC", " CASCADE 2.0 Analysis (Topology Mutations) Load the results: # &#39;ss&#39; =&gt; calibrated models, &#39;rand&#39; =&gt; proliferative models (so not random but kind of!) # &#39;ew&#39; =&gt; ensemble-wise, &#39;mw&#39; =&gt; modelwise ## HSA results ss topo_ss_hsa_ew_50sim_file = paste0(&quot;results/topology-only/cascade_2.0_ss_50sim_fixpoints_hsa_ensemblewise_synergies.tab&quot;) topo_ss_hsa_mw_50sim_file = paste0(&quot;results/topology-only/cascade_2.0_ss_50sim_fixpoints_hsa_modelwise_synergies.tab&quot;) topo_ss_hsa_ew_150sim_file = paste0(&quot;results/topology-only/cascade_2.0_ss_150sim_fixpoints_hsa_ensemblewise_synergies.tab&quot;) topo_ss_hsa_mw_150sim_file = paste0(&quot;results/topology-only/cascade_2.0_ss_150sim_fixpoints_hsa_modelwise_synergies.tab&quot;) topo_ss_hsa_ew_synergies_50sim = emba::get_synergy_scores(topo_ss_hsa_ew_50sim_file) topo_ss_hsa_mw_synergies_50sim = emba::get_synergy_scores(topo_ss_hsa_mw_50sim_file, file_type = &quot;modelwise&quot;) topo_ss_hsa_ew_synergies_150sim = emba::get_synergy_scores(topo_ss_hsa_ew_150sim_file) topo_ss_hsa_mw_synergies_150sim = emba::get_synergy_scores(topo_ss_hsa_mw_150sim_file, file_type = &quot;modelwise&quot;) ## HSA results rand topo_prolif_hsa_ew_50sim_file = paste0(&quot;results/topology-only/cascade_2.0_prolif_50sim_fixpoints_hsa_ensemblewise_synergies.tab&quot;) topo_prolif_hsa_mw_50sim_file = paste0(&quot;results/topology-only/cascade_2.0_prolif_50sim_fixpoints_hsa_modelwise_synergies.tab&quot;) topo_prolif_hsa_ew_150sim_file = paste0(&quot;results/topology-only/cascade_2.0_prolif_150sim_fixpoints_hsa_ensemblewise_synergies.tab&quot;) topo_prolif_hsa_mw_150sim_file = paste0(&quot;results/topology-only/cascade_2.0_prolif_150sim_fixpoints_hsa_modelwise_synergies.tab&quot;) topo_prolif_hsa_ew_synergies_50sim = emba::get_synergy_scores(topo_prolif_hsa_ew_50sim_file) topo_prolif_hsa_mw_synergies_50sim = emba::get_synergy_scores(topo_prolif_hsa_mw_50sim_file, file_type = &quot;modelwise&quot;) topo_prolif_hsa_ew_synergies_150sim = emba::get_synergy_scores(topo_prolif_hsa_ew_150sim_file) topo_prolif_hsa_mw_synergies_150sim = emba::get_synergy_scores(topo_prolif_hsa_mw_150sim_file, file_type = &quot;modelwise&quot;) ## Bliss results ss topo_ss_bliss_ew_50sim_file = paste0(&quot;results/topology-only/cascade_2.0_ss_50sim_fixpoints_bliss_ensemblewise_synergies.tab&quot;) topo_ss_bliss_mw_50sim_file = paste0(&quot;results/topology-only/cascade_2.0_ss_50sim_fixpoints_bliss_modelwise_synergies.tab&quot;) topo_ss_bliss_ew_150sim_file = paste0(&quot;results/topology-only/cascade_2.0_ss_150sim_fixpoints_bliss_ensemblewise_synergies.tab&quot;) topo_ss_bliss_mw_150sim_file = paste0(&quot;results/topology-only/cascade_2.0_ss_150sim_fixpoints_bliss_modelwise_synergies.tab&quot;) topo_ss_bliss_ew_synergies_50sim = emba::get_synergy_scores(topo_ss_bliss_ew_50sim_file) topo_ss_bliss_mw_synergies_50sim = emba::get_synergy_scores(topo_ss_bliss_mw_50sim_file, file_type = &quot;modelwise&quot;) topo_ss_bliss_ew_synergies_150sim = emba::get_synergy_scores(topo_ss_bliss_ew_150sim_file) topo_ss_bliss_mw_synergies_150sim = emba::get_synergy_scores(topo_ss_bliss_mw_150sim_file, file_type = &quot;modelwise&quot;) ## Bliss results rand topo_prolif_bliss_ew_50sim_file = paste0(&quot;results/topology-only/cascade_2.0_prolif_50sim_fixpoints_bliss_ensemblewise_synergies.tab&quot;) topo_prolif_bliss_mw_50sim_file = paste0(&quot;results/topology-only/cascade_2.0_prolif_50sim_fixpoints_bliss_modelwise_synergies.tab&quot;) topo_prolif_bliss_ew_150sim_file = paste0(&quot;results/topology-only/cascade_2.0_prolif_150sim_fixpoints_bliss_ensemblewise_synergies.tab&quot;) topo_prolif_bliss_mw_150sim_file = paste0(&quot;results/topology-only/cascade_2.0_prolif_150sim_fixpoints_bliss_modelwise_synergies.tab&quot;) topo_prolif_bliss_ew_synergies_50sim = emba::get_synergy_scores(topo_prolif_bliss_ew_50sim_file) topo_prolif_bliss_mw_synergies_50sim = emba::get_synergy_scores(topo_prolif_bliss_mw_50sim_file, file_type = &quot;modelwise&quot;) topo_prolif_bliss_ew_synergies_150sim = emba::get_synergy_scores(topo_prolif_bliss_ew_150sim_file) topo_prolif_bliss_mw_synergies_150sim = emba::get_synergy_scores(topo_prolif_bliss_mw_150sim_file, file_type = &quot;modelwise&quot;) # calculate probability of synergy in the modelwise results topo_ss_hsa_mw_synergies_50sim = topo_ss_hsa_mw_synergies_50sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topo_ss_hsa_mw_synergies_150sim = topo_ss_hsa_mw_synergies_150sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topo_prolif_hsa_mw_synergies_50sim = topo_prolif_hsa_mw_synergies_50sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topo_prolif_hsa_mw_synergies_150sim = topo_prolif_hsa_mw_synergies_150sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topo_ss_bliss_mw_synergies_50sim = topo_ss_bliss_mw_synergies_50sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topo_ss_bliss_mw_synergies_150sim = topo_ss_bliss_mw_synergies_150sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topo_prolif_bliss_mw_synergies_50sim = topo_prolif_bliss_mw_synergies_50sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topo_prolif_bliss_mw_synergies_150sim = topo_prolif_bliss_mw_synergies_150sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) # Tidy the data pred_topo_ew_hsa = bind_cols( topo_ss_hsa_ew_synergies_50sim %&gt;% rename(ss_score_50sim = score), topo_ss_hsa_ew_synergies_150sim %&gt;% select(score) %&gt;% rename(ss_score_150sim = score), topo_prolif_hsa_ew_synergies_50sim %&gt;% select(score) %&gt;% rename(prolif_score_50sim = score), topo_prolif_hsa_ew_synergies_150sim %&gt;% select(score) %&gt;% rename(prolif_score_150sim = score), as_tibble_col(observed, column_name = &quot;observed&quot;)) pred_topo_mw_hsa = bind_cols( topo_ss_hsa_mw_synergies_50sim %&gt;% select(perturbation, synergy_prob_ss) %&gt;% rename(synergy_prob_ss_50sim = synergy_prob_ss), topo_ss_hsa_mw_synergies_150sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_ss_150sim = synergy_prob_ss), topo_prolif_hsa_mw_synergies_50sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_prolif_50sim = synergy_prob_ss), topo_prolif_hsa_mw_synergies_150sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_prolif_150sim = synergy_prob_ss), as_tibble_col(observed, column_name = &quot;observed&quot;)) pred_topo_ew_bliss = bind_cols( topo_ss_bliss_ew_synergies_50sim %&gt;% rename(ss_score_50sim = score), topo_ss_bliss_ew_synergies_150sim %&gt;% select(score) %&gt;% rename(ss_score_150sim = score), topo_prolif_bliss_ew_synergies_50sim %&gt;% select(score) %&gt;% rename(prolif_score_50sim = score), topo_prolif_bliss_ew_synergies_150sim %&gt;% select(score) %&gt;% rename(prolif_score_150sim = score), as_tibble_col(observed, column_name = &quot;observed&quot;)) pred_topo_mw_bliss = bind_cols( topo_ss_bliss_mw_synergies_50sim %&gt;% select(perturbation, synergy_prob_ss) %&gt;% rename(synergy_prob_ss_50sim = synergy_prob_ss), topo_ss_bliss_mw_synergies_150sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_ss_150sim = synergy_prob_ss), topo_prolif_bliss_mw_synergies_50sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_prolif_50sim = synergy_prob_ss), topo_prolif_bliss_mw_synergies_150sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_prolif_150sim = synergy_prob_ss), as_tibble_col(observed, column_name = &quot;observed&quot;)) HSA Results HSA refers to the synergy method used in Drabme to assess the synergies from the gitsbe models We test performance using ROC and PR AUC for both the ensemble-wise and model-wise synergies from Drabme Calibrated models: fitted to steady state (\\(50,150\\) simulations) Proliferative models: fitted to proliferation profile (\\(50,150\\) simulations) Gitsbe models have only topology mutations (\\(50\\) mutations as a bootstrap value, \\(10\\) after models with stable states are found) ROC curves topo_res_ss_ew_50sim = get_roc_stats(df = pred_topo_ew_hsa, pred_col = &quot;ss_score_50sim&quot;, label_col = &quot;observed&quot;) topo_res_ss_ew_150sim = get_roc_stats(df = pred_topo_ew_hsa, pred_col = &quot;ss_score_150sim&quot;, label_col = &quot;observed&quot;) topo_res_prolif_ew_50sim = get_roc_stats(df = pred_topo_ew_hsa, pred_col = &quot;prolif_score_50sim&quot;, label_col = &quot;observed&quot;) topo_res_prolif_ew_150sim = get_roc_stats(df = pred_topo_ew_hsa, pred_col = &quot;prolif_score_150sim&quot;, label_col = &quot;observed&quot;) topo_res_ss_mw_50sim = get_roc_stats(df = pred_topo_mw_hsa, pred_col = &quot;synergy_prob_ss_50sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topo_res_ss_mw_150sim = get_roc_stats(df = pred_topo_mw_hsa, pred_col = &quot;synergy_prob_ss_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topo_res_prolif_mw_50sim = get_roc_stats(df = pred_topo_mw_hsa, pred_col = &quot;synergy_prob_prolif_50sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topo_res_prolif_mw_150sim = get_roc_stats(df = pred_topo_mw_hsa, pred_col = &quot;synergy_prob_prolif_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) # Plot ROCs plot(x = topo_res_ss_ew_50sim$roc_stats$FPR, y = topo_res_ss_ew_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Ensemble-wise synergies (HSA)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = topo_res_ss_ew_150sim$roc_stats$FPR, y = topo_res_ss_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = topo_res_prolif_ew_50sim$roc_stats$FPR, y = topo_res_prolif_ew_50sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = topo_res_prolif_ew_150sim$roc_stats$FPR, y = topo_res_prolif_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(topo_res_ss_ew_50sim$AUC, digits = 2), &quot;Calibrated (50 sim)&quot;), paste(round(topo_res_ss_ew_150sim$AUC, digits = 2), &quot;Calibrated (150 sim)&quot;), paste(round(topo_res_prolif_ew_50sim$AUC, digits = 2), &quot;Proliferative (50 sim)&quot;), paste(round(topo_res_prolif_ew_150sim$AUC, digits = 2), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) plot(x = topo_res_ss_mw_50sim$roc_stats$FPR, y = topo_res_ss_mw_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Model-wise synergies (HSA)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = topo_res_ss_mw_150sim$roc_stats$FPR, y = topo_res_ss_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = topo_res_prolif_mw_50sim$roc_stats$FPR, y = topo_res_prolif_mw_50sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = topo_res_prolif_mw_150sim$roc_stats$FPR, y = topo_res_prolif_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(topo_res_ss_mw_50sim$AUC, digits = 2), &quot;Calibrated (50 sim)&quot;), paste(round(topo_res_ss_mw_150sim$AUC, digits = 2), &quot;Calibrated (150 sim)&quot;), paste(round(topo_res_prolif_mw_50sim$AUC, digits = 2), &quot;Proliferative (50 sim)&quot;), paste(round(topo_res_prolif_mw_150sim$AUC, digits = 2), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) Figure 28: ROC curves (CASCADE 2.0, Topology Mutations, HSA synergy method) PR curves pr_topo_res_ss_ew_50sim = pr.curve(scores.class0 = pred_topo_ew_hsa %&gt;% pull(ss_score_50sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_hsa %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_topo_res_ss_ew_150sim = pr.curve(scores.class0 = pred_topo_ew_hsa %&gt;% pull(ss_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_topo_res_prolif_ew_50sim = pr.curve(scores.class0 = pred_topo_ew_hsa %&gt;% pull(prolif_score_50sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_topo_res_prolif_ew_150sim = pr.curve(scores.class0 = pred_topo_ew_hsa %&gt;% pull(prolif_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_topo_res_ss_mw_50sim = pr.curve(scores.class0 = pred_topo_mw_hsa %&gt;% pull(synergy_prob_ss_50sim), weights.class0 = pred_topo_mw_hsa %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_topo_res_ss_mw_150sim = pr.curve(scores.class0 = pred_topo_mw_hsa %&gt;% pull(synergy_prob_ss_150sim), weights.class0 = pred_topo_mw_hsa %&gt;% pull(observed), curve = TRUE) pr_topo_res_prolif_mw_50sim = pr.curve(scores.class0 = pred_topo_mw_hsa %&gt;% pull(synergy_prob_prolif_50sim), weights.class0 = pred_topo_mw_hsa %&gt;% pull(observed), curve = TRUE) pr_topo_res_prolif_mw_150sim = pr.curve(scores.class0 = pred_topo_mw_hsa %&gt;% pull(synergy_prob_prolif_150sim), weights.class0 = pred_topo_mw_hsa %&gt;% pull(observed), curve = TRUE) plot(pr_topo_res_ss_ew_50sim, main = &#39;PR curve, Ensemble-wise synergies (HSA)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_topo_res_ss_ew_150sim, add = TRUE, color = my_palette[2]) plot(pr_topo_res_prolif_ew_50sim, add = TRUE, color = my_palette[3]) plot(pr_topo_res_prolif_ew_150sim, add = TRUE, color = my_palette[4]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(pr_topo_res_ss_ew_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_topo_res_ss_ew_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_topo_res_prolif_ew_50sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (50 sim)&quot;), paste(round(pr_topo_res_prolif_ew_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) plot(pr_topo_res_ss_mw_50sim, main = &#39;PR curve, Model-wise synergies (HSA)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_topo_res_ss_mw_150sim, add = TRUE, color = my_palette[2]) plot(pr_topo_res_prolif_mw_50sim, add = TRUE, color = my_palette[3]) plot(pr_topo_res_prolif_mw_150sim, add = TRUE, color = my_palette[4]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(pr_topo_res_ss_mw_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_topo_res_ss_mw_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_topo_res_prolif_mw_50sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (50 sim)&quot;), paste(round(pr_topo_res_prolif_mw_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) Figure 29: PR curves (CASCADE 2.0, Topology Mutations, HSA synergy method) The PR curves show that the performance of each individual predictor is poor compared to the baseline. Someone looking at the ROC curves only might reach a different conclusion. Proliferative models perform slightly better than the calibrated ones. The model-wise approach produces slightly better ROC results than the ensemble-wise approach AUC sensitivity Investigate same thing as described in here. This is very crucial since the PR performance is poor for the individual predictors, but a combined predictor might be able to counter this. We will combine the synergy scores from the proliferative simulations with the results from the calibrated Gitsbe simulations (number of simulations: \\(150\\)). # Ensemble-wise betas = seq(from = -10, to = 10, by = 0.1) prolif_roc_topo = sapply(betas, function(beta) { pred_topo_ew_hsa = pred_topo_ew_hsa %&gt;% mutate(combined_score = ss_score_150sim + beta * prolif_score_150sim) res = roc.curve(scores.class0 = pred_topo_ew_hsa %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_hsa %&gt;% pull(observed)) auc_value = res$auc }) prolif_pr_topo = sapply(betas, function(beta) { pred_topo_ew_hsa = pred_topo_ew_hsa %&gt;% mutate(combined_score = ss_score_150sim + beta * prolif_score_150sim) res = pr.curve(scores.class0 = pred_topo_ew_hsa %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_hsa %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_ew = as_tibble(cbind(betas, prolif_roc_topo, prolif_pr_topo)) df_ew = df_ew %&gt;% tidyr::pivot_longer(-betas, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_ew, x = &quot;betas&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;$\\\\beta$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: calibrated + β x proliferative&quot;, &quot;ROC: calibrated + β x proliferative&quot;)), title = TeX(&quot;AUC sensitivity to $\\\\beta$ parameter (HSA, CASCADE 2.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + geom_vline(xintercept = 0) + geom_vline(xintercept = -1, color = &quot;red&quot;, size = 0.3, linetype = &quot;dashed&quot;) + geom_text(aes(x=-1.8, label=&quot;β = -1&quot;, y=0.14), colour=&quot;black&quot;, angle=90) + grids() Figure 30: AUC sensitivity (CASCADE 2.0, Topology Mutations, HSA synergy method, Ensemble-wise results) # Model-wise weights = seq(from = 0, to = 1, by = 0.05) prolif_roc_mw = sapply(weights, function(w) { pred_topo_mw_hsa = pred_topo_mw_hsa %&gt;% mutate(weighted_prob = (1 - w) * pred_topo_mw_hsa$synergy_prob_ss_150sim + w * pred_topo_mw_hsa$synergy_prob_prolif_150sim) res = roc.curve(scores.class0 = pred_topo_mw_hsa %&gt;% pull(weighted_prob), weights.class0 = pred_topo_mw_hsa %&gt;% pull(observed)) auc_value = res$auc }) prolif_pr_mw = sapply(weights, function(w) { pred_topo_mw_hsa = pred_topo_mw_hsa %&gt;% mutate(weighted_prob = (1 - w) * pred_topo_mw_hsa$synergy_prob_ss_150sim + w * pred_topo_mw_hsa$synergy_prob_prolif_150sim) res = pr.curve(scores.class0 = pred_topo_mw_hsa %&gt;% pull(weighted_prob), weights.class0 = pred_topo_mw_hsa %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_mw = as_tibble(cbind(weights, prolif_roc_mw, prolif_pr_mw)) df_mw = df_mw %&gt;% tidyr::pivot_longer(-weights, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_mw, x = &quot;weights&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;weight $w$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: (1-w) x prob(ss) + w x prob(prolif)&quot;, &quot;ROC: (1-w) x prob(ss) + w x prob(prolif)&quot;)), title.position = &quot;center&quot;, title = TeX(&quot;AUC sensitivity to weighted average score (HSA, CASCADE 2.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + grids() Figure 31: AUC sensitivity (CASCADE 2.0, Topology Mutations, HSA synergy method, Model-wise results) No added benefit when using the model-wise approach. The proliferative models do not bring any significant change to the prediction performance of the calibrated models. Bliss Results Bliss refers to the synergy method used in Drabme to assess the synergies from the gitsbe models We test performance using ROC and PR AUC for both the ensemble-wise and model-wise synergies from Drabme Calibrated models: fitted to steady state (\\(50,150\\) simulations) Proliferative models: fitted to proliferation profile (\\(50,150\\) simulations) Gitsbe models have only topology mutations (\\(50\\) mutations as a bootstrap value, \\(10\\) after models with stable states are found) ROC curves topo_res_ss_ew_50sim = get_roc_stats(df = pred_topo_ew_bliss, pred_col = &quot;ss_score_50sim&quot;, label_col = &quot;observed&quot;) topo_res_ss_ew_150sim = get_roc_stats(df = pred_topo_ew_bliss, pred_col = &quot;ss_score_150sim&quot;, label_col = &quot;observed&quot;) topo_res_prolif_ew_50sim = get_roc_stats(df = pred_topo_ew_bliss, pred_col = &quot;prolif_score_50sim&quot;, label_col = &quot;observed&quot;) topo_res_prolif_ew_150sim = get_roc_stats(df = pred_topo_ew_bliss, pred_col = &quot;prolif_score_150sim&quot;, label_col = &quot;observed&quot;) topo_res_ss_mw_50sim = get_roc_stats(df = pred_topo_mw_bliss, pred_col = &quot;synergy_prob_ss_50sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topo_res_ss_mw_150sim = get_roc_stats(df = pred_topo_mw_bliss, pred_col = &quot;synergy_prob_ss_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topo_res_prolif_mw_50sim = get_roc_stats(df = pred_topo_mw_bliss, pred_col = &quot;synergy_prob_prolif_50sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topo_res_prolif_mw_150sim = get_roc_stats(df = pred_topo_mw_bliss, pred_col = &quot;synergy_prob_prolif_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) # Plot ROCs plot(x = topo_res_ss_ew_50sim$roc_stats$FPR, y = topo_res_ss_ew_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Ensemble-wise synergies (Bliss)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = topo_res_ss_ew_150sim$roc_stats$FPR, y = topo_res_ss_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = topo_res_prolif_ew_50sim$roc_stats$FPR, y = topo_res_prolif_ew_50sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = topo_res_prolif_ew_150sim$roc_stats$FPR, y = topo_res_prolif_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(topo_res_ss_ew_50sim$AUC, digits = 2), &quot;Calibrated (50 sim)&quot;), paste(round(topo_res_ss_ew_150sim$AUC, digits = 2), &quot;Calibrated (150 sim)&quot;), paste(round(topo_res_prolif_ew_50sim$AUC, digits = 2), &quot;Proliferative (50 sim)&quot;), paste(round(topo_res_prolif_ew_150sim$AUC, digits = 2), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) plot(x = topo_res_ss_mw_50sim$roc_stats$FPR, y = topo_res_ss_mw_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Model-wise synergies (Bliss)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = topo_res_ss_mw_150sim$roc_stats$FPR, y = topo_res_ss_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = topo_res_prolif_mw_50sim$roc_stats$FPR, y = topo_res_prolif_mw_50sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = topo_res_prolif_mw_150sim$roc_stats$FPR, y = topo_res_prolif_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(topo_res_ss_mw_50sim$AUC, digits = 2), &quot;Calibrated (50 sim)&quot;), paste(round(topo_res_ss_mw_150sim$AUC, digits = 2), &quot;Calibrated (150 sim)&quot;), paste(round(topo_res_prolif_mw_50sim$AUC, digits = 2), &quot;Proliferative (50 sim)&quot;), paste(round(topo_res_prolif_mw_150sim$AUC, digits = 2), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) Figure 32: ROC curves (CASCADE 2.0, Topology Mutations, Bliss synergy method) PR curves pr_topo_res_ss_ew_50sim = pr.curve(scores.class0 = pred_topo_ew_bliss %&gt;% pull(ss_score_50sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_bliss %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_topo_res_ss_ew_150sim = pr.curve(scores.class0 = pred_topo_ew_bliss %&gt;% pull(ss_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_topo_res_prolif_ew_50sim = pr.curve(scores.class0 = pred_topo_ew_bliss %&gt;% pull(prolif_score_50sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_topo_res_prolif_ew_150sim = pr.curve(scores.class0 = pred_topo_ew_bliss %&gt;% pull(prolif_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_topo_res_ss_mw_50sim = pr.curve(scores.class0 = pred_topo_mw_bliss %&gt;% pull(synergy_prob_ss_50sim), weights.class0 = pred_topo_mw_bliss %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_topo_res_ss_mw_150sim = pr.curve(scores.class0 = pred_topo_mw_bliss %&gt;% pull(synergy_prob_ss_150sim), weights.class0 = pred_topo_mw_bliss %&gt;% pull(observed), curve = TRUE) pr_topo_res_prolif_mw_50sim = pr.curve(scores.class0 = pred_topo_mw_bliss %&gt;% pull(synergy_prob_prolif_50sim), weights.class0 = pred_topo_mw_bliss %&gt;% pull(observed), curve = TRUE) pr_topo_res_prolif_mw_150sim = pr.curve(scores.class0 = pred_topo_mw_bliss %&gt;% pull(synergy_prob_prolif_150sim), weights.class0 = pred_topo_mw_bliss %&gt;% pull(observed), curve = TRUE) plot(pr_topo_res_ss_ew_50sim, main = &#39;PR curve, Ensemble-wise synergies (Bliss)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_topo_res_ss_ew_150sim, add = TRUE, color = my_palette[2]) plot(pr_topo_res_prolif_ew_50sim, add = TRUE, color = my_palette[3]) plot(pr_topo_res_prolif_ew_150sim, add = TRUE, color = my_palette[4]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(pr_topo_res_ss_ew_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_topo_res_ss_ew_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_topo_res_prolif_ew_50sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (50 sim)&quot;), paste(round(pr_topo_res_prolif_ew_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) plot(pr_topo_res_ss_mw_50sim, main = &#39;PR curve, Model-wise synergies (Bliss)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_topo_res_ss_mw_150sim, add = TRUE, color = my_palette[2]) plot(pr_topo_res_prolif_mw_50sim, add = TRUE, color = my_palette[3]) plot(pr_topo_res_prolif_mw_150sim, add = TRUE, color = my_palette[4]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(pr_topo_res_ss_mw_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_topo_res_ss_mw_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_topo_res_prolif_mw_50sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (50 sim)&quot;), paste(round(pr_topo_res_prolif_mw_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) Figure 33: PR curves (CASCADE 2.0, Topology Mutations, Bliss synergy method) The PR curves show that the performance of all individual predictors is poor compared to the baseline. Proliferative models perform slightly better than the calibrated ones. The model-wise approach produces slightly better ROC and PR results than the ensemble-wise approach AUC sensitivity Investigate same thing as described in here. This is very crucial since the PR performance is poor for the individual predictors, but a combined predictor might be able to counter this. We will combine the synergy scores from the proliferative simulations with the results from the calibrated Gitsbe simulations (number of simulations: \\(150\\)). # Ensemble-wise betas = seq(from = -10, to = 10, by = 0.1) prolif_roc = sapply(betas, function(beta) { pred_topo_ew_bliss = pred_topo_ew_bliss %&gt;% mutate(combined_score = ss_score_150sim + beta * prolif_score_150sim) res = roc.curve(scores.class0 = pred_topo_ew_bliss %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_bliss %&gt;% pull(observed)) auc_value = res$auc }) prolif_pr = sapply(betas, function(beta) { pred_topo_ew_bliss = pred_topo_ew_bliss %&gt;% mutate(combined_score = ss_score_150sim + beta * prolif_score_150sim) res = pr.curve(scores.class0 = pred_topo_ew_bliss %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_bliss %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_ew = as_tibble(cbind(betas, prolif_roc, prolif_pr)) df_ew = df_ew %&gt;% tidyr::pivot_longer(-betas, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_ew, x = &quot;betas&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;$\\\\beta$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: calibrated + β x proliferative&quot;, &quot;ROC: calibrated + β x proliferative&quot;)), title = TeX(&quot;AUC sensitivity to $\\\\beta$ parameter (Bliss, CASCADE 2.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + geom_vline(xintercept = 0) + geom_vline(xintercept = -1, color = &quot;red&quot;, size = 0.3, linetype = &quot;dashed&quot;) + geom_text(aes(x=-2, label=&quot;β = -1&quot;, y=0.15), colour=&quot;black&quot;, angle = 90) + grids() Figure 34: AUC sensitivity (CASCADE 2.0, Topology Mutations, Bliss synergy method, Ensemble-wise results) # Model-wise weights = seq(from = 0, to = 1, by = 0.05) prolif_roc_mw = sapply(weights, function(w) { pred_topo_mw_bliss = pred_topo_mw_bliss %&gt;% mutate(weighted_prob = (1 - w) * pred_topo_mw_bliss$synergy_prob_ss_150sim + w * pred_topo_mw_bliss$synergy_prob_prolif_150sim) res = roc.curve(scores.class0 = pred_topo_mw_bliss %&gt;% pull(weighted_prob), weights.class0 = pred_topo_mw_bliss %&gt;% pull(observed)) auc_value = res$auc }) prolif_pr_mw = sapply(weights, function(w) { pred_topo_mw_bliss = pred_topo_mw_bliss %&gt;% mutate(weighted_prob = (1 - w) * pred_topo_mw_bliss$synergy_prob_ss_150sim + w * pred_topo_mw_bliss$synergy_prob_prolif_150sim) res = pr.curve(scores.class0 = pred_topo_mw_bliss %&gt;% pull(weighted_prob), weights.class0 = pred_topo_mw_bliss %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_mw = as_tibble(cbind(weights, prolif_roc_mw, prolif_pr_mw)) df_mw = df_mw %&gt;% tidyr::pivot_longer(-weights, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_mw, x = &quot;weights&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;weight $w$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: (1-w) x prob(ss) + w x prob(prolif)&quot;, &quot;ROC: (1-w) x prob(ss) + w x prob(prolif)&quot;)), title.position = &quot;center&quot;, title = TeX(&quot;AUC sensitivity to weighted average score (Bliss, CASCADE 2.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + grids() Figure 35: AUC sensitivity (CASCADE 2.0, Topology Mutations, Bliss synergy method, Model-wise results) No added benefit when using the model-wise approach. The proliferative models can be used to normalize against the predictions of the calibrated models and thus bring significant contribution to the calibrated models performance (both ROC-AUC and PR-AUC are increased). The \\(\\beta_{best}\\) values of the combined calibrated and proliferative model predictor that maximize the ROC-AUC and PR-AUC respectively are \\(\\beta_{best}^{\\text{ROC-AUC}}=-0.8\\) and \\(\\beta_{best}^{\\text{PR-AUC}}=-1\\). Best ROC and PRC For the Bliss ensemble-wise results we demonstrated above that a value of \\(\\beta_{best}=-1\\) can result in significant performance gain of the combined predictor (\\(calibrated + \\beta \\times proliferative\\)). So, the best ROC and PR curves we can get with our simulations when using models with topology mutations are: best_beta = -1 pred_topo_ew_bliss = pred_topo_ew_bliss %&gt;% mutate(best_score = ss_score_150sim + best_beta * prolif_score_150sim) roc_best_res = get_roc_stats(df = pred_topo_ew_bliss, pred_col = &quot;best_score&quot;, label_col = &quot;observed&quot;) pr_best_res = pr.curve(scores.class0 = pred_topo_ew_bliss %&gt;% pull(best_score) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_bliss %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) # Plot best ROC plot(x = roc_best_res$roc_stats$FPR, y = roc_best_res$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = TeX(&#39;ROC curve (Ensemble-wise), $calibrated + \\\\beta \\\\times proliferative$&#39;), xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) legend(&#39;bottomright&#39;, title = TeX(&#39;AUC ($\\\\beta$ = -1)&#39;), col = my_palette[1], pch = 19, legend = paste(round(roc_best_res$AUC, digits = 2), &#39;Bliss (150 sim)&#39;)) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) # Plot best PRC plot(pr_best_res, main = TeX(&#39;PR curve (Ensemble-wise), $calibrated + \\\\beta \\\\times proliferative$&#39;), auc.main = FALSE, color = my_palette[2], rand.plot = TRUE) legend(&#39;topright&#39;, title = TeX(&#39;AUC ($\\\\beta$ = -1)&#39;), col = my_palette[2], pch = 19, legend = paste(round(pr_best_res$auc.davis.goadrich, digits = 3), &#39;Bliss (150 sim)&#39;)) grid(lwd = 0.5) Figure 36: ROC and PR curve for best beta (CASCADE 2.0, Topology Mutations) "],
["cascade-2-0-analysis-topology-and-link-operator-mutations.html", "CASCADE 2.0 Analysis (Topology and Link Operator Mutations) HSA Results Bliss Results Best ROC and PRC", " CASCADE 2.0 Analysis (Topology and Link Operator Mutations) # &#39;ss&#39; =&gt; calibrated models, &#39;rand&#39; =&gt; proliferative models (so not random but kind of!) # &#39;ew&#39; =&gt; ensemble-wise, &#39;mw&#39; =&gt; modelwise ## HSA results ss topolink_ss_hsa_ew_50sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_ss_50sim_fixpoints_hsa_ensemblewise_synergies.tab&quot;) topolink_ss_hsa_mw_50sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_ss_50sim_fixpoints_hsa_modelwise_synergies.tab&quot;) topolink_ss_hsa_ew_150sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_ss_150sim_fixpoints_hsa_ensemblewise_synergies.tab&quot;) topolink_ss_hsa_mw_150sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_ss_150sim_fixpoints_hsa_modelwise_synergies.tab&quot;) topolink_ss_hsa_ew_synergies_50sim = emba::get_synergy_scores(topolink_ss_hsa_ew_50sim_file) topolink_ss_hsa_mw_synergies_50sim = emba::get_synergy_scores(topolink_ss_hsa_mw_50sim_file, file_type = &quot;modelwise&quot;) topolink_ss_hsa_ew_synergies_150sim = emba::get_synergy_scores(topolink_ss_hsa_ew_150sim_file) topolink_ss_hsa_mw_synergies_150sim = emba::get_synergy_scores(topolink_ss_hsa_mw_150sim_file, file_type = &quot;modelwise&quot;) ## HSA results rand topolink_prolif_hsa_ew_50sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_prolif_50sim_fixpoints_hsa_ensemblewise_synergies.tab&quot;) topolink_prolif_hsa_mw_50sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_prolif_50sim_fixpoints_hsa_modelwise_synergies.tab&quot;) topolink_prolif_hsa_ew_150sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_prolif_150sim_fixpoints_hsa_ensemblewise_synergies.tab&quot;) topolink_prolif_hsa_mw_150sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_prolif_150sim_fixpoints_hsa_modelwise_synergies.tab&quot;) topolink_prolif_hsa_ew_synergies_50sim = emba::get_synergy_scores(topolink_prolif_hsa_ew_50sim_file) topolink_prolif_hsa_mw_synergies_50sim = emba::get_synergy_scores(topolink_prolif_hsa_mw_50sim_file, file_type = &quot;modelwise&quot;) topolink_prolif_hsa_ew_synergies_150sim = emba::get_synergy_scores(topolink_prolif_hsa_ew_150sim_file) topolink_prolif_hsa_mw_synergies_150sim = emba::get_synergy_scores(topolink_prolif_hsa_mw_150sim_file, file_type = &quot;modelwise&quot;) ## Bliss results ss topolink_ss_bliss_ew_50sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_ss_50sim_fixpoints_bliss_ensemblewise_synergies.tab&quot;) topolink_ss_bliss_mw_50sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_ss_50sim_fixpoints_bliss_modelwise_synergies.tab&quot;) topolink_ss_bliss_ew_150sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_ss_150sim_fixpoints_bliss_ensemblewise_synergies.tab&quot;) topolink_ss_bliss_mw_150sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_ss_150sim_fixpoints_bliss_modelwise_synergies.tab&quot;) topolink_ss_bliss_ew_synergies_50sim = emba::get_synergy_scores(topolink_ss_bliss_ew_50sim_file) topolink_ss_bliss_mw_synergies_50sim = emba::get_synergy_scores(topolink_ss_bliss_mw_50sim_file, file_type = &quot;modelwise&quot;) topolink_ss_bliss_ew_synergies_150sim = emba::get_synergy_scores(topolink_ss_bliss_ew_150sim_file) topolink_ss_bliss_mw_synergies_150sim = emba::get_synergy_scores(topolink_ss_bliss_mw_150sim_file, file_type = &quot;modelwise&quot;) ## Bliss results rand topolink_prolif_bliss_ew_50sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_prolif_50sim_fixpoints_bliss_ensemblewise_synergies.tab&quot;) topolink_prolif_bliss_mw_50sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_prolif_50sim_fixpoints_bliss_modelwise_synergies.tab&quot;) topolink_prolif_bliss_ew_150sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_prolif_150sim_fixpoints_bliss_ensemblewise_synergies.tab&quot;) topolink_prolif_bliss_mw_150sim_file = paste0(&quot;results/topo-and-link/cascade_2.0_prolif_150sim_fixpoints_bliss_modelwise_synergies.tab&quot;) topolink_prolif_bliss_ew_synergies_50sim = emba::get_synergy_scores(topolink_prolif_bliss_ew_50sim_file) topolink_prolif_bliss_mw_synergies_50sim = emba::get_synergy_scores(topolink_prolif_bliss_mw_50sim_file, file_type = &quot;modelwise&quot;) topolink_prolif_bliss_ew_synergies_150sim = emba::get_synergy_scores(topolink_prolif_bliss_ew_150sim_file) topolink_prolif_bliss_mw_synergies_150sim = emba::get_synergy_scores(topolink_prolif_bliss_mw_150sim_file, file_type = &quot;modelwise&quot;) # calculate probability of synergy in the modelwise results topolink_ss_hsa_mw_synergies_50sim = topolink_ss_hsa_mw_synergies_50sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topolink_ss_hsa_mw_synergies_150sim = topolink_ss_hsa_mw_synergies_150sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topolink_prolif_hsa_mw_synergies_50sim = topolink_prolif_hsa_mw_synergies_50sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topolink_prolif_hsa_mw_synergies_150sim = topolink_prolif_hsa_mw_synergies_150sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topolink_ss_bliss_mw_synergies_50sim = topolink_ss_bliss_mw_synergies_50sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topolink_ss_bliss_mw_synergies_150sim = topolink_ss_bliss_mw_synergies_150sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topolink_prolif_bliss_mw_synergies_50sim = topolink_prolif_bliss_mw_synergies_50sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) topolink_prolif_bliss_mw_synergies_150sim = topolink_prolif_bliss_mw_synergies_150sim %&gt;% mutate(synergy_prob_ss = synergies/(synergies + `non-synergies`)) # Tidy the data pred_topolink_ew_hsa = bind_cols( topolink_ss_hsa_ew_synergies_50sim %&gt;% rename(ss_score_50sim = score), topolink_ss_hsa_ew_synergies_150sim %&gt;% select(score) %&gt;% rename(ss_score_150sim = score), topolink_prolif_hsa_ew_synergies_50sim %&gt;% select(score) %&gt;% rename(prolif_score_50sim = score), topolink_prolif_hsa_ew_synergies_150sim %&gt;% select(score) %&gt;% rename(prolif_score_150sim = score), as_tibble_col(observed, column_name = &quot;observed&quot;)) pred_topolink_mw_hsa = bind_cols( topolink_ss_hsa_mw_synergies_50sim %&gt;% select(perturbation, synergy_prob_ss) %&gt;% rename(synergy_prob_ss_50sim = synergy_prob_ss), topolink_ss_hsa_mw_synergies_150sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_ss_150sim = synergy_prob_ss), topolink_prolif_hsa_mw_synergies_50sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_prolif_50sim = synergy_prob_ss), topolink_prolif_hsa_mw_synergies_150sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_prolif_150sim = synergy_prob_ss), as_tibble_col(observed, column_name = &quot;observed&quot;)) pred_topolink_ew_bliss = bind_cols( topolink_ss_bliss_ew_synergies_50sim %&gt;% rename(ss_score_50sim = score), topolink_ss_bliss_ew_synergies_150sim %&gt;% select(score) %&gt;% rename(ss_score_150sim = score), topolink_prolif_bliss_ew_synergies_50sim %&gt;% select(score) %&gt;% rename(prolif_score_50sim = score), topolink_prolif_bliss_ew_synergies_150sim %&gt;% select(score) %&gt;% rename(prolif_score_150sim = score), as_tibble_col(observed, column_name = &quot;observed&quot;)) pred_topolink_mw_bliss = bind_cols( topolink_ss_bliss_mw_synergies_50sim %&gt;% select(perturbation, synergy_prob_ss) %&gt;% rename(synergy_prob_ss_50sim = synergy_prob_ss), topolink_ss_bliss_mw_synergies_150sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_ss_150sim = synergy_prob_ss), topolink_prolif_bliss_mw_synergies_50sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_prolif_50sim = synergy_prob_ss), topolink_prolif_bliss_mw_synergies_150sim %&gt;% select(synergy_prob_ss) %&gt;% rename(synergy_prob_prolif_150sim = synergy_prob_ss), as_tibble_col(observed, column_name = &quot;observed&quot;)) HSA Results HSA refers to the synergy method used in Drabme to assess the synergies from the gitsbe models We test performance using ROC and PR AUC for both the ensemble-wise and model-wise synergies from Drabme Calibrated models: fitted to steady state (\\(50,150\\) simulations) Proliferative models: fitted to proliferation profile (\\(50,150\\) simulations) Gitsbe models have both balance and topology mutations (\\(3000,50\\) mutations as a bootstrap value, \\(3\\) and \\(10\\) respectively after models with stable states are found) ROC curves topolink_res_ss_ew_50sim = get_roc_stats(df = pred_topolink_ew_hsa, pred_col = &quot;ss_score_50sim&quot;, label_col = &quot;observed&quot;) topolink_res_ss_ew_150sim = get_roc_stats(df = pred_topolink_ew_hsa, pred_col = &quot;ss_score_150sim&quot;, label_col = &quot;observed&quot;) topolink_res_prolif_ew_50sim = get_roc_stats(df = pred_topolink_ew_hsa, pred_col = &quot;prolif_score_50sim&quot;, label_col = &quot;observed&quot;) topolink_res_prolif_ew_150sim = get_roc_stats(df = pred_topolink_ew_hsa, pred_col = &quot;prolif_score_150sim&quot;, label_col = &quot;observed&quot;) topolink_res_ss_mw_50sim = get_roc_stats(df = pred_topolink_mw_hsa, pred_col = &quot;synergy_prob_ss_50sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topolink_res_ss_mw_150sim = get_roc_stats(df = pred_topolink_mw_hsa, pred_col = &quot;synergy_prob_ss_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topolink_res_prolif_mw_50sim = get_roc_stats(df = pred_topolink_mw_hsa, pred_col = &quot;synergy_prob_prolif_50sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topolink_res_prolif_mw_150sim = get_roc_stats(df = pred_topolink_mw_hsa, pred_col = &quot;synergy_prob_prolif_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) # Plot ROCs plot(x = topolink_res_ss_ew_50sim$roc_stats$FPR, y = topolink_res_ss_ew_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Ensemble-wise synergies (HSA)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = topolink_res_ss_ew_150sim$roc_stats$FPR, y = topolink_res_ss_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = topolink_res_prolif_ew_50sim$roc_stats$FPR, y = topolink_res_prolif_ew_50sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = topolink_res_prolif_ew_150sim$roc_stats$FPR, y = topolink_res_prolif_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(topolink_res_ss_ew_50sim$AUC, digits = 2), &quot;Calibrated (50 sim)&quot;), paste(round(topolink_res_ss_ew_150sim$AUC, digits = 2), &quot;Calibrated (150 sim)&quot;), paste(round(topolink_res_prolif_ew_50sim$AUC, digits = 2), &quot;Proliferative (50 sim)&quot;), paste(round(topolink_res_prolif_ew_150sim$AUC, digits = 2), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) plot(x = topolink_res_ss_mw_50sim$roc_stats$FPR, y = topolink_res_ss_mw_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Model-wise synergies (HSA)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = topolink_res_ss_mw_150sim$roc_stats$FPR, y = topolink_res_ss_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = topolink_res_prolif_mw_50sim$roc_stats$FPR, y = topolink_res_prolif_mw_50sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = topolink_res_prolif_mw_150sim$roc_stats$FPR, y = topolink_res_prolif_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(topolink_res_ss_mw_50sim$AUC, digits = 2), &quot;Calibrated (50 sim)&quot;), paste(round(topolink_res_ss_mw_150sim$AUC, digits = 2), &quot;Calibrated (150 sim)&quot;), paste(round(topolink_res_prolif_mw_50sim$AUC, digits = 2), &quot;Proliferative (50 sim)&quot;), paste(round(topolink_res_prolif_mw_150sim$AUC, digits = 2), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) Figure 37: ROC curves (CASCADE 2.0, Link Operator and Topology Mutations, HSA synergy method) PR curves pr_topolink_res_ss_ew_50sim = pr.curve(scores.class0 = pred_topolink_ew_hsa %&gt;% pull(ss_score_50sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_hsa %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_topolink_res_ss_ew_150sim = pr.curve(scores.class0 = pred_topolink_ew_hsa %&gt;% pull(ss_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_topolink_res_prolif_ew_50sim = pr.curve(scores.class0 = pred_topolink_ew_hsa %&gt;% pull(prolif_score_50sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_topolink_res_prolif_ew_150sim = pr.curve(scores.class0 = pred_topolink_ew_hsa %&gt;% pull(prolif_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_hsa %&gt;% pull(observed), curve = TRUE) pr_topolink_res_ss_mw_50sim = pr.curve(scores.class0 = pred_topolink_mw_hsa %&gt;% pull(synergy_prob_ss_50sim), weights.class0 = pred_topolink_mw_hsa %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_topolink_res_ss_mw_150sim = pr.curve(scores.class0 = pred_topolink_mw_hsa %&gt;% pull(synergy_prob_ss_150sim), weights.class0 = pred_topolink_mw_hsa %&gt;% pull(observed), curve = TRUE) pr_topolink_res_prolif_mw_50sim = pr.curve(scores.class0 = pred_topolink_mw_hsa %&gt;% pull(synergy_prob_prolif_50sim), weights.class0 = pred_topolink_mw_hsa %&gt;% pull(observed), curve = TRUE) pr_topolink_res_prolif_mw_150sim = pr.curve(scores.class0 = pred_topolink_mw_hsa %&gt;% pull(synergy_prob_prolif_150sim), weights.class0 = pred_topolink_mw_hsa %&gt;% pull(observed), curve = TRUE) plot(pr_topolink_res_ss_ew_50sim, main = &#39;PR curve, Ensemble-wise synergies (HSA)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_topolink_res_ss_ew_150sim, add = TRUE, color = my_palette[2]) plot(pr_topolink_res_prolif_ew_50sim, add = TRUE, color = my_palette[3]) plot(pr_topolink_res_prolif_ew_150sim, add = TRUE, color = my_palette[4]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(pr_topolink_res_ss_ew_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_topolink_res_ss_ew_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_topolink_res_prolif_ew_50sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (50 sim)&quot;), paste(round(pr_topolink_res_prolif_ew_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) plot(pr_topolink_res_ss_mw_50sim, main = &#39;PR curve, Model-wise synergies (HSA)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_topolink_res_ss_mw_150sim, add = TRUE, color = my_palette[2]) plot(pr_topolink_res_prolif_mw_50sim, add = TRUE, color = my_palette[3]) plot(pr_topolink_res_prolif_mw_150sim, add = TRUE, color = my_palette[4]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(pr_topolink_res_ss_mw_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_topolink_res_ss_mw_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_topolink_res_prolif_mw_50sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (50 sim)&quot;), paste(round(pr_topolink_res_prolif_mw_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) Figure 38: PR curves (CASCADE 2.0, Link Operator and Topology Mutations, HSA synergy method) The PR curves show that the performance of each individual predictor is poor compared to the baseline. Someone looking at the ROC curves only might reach a different conclusion. The model-wise approach produces slightly better ROC results than the ensemble-wise approach AUC sensitivity Investigate same thing as described in here. This is very crucial since the PR performance is poor for the individual predictors, but a combined predictor might be able to counter this. We will combine the synergy scores from the proliferative simulations with the results from the calibrated Gitsbe simulations (number of simulations: \\(150\\)). # Ensemble-wise betas = seq(from = -10, to = 10, by = 0.1) prolif_roc_topo = sapply(betas, function(beta) { pred_topolink_ew_hsa = pred_topolink_ew_hsa %&gt;% mutate(combined_score = ss_score_150sim + beta * prolif_score_150sim) res = roc.curve(scores.class0 = pred_topolink_ew_hsa %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_hsa %&gt;% pull(observed)) auc_value = res$auc }) prolif_pr_topo = sapply(betas, function(beta) { pred_topolink_ew_hsa = pred_topolink_ew_hsa %&gt;% mutate(combined_score = ss_score_150sim + beta * prolif_score_150sim) res = pr.curve(scores.class0 = pred_topolink_ew_hsa %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_hsa %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_ew = as_tibble(cbind(betas, prolif_roc_topo, prolif_pr_topo)) df_ew = df_ew %&gt;% tidyr::pivot_longer(-betas, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_ew, x = &quot;betas&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;$\\\\beta$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: calibrated + β x proliferative&quot;, &quot;ROC: calibrated + β x proliferative&quot;)), title = TeX(&quot;AUC sensitivity to $\\\\beta$ parameter (HSA, CASCADE 2.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + geom_vline(xintercept = 0) + geom_vline(xintercept = -1, color = &quot;red&quot;, size = 0.3, linetype = &quot;dashed&quot;) + geom_text(aes(x=-1.8, label=&quot;β = -1&quot;, y=0.3), colour=&quot;black&quot;, angle=90) + grids() Figure 39: AUC sensitivity (CASCADE 2.0, Link Operator and Topology Mutations, HSA synergy method, Ensemble-wise results) # Model-wise weights = seq(from = 0, to = 1, by = 0.05) prolif_roc_mw = sapply(weights, function(w) { pred_topolink_mw_hsa = pred_topolink_mw_hsa %&gt;% mutate(weighted_prob = (1 - w) * pred_topolink_mw_hsa$synergy_prob_ss_150sim + w * pred_topolink_mw_hsa$synergy_prob_prolif_150sim) res = roc.curve(scores.class0 = pred_topolink_mw_hsa %&gt;% pull(weighted_prob), weights.class0 = pred_topolink_mw_hsa %&gt;% pull(observed)) auc_value = res$auc }) prolif_pr_mw = sapply(weights, function(w) { pred_topolink_mw_hsa = pred_topolink_mw_hsa %&gt;% mutate(weighted_prob = (1 - w) * pred_topolink_mw_hsa$synergy_prob_ss_150sim + w * pred_topolink_mw_hsa$synergy_prob_prolif_150sim) res = pr.curve(scores.class0 = pred_topolink_mw_hsa %&gt;% pull(weighted_prob), weights.class0 = pred_topolink_mw_hsa %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_mw = as_tibble(cbind(weights, prolif_roc_mw, prolif_pr_mw)) df_mw = df_mw %&gt;% tidyr::pivot_longer(-weights, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_mw, x = &quot;weights&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;weight $w$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: (1-w) x prob(ss) + w x prob(prolif)&quot;, &quot;ROC: (1-w) x prob(ss) + w x prob(prolif)&quot;)), title.position = &quot;center&quot;, title = TeX(&quot;AUC sensitivity to weighted average score (HSA, CASCADE 2.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + grids() Figure 40: AUC sensitivity (CASCADE 2.0, Link Operator and Topology Mutations, HSA synergy method, Model-wise results) No added benefit when using the model-wise approach. The proliferative models can be used to normalize against the predictions of the calibrated models and thus bring significant contribution to the calibrated models performance (PR-AUC shows much more sensitivity in that regard - it increases substantially more than the ROC-AUC). The \\(\\beta_{best}\\) value of the combined calibrated and proliferative model predictor that maximizes both the ROC-AUC and PR-AUC is \\(\\beta_{best}=-1\\). Bliss Results Bliss refers to the synergy method used in Drabme to assess the synergies from the gitsbe models We test performance using ROC and PR AUC for both the ensemble-wise and model-wise synergies from Drabme Calibrated models: fitted to steady state (\\(50,150\\) simulations) Proliferative models: fitted to proliferation profile (\\(50,150\\) simulations) Gitsbe models have both balance and topology mutations (\\(3000,50\\) mutations as a bootstrap value, \\(3\\) and \\(10\\) respectively after models with stable states are found) ROC curves topolink_res_ss_ew_50sim = get_roc_stats(df = pred_topolink_ew_bliss, pred_col = &quot;ss_score_50sim&quot;, label_col = &quot;observed&quot;) topolink_res_ss_ew_150sim = get_roc_stats(df = pred_topolink_ew_bliss, pred_col = &quot;ss_score_150sim&quot;, label_col = &quot;observed&quot;) topolink_res_prolif_ew_50sim = get_roc_stats(df = pred_topolink_ew_bliss, pred_col = &quot;prolif_score_50sim&quot;, label_col = &quot;observed&quot;) topolink_res_prolif_ew_150sim = get_roc_stats(df = pred_topolink_ew_bliss, pred_col = &quot;prolif_score_150sim&quot;, label_col = &quot;observed&quot;) topolink_res_ss_mw_50sim = get_roc_stats(df = pred_topolink_mw_bliss, pred_col = &quot;synergy_prob_ss_50sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topolink_res_ss_mw_150sim = get_roc_stats(df = pred_topolink_mw_bliss, pred_col = &quot;synergy_prob_ss_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topolink_res_prolif_mw_50sim = get_roc_stats(df = pred_topolink_mw_bliss, pred_col = &quot;synergy_prob_prolif_50sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) topolink_res_prolif_mw_150sim = get_roc_stats(df = pred_topolink_mw_bliss, pred_col = &quot;synergy_prob_prolif_150sim&quot;, label_col = &quot;observed&quot;, direction = &quot;&gt;&quot;) # Plot ROCs plot(x = topolink_res_ss_ew_50sim$roc_stats$FPR, y = topolink_res_ss_ew_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Ensemble-wise synergies (Bliss)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = topolink_res_ss_ew_150sim$roc_stats$FPR, y = topolink_res_ss_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = topolink_res_prolif_ew_50sim$roc_stats$FPR, y = topolink_res_prolif_ew_50sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = topolink_res_prolif_ew_150sim$roc_stats$FPR, y = topolink_res_prolif_ew_150sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(topolink_res_ss_ew_50sim$AUC, digits = 2), &quot;Calibrated (50 sim)&quot;), paste(round(topolink_res_ss_ew_150sim$AUC, digits = 2), &quot;Calibrated (150 sim)&quot;), paste(round(topolink_res_prolif_ew_50sim$AUC, digits = 2), &quot;Proliferative (50 sim)&quot;), paste(round(topolink_res_prolif_ew_150sim$AUC, digits = 2), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) plot(x = topolink_res_ss_mw_50sim$roc_stats$FPR, y = topolink_res_ss_mw_50sim$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = &#39;ROC curve, Model-wise synergies (Bliss)&#39;, xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = topolink_res_ss_mw_150sim$roc_stats$FPR, y = topolink_res_ss_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[2]) lines(x = topolink_res_prolif_mw_50sim$roc_stats$FPR, y = topolink_res_prolif_mw_50sim$roc_stats$TPR, lwd = 3, col = my_palette[3]) lines(x = topolink_res_prolif_mw_150sim$roc_stats$FPR, y = topolink_res_prolif_mw_150sim$roc_stats$TPR, lwd = 3, col = my_palette[4]) legend(&#39;bottomright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(topolink_res_ss_mw_50sim$AUC, digits = 2), &quot;Calibrated (50 sim)&quot;), paste(round(topolink_res_ss_mw_150sim$AUC, digits = 2), &quot;Calibrated (150 sim)&quot;), paste(round(topolink_res_prolif_mw_50sim$AUC, digits = 2), &quot;Proliferative (50 sim)&quot;), paste(round(topolink_res_prolif_mw_150sim$AUC, digits = 2), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) Figure 41: ROC curves (CASCADE 2.0, Link Operator and Topology Mutations, Bliss synergy method) PR curves pr_topolink_res_ss_ew_50sim = pr.curve(scores.class0 = pred_topolink_ew_bliss %&gt;% pull(ss_score_50sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_bliss %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_topolink_res_ss_ew_150sim = pr.curve(scores.class0 = pred_topolink_ew_bliss %&gt;% pull(ss_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_topolink_res_prolif_ew_50sim = pr.curve(scores.class0 = pred_topolink_ew_bliss %&gt;% pull(prolif_score_50sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_topolink_res_prolif_ew_150sim = pr.curve(scores.class0 = pred_topolink_ew_bliss %&gt;% pull(prolif_score_150sim) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_bliss %&gt;% pull(observed), curve = TRUE) pr_topolink_res_ss_mw_50sim = pr.curve(scores.class0 = pred_topolink_mw_bliss %&gt;% pull(synergy_prob_ss_50sim), weights.class0 = pred_topolink_mw_bliss %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_topolink_res_ss_mw_150sim = pr.curve(scores.class0 = pred_topolink_mw_bliss %&gt;% pull(synergy_prob_ss_150sim), weights.class0 = pred_topolink_mw_bliss %&gt;% pull(observed), curve = TRUE) pr_topolink_res_prolif_mw_50sim = pr.curve(scores.class0 = pred_topolink_mw_bliss %&gt;% pull(synergy_prob_prolif_50sim), weights.class0 = pred_topolink_mw_bliss %&gt;% pull(observed), curve = TRUE) pr_topolink_res_prolif_mw_150sim = pr.curve(scores.class0 = pred_topolink_mw_bliss %&gt;% pull(synergy_prob_prolif_150sim), weights.class0 = pred_topolink_mw_bliss %&gt;% pull(observed), curve = TRUE) plot(pr_topolink_res_ss_ew_50sim, main = &#39;PR curve, Ensemble-wise synergies (Bliss)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_topolink_res_ss_ew_150sim, add = TRUE, color = my_palette[2]) plot(pr_topolink_res_prolif_ew_50sim, add = TRUE, color = my_palette[3]) plot(pr_topolink_res_prolif_ew_150sim, add = TRUE, color = my_palette[4]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(pr_topolink_res_ss_ew_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_topolink_res_ss_ew_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_topolink_res_prolif_ew_50sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (50 sim)&quot;), paste(round(pr_topolink_res_prolif_ew_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) plot(pr_topolink_res_ss_mw_50sim, main = &#39;PR curve, Model-wise synergies (Bliss)&#39;, auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_topolink_res_ss_mw_150sim, add = TRUE, color = my_palette[2]) plot(pr_topolink_res_prolif_mw_50sim, add = TRUE, color = my_palette[3]) plot(pr_topolink_res_prolif_mw_150sim, add = TRUE, color = my_palette[4]) legend(&#39;topright&#39;, title = &#39;AUC&#39;, col = my_palette[1:4], pch = 19, legend = c(paste(round(pr_topolink_res_ss_mw_50sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (50 sim)&quot;), paste(round(pr_topolink_res_ss_mw_150sim$auc.davis.goadrich, digits = 3), &quot;Calibrated (150 sim)&quot;), paste(round(pr_topolink_res_prolif_mw_50sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (50 sim)&quot;), paste(round(pr_topolink_res_prolif_mw_150sim$auc.davis.goadrich, digits = 3), &quot;Proliferative (150 sim)&quot;))) grid(lwd = 0.5) Figure 42: PR curves (CASCADE 2.0, Link Operator and Topology Mutations, Bliss synergy method) The PR curves show that the performance of each individual predictor is poor compared to the baseline. The model-wise approach produces better ROC and PR results than the ensemble-wise approach (performance in terms of AUC value is almost doubled) AUC sensitivity Investigate same thing as described in here. This is very crucial since the PR performance is poor for the individual predictors, but a combined predictor might be able to counter this. We will combine the synergy scores from the proliferative simulations with the results from the calibrated Gitsbe simulations (number of simulations: \\(150\\)). # Ensemble-wise betas = seq(from = -10, to = 10, by = 0.1) prolif_roc = sapply(betas, function(beta) { pred_topolink_ew_bliss = pred_topolink_ew_bliss %&gt;% mutate(combined_score = ss_score_150sim + beta * prolif_score_150sim) res = roc.curve(scores.class0 = pred_topolink_ew_bliss %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_bliss %&gt;% pull(observed)) auc_value = res$auc }) prolif_pr = sapply(betas, function(beta) { pred_topolink_ew_bliss = pred_topolink_ew_bliss %&gt;% mutate(combined_score = ss_score_150sim + beta * prolif_score_150sim) res = pr.curve(scores.class0 = pred_topolink_ew_bliss %&gt;% pull(combined_score) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_bliss %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_ew = as_tibble(cbind(betas, prolif_roc, prolif_pr)) df_ew = df_ew %&gt;% tidyr::pivot_longer(-betas, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_ew, x = &quot;betas&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;$\\\\beta$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: calibrated + β x proliferative&quot;, &quot;ROC: calibrated + β x proliferative&quot;)), title = TeX(&quot;AUC sensitivity to $\\\\beta$ parameter (Bliss, CASCADE 2.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + geom_vline(xintercept = 0) + geom_vline(xintercept = -1, color = &quot;red&quot;, size = 0.3, linetype = &quot;dashed&quot;) + geom_text(aes(x=-2, label=&quot;β = -1&quot;, y=0.15), colour=&quot;black&quot;, angle = 90) + grids() Figure 43: AUC sensitivity (CASCADE 2.0, Link Operator and Topology Mutations, Bliss synergy method, Ensemble-wise results) # Model-wise weights = seq(from = 0, to = 1, by = 0.05) prolif_roc_mw = sapply(weights, function(w) { pred_topolink_mw_bliss = pred_topolink_mw_bliss %&gt;% mutate(weighted_prob = (1 - w) * pred_topolink_mw_bliss$synergy_prob_ss_150sim + w * pred_topolink_mw_bliss$synergy_prob_prolif_150sim) res = roc.curve(scores.class0 = pred_topolink_mw_bliss %&gt;% pull(weighted_prob), weights.class0 = pred_topolink_mw_bliss %&gt;% pull(observed)) auc_value = res$auc }) prolif_pr_mw = sapply(weights, function(w) { pred_topolink_mw_bliss = pred_topolink_mw_bliss %&gt;% mutate(weighted_prob = (1 - w) * pred_topolink_mw_bliss$synergy_prob_ss_150sim + w * pred_topolink_mw_bliss$synergy_prob_prolif_150sim) res = pr.curve(scores.class0 = pred_topolink_mw_bliss %&gt;% pull(weighted_prob), weights.class0 = pred_topolink_mw_bliss %&gt;% pull(observed)) auc_value = res$auc.davis.goadrich }) df_mw = as_tibble(cbind(weights, prolif_roc_mw, prolif_pr_mw)) df_mw = df_mw %&gt;% tidyr::pivot_longer(-weights, names_to = &quot;type&quot;, values_to = &quot;AUC&quot;) ggline(data = df_mw, x = &quot;weights&quot;, y = &quot;AUC&quot;, numeric.x.axis = TRUE, color = &quot;type&quot;, plot_type = &quot;l&quot;, xlab = TeX(&quot;weight $w$&quot;), ylab = &quot;AUC (Area Under Curve)&quot;, legend = &quot;none&quot;, facet.by = &quot;type&quot;, palette = my_palette, panel.labs = list(type = c(&quot;PR: (1-w) x prob(ss) + w x prob(prolif)&quot;, &quot;ROC: (1-w) x prob(ss) + w x prob(prolif)&quot;)), title.position = &quot;center&quot;, title = TeX(&quot;AUC sensitivity to weighted average score (Bliss, CASCADE 2.0)&quot;)) + theme(plot.title = element_text(hjust = 0.5)) + grids() Figure 44: AUC sensitivity (CASCADE 2.0, Link Operator and Topology Mutations, Bliss synergy method, Model-wise results) No added benefit when using the model-wise approach. The proliferative models can be used to normalize against the predictions of the calibrated models and thus bring significant contribution to the calibrated models performance (both ROC-AUC and PR-AUC are increased). The \\(\\beta_{best}\\) values of the combined calibrated and proliferative model predictor that maximize the ROC-AUC and PR-AUC respectively are \\(\\beta_{best}^{\\text{ROC-AUC}}=-1.1\\) and \\(\\beta_{best}^{\\text{PR-AUC}}=-1.3\\). For \\(\\beta=-1\\) we still see significant performance improvement. Best ROC and PRC For both the Bliss and HSA ensemble-wise results we demonstrated above that a value of \\(\\beta_{best}=-1\\) can result in significant performance gain of the combined predictor (\\(calibrated + \\beta \\times proliferative\\)). So, the best ROC and PR curves we can get with our simulations when using models with both link operator (balance) and topology mutations are: best_beta = -1 pred_topolink_ew_hsa = pred_topolink_ew_hsa %&gt;% mutate(best_score = ss_score_150sim + best_beta * prolif_score_150sim) pred_topolink_ew_bliss = pred_topolink_ew_bliss %&gt;% mutate(best_score = ss_score_150sim + best_beta * prolif_score_150sim) roc_best_res_hsa = get_roc_stats(df = pred_topolink_ew_hsa, pred_col = &quot;best_score&quot;, label_col = &quot;observed&quot;) roc_best_res_bliss = get_roc_stats(df = pred_topolink_ew_bliss, pred_col = &quot;best_score&quot;, label_col = &quot;observed&quot;) pr_best_res_hsa = pr.curve(scores.class0 = pred_topolink_ew_hsa %&gt;% pull(best_score) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_hsa %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) pr_best_res_bliss = pr.curve(scores.class0 = pred_topolink_ew_bliss %&gt;% pull(best_score) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_bliss %&gt;% pull(observed), curve = TRUE) # Plot best ROCs plot(x = roc_best_res_hsa$roc_stats$FPR, y = roc_best_res_hsa$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = TeX(&#39;ROC curve (Ensemble-wise), $calibrated + \\\\beta \\\\times proliferative$&#39;), xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = roc_best_res_bliss$roc_stats$FPR, y = roc_best_res_bliss$roc_stats$TPR, lwd = 3, col = my_palette[2]) legend(&#39;bottomright&#39;, title = TeX(&#39;AUC ($\\\\beta$ = -1)&#39;), col = c(my_palette[1:2]), pch = 19, legend = c(paste(round(roc_best_res_hsa$AUC, digits = 2), &#39;HSA (150 sim)&#39;), paste(round(roc_best_res_bliss$AUC, digits = 2), &#39;Bliss (150 sim)&#39;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) # Plot best PRCs plot(pr_best_res_hsa, main = TeX(&#39;PR curve (Ensemble-wise), $calibrated + \\\\beta \\\\times proliferative$&#39;), auc.main = FALSE, color = my_palette[1], rand.plot = TRUE) plot(pr_best_res_bliss, add = TRUE, color = my_palette[2]) legend(&#39;topright&#39;, title = TeX(&#39;AUC ($\\\\beta$ = -1)&#39;), col = c(my_palette[1:2]), pch = 19, legend = c(paste(round(pr_best_res_hsa$auc.davis.goadrich, digits = 2), &#39;HSA (150 sim)&#39;), paste(round(pr_best_res_bliss$auc.davis.goadrich, digits = 2), &#39;Bliss (150 sim)&#39;))) grid(lwd = 0.5) Figure 45: ROC and PR curve for best beta (CASCADE 2.0, Link Operator and Topology Mutations) "],
["parameterization-performance-comparison.html", "Parameterization Performance Comparison", " Parameterization Performance Comparison In this section we will compare the best combined predictors (\\(calibrated + \\beta \\times proliferative\\)) across all 3 model parameterizations/mutations we tested in this report for CASCADE 2.0: link operator mutations, topology mutations and both. We use the normalization parameter \\(\\beta=-1\\) for all combined predictors, as it was observed throughout the report that it maximizes the performance of all Bliss-assessed, ensemble-wise combined synergy predictors. Why call \\(\\beta\\) a normalization parameter? What matters for the calculation of the ROC and PR points is the ranking of the synergy scores. Thus if we bring the predictor’s synergy scores to the exponential space, a value of \\(-1\\) for \\(\\beta\\) translates to a simple fold-change normalization technique: \\(calibrated + \\beta \\times proliferative \\overset{\\beta = -1}{=} calibrated - proliferative \\xrightarrow[\\text{same ranking}]{e(x) \\text{ monotonous}}\\) \\(exp(calibrated - proliferative)=exp(calibrated)/exp(proliferative)\\). # Link operator mutations results (`best_score2` has the results for β = -1, `best_score1` for β = -1.6) roc_link_res = get_roc_stats(df = pred_ew_bliss, pred_col = &quot;best_score2&quot;, label_col = &quot;observed&quot;) pr_link_res = pr.curve(scores.class0 = pred_ew_bliss %&gt;% pull(best_score2) %&gt;% (function(x) {-x}), weights.class0 = pred_ew_bliss %&gt;% pull(observed), curve = TRUE, rand.compute = TRUE) # Topology mutations results roc_topo_res = get_roc_stats(df = pred_topo_ew_bliss, pred_col = &quot;best_score&quot;, label_col = &quot;observed&quot;) pr_topo_res = pr.curve(scores.class0 = pred_topo_ew_bliss %&gt;% pull(best_score) %&gt;% (function(x) {-x}), weights.class0 = pred_topo_ew_bliss %&gt;% pull(observed), curve = TRUE) # Both Link Operator and Topology mutations results roc_topolink_res = get_roc_stats(df = pred_topolink_ew_bliss, pred_col = &quot;best_score&quot;, label_col = &quot;observed&quot;) pr_topolink_res = pr.curve(scores.class0 = pred_topolink_ew_bliss %&gt;% pull(best_score) %&gt;% (function(x) {-x}), weights.class0 = pred_topolink_ew_bliss %&gt;% pull(observed), curve = TRUE) # Plot best ROCs plot(x = roc_link_res$roc_stats$FPR, y = roc_link_res$roc_stats$TPR, type = &#39;l&#39;, lwd = 3, col = my_palette[1], main = TeX(&#39;ROC curves (Ensemble-wise), $calibrated + \\\\beta \\\\times proliferative$&#39;), xlab = &#39;False Positive Rate (FPR)&#39;, ylab = &#39;True Positive Rate (TPR)&#39;) lines(x = roc_topo_res$roc_stats$FPR, y = roc_topo_res$roc_stats$TPR, lwd = 2, col = my_palette[2]) lines(x = roc_topolink_res$roc_stats$FPR, y = roc_topolink_res$roc_stats$TPR, lwd = 2.3, col = my_palette[3]) legend(&#39;bottomright&#39;, title = TeX(&#39;AUC ($\\\\beta$ = -1)&#39;), col = c(my_palette[1:3]), pch = 19, legend = c(paste(round(roc_link_res$AUC, digits = 2), &#39;Link Operator Mutations&#39;), paste(round(roc_topo_res$AUC, digits = 2), &#39;Topology Mutations&#39;), paste(round(roc_topolink_res$AUC, digits = 2), &#39;Both Mutations&#39;))) grid(lwd = 0.5) abline(a = 0, b = 1, col = &#39;lightgrey&#39;, lty = &#39;dotdash&#39;, lwd = 1.2) # Plot best PRCs plot(pr_link_res, main = TeX(&#39;PR curves (Ensemble-wise), $calibrated + \\\\beta \\\\times proliferative$&#39;), auc.main = FALSE, color = my_palette[1], rand.plot = TRUE, lwd = 3) plot(pr_topo_res, add = TRUE, color = my_palette[2], lwd = 2) plot(pr_topolink_res, add = TRUE, color = my_palette[3], lwd = 2.3) legend(&#39;topright&#39;, title = TeX(&#39;AUC ($\\\\beta$ = -1)&#39;), col = c(my_palette[1:3]), pch = 19, legend = c(paste(round(pr_link_res$auc.davis.goadrich, digits = 2), &#39;Link Operator Mutations&#39;), paste(round(pr_topo_res$auc.davis.goadrich, digits = 2), &#39;Topology Mutations&#39;), paste(round(pr_topolink_res$auc.davis.goadrich, digits = 2), &#39; Both Mutations&#39;))) grid(lwd = 0.5) Figure 46: Comparing ROC and PR curves for combined predictors across 3 parameterization schemes (CASCADE 2.0, Bliss synergy method, Ensemble-wise results) We observe that if we had used the results for the link operator only combined predictor with \\(\\beta_{best}=-1.6\\) as was demonstrated here, we would have an AUC-ROC of \\(0.85\\) and AUC-PR of \\(0.27\\), which are pretty close to the results we see above for \\(\\beta=-1\\), using both link and topology mutations. Overall, this suggests that parameterizing our boolean models using topology mutations can increase the performance of our proposed synergy prediction approach much more than using either link operator (balance) mutations alone or combined with topology parameterization. Note that the difference in terms of ROC AUC is not significant compared to the difference of PR AUC scores and since the dataset we test our models on is fairly imbalanced, we base our conclusion on the information from the PR plots (Saito and Rehmsmeier 2015). "],
["reproduce-simulation-results.html", "Reproduce simulation results Get output files Repo results structure Random model results", " Reproduce simulation results Get output files Use the druglogics-synergy module, version 1.2.0: git checkout v1.2.0 Run the script run_druglogics_synergy.sh in the above repo. You can of course change several other parameters in the input files or the script itself (e.g. number of simulations to run, for a complete list of configuration options, see here). To get the results for the topology mutations for CASCADE 2.0 you need to change the ags_cascade_2.0/config file option topology_mutations: 10 (it is \\(0\\) by default - no topology mutations, only link-operator/balance mutations). If you wish to get the results from both mutations, set both balance_mutations and topology_mutations options to a non-zero value (\\(3\\) and \\(10\\) were used in the simulations). Each druglogics-synergy execution results in an output directory and the files of interest (which are used to produce the ROC and PR curves in this report among other figures) are the modelwise_synergies.tab and the ensemble_synergies.tab respectively. For the fitness evolution figures we used the summary.txt file of the corresponding simulations. Repo results structure We have gathered all the necessary output files from the above simulations to the directory results for ease of use in our report. The results directory has 3 sub-directories: link-only: results from the link-operator mutated models only (used in the sections Cascade 1.0 Analysis and CASCADE 2.0 Analysis (Link Operator Mutations)) topology-only: results from the topology-mutated models only (used in the section CASCADE 2.0 Analysis (Topology Mutations)) topo-and-link: results where both mutations applied to the generated boolean models (used in section CASCADE 2.0 Analysis (Topology and Link Operator Mutations)) Because the simulation results using only link operator mutations were substantially more (both CASCADE 1.0 and CASCADE 2.0 networks were tested and for various number of simulations) than the others using topology or both kind of mutations, we splitted the link-only-mutations results to 2 directories (hsa and bliss) having the results from the different synergy assessment methods (check Drabme’s synergy_method configuration option). Random model results Use the druglogics-synergy module, version 1.2.0: git checkout v1.2.0 and the abmlog module, version 1.5.0: git checkout v1.5.0. The CASCADE 1.0 and 2.0 .sif network files can be found at the directories ags_cascade_1.0 and ags_cascade_2.0 on the druglogics-synergy repository. Copy these two network files inside the test dir of the abmlog repository root. Run the abmlog for the CASCADE 2.0 topology: java -cp target/abmlog-1.5.0-jar-with-dependencies.jar eu.druglogics.abmlog.RandomBooleanModelGenerator --file=test/cascade_2_0.sif --num=3000 Next, prune the resulting models to only the ones that have 1 stable state (should be \\(1292\\)) using the simple bash script process_models.sh inside the generated models directory from abmlog. cd pathTo/druglogics-synergy/ags_cascade_2.0 Move the abmlog-generated models dir inside the ags_cascade_2.0 dir Use attractor_tool: biolqm_stable_states in the config file Use synergy_method: hsa or synergy_method: bliss in the config file (run twice below command, changing the project to cascade_2.0_random_bliss) Run Drabme via druglogics-synergy: cd ags_cascade_2.0/ java -cp ../target/synergy-1.2.0-jar-with-dependencies.jar eu.druglogics.drabme.Launcher --project=cascade_2.0_random_hsa --modelsDir=models --drugs=drugpanel --perturbations=perturbations --config=config --modeloutputs=modeloutputs The above procedure is the same for CASCADE 1.0. Changes: The number of models after pruning to those that have only 1 stable state should be \\(950\\) The abmlog-generated models directory should be put inside the ags_cascade_1.0 of druglogics-synergy The network file is now for the CASCADE 1.0 (network.sif inside the ags_cascade_1.0) The Drabme command should be run with --project=cascade_1.0_random_hsa and --project=cascade_1.0_random_bliss respectively "],
["r-session-info.html", "R session info", " R session info xfun::session_info() R version 3.6.3 (2020-02-29) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 18.04.4 LTS Locale: LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 LC_PAPER=en_US.UTF-8 LC_NAME=C LC_ADDRESS=C LC_TELEPHONE=C LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C Package version: abind_1.4-5 assertthat_0.2.1 backports_1.1.8 base64enc_0.1.3 BH_1.72.0.3 bibtex_0.4.2.2 bookdown_0.20 boot_1.3.25 broom_0.5.6 callr_3.4.3 car_3.0-8 carData_3.0-4 cellranger_1.1.0 Ckmeans.1d.dp_4.3.2 cli_2.0.2 clipr_0.7.0 codetools_0.2-16 colorspace_1.4-1 compiler_3.6.3 corrplot_0.84 cowplot_1.0.0 crayon_1.3.4 crosstalk_1.1.0.1 curl_4.3 data.table_1.12.8 desc_1.2.0 digest_0.6.25 dplyr_1.0.0 DT_0.14 ellipsis_0.3.1 emba_0.1.5 equatiomatic_0.0.0.9000 evaluate_0.14 fansi_0.4.1 farver_2.0.3 forcats_0.5.0 foreach_1.5.0 foreign_0.8-75 gbRd_0.4-11 generics_0.0.2 ggplot2_3.3.2 ggpubr_0.4.0 ggrepel_0.8.2 ggsci_2.9 ggsignif_0.6.0 glmnet_4.0-2 glue_1.4.1 graphics_3.6.3 grDevices_3.6.3 grid_3.6.3 gridExtra_2.3 gtable_0.3.0 haven_2.3.1 highr_0.8 hms_0.5.3 htmltools_0.5.0 htmlwidgets_1.5.1 igraph_1.2.5 isoband_0.2.2 iterators_1.0.12 jsonlite_1.7.0 knitr_1.29 labeling_0.3 later_1.1.0.1 latex2exp_0.4.0 lattice_0.20-41 lazyeval_0.2.2 lifecycle_0.2.0 lme4_1.1.23 magrittr_1.5 MAMSE_0.2-1 maptools_1.0.1 markdown_1.1 MASS_7.3.51.6 Matrix_1.2-18 MatrixModels_0.4.1 methods_3.6.3 mgcv_1.8.31 mime_0.9 minqa_1.2.4 munsell_0.5.0 nlme_3.1-148 nloptr_1.2.2.1 nnet_7.3.14 openxlsx_4.1.5 parallel_3.6.3 pbkrtest_0.4.8.6 pillar_1.4.4 pkgbuild_1.0.8 pkgconfig_2.0.3 pkgload_1.1.0 plyr_1.8.6 polynom_1.4.0 praise_1.0.0 prettyunits_1.1.1 processx_3.4.2 progress_1.2.2 promises_1.1.1 PRROC_1.3.1 ps_1.3.3 purrr_0.3.4 quantreg_5.55 R6_2.4.1 RColorBrewer_1.1-2 Rcpp_1.0.4.6 RcppEigen_0.3.3.7.0 Rdpack_1.0.0 readr_1.3.1 readxl_1.3.1 rematch_1.0.1 reshape2_1.4.4 rio_0.5.16 rje_1.10.16 rlang_0.4.6 rmarkdown_2.3 rprojroot_1.3.2 rstatix_0.6.0 rstudioapi_0.11 scales_1.1.1 shape_1.4.4 sp_1.4.2 SparseM_1.78 splines_3.6.3 statmod_1.4.34 stats_3.6.3 stringi_1.4.6 stringr_1.4.0 survival_3.2-3 testthat_2.3.2 tibble_3.0.1 tidyr_1.1.0 tidyselect_1.1.0 tinytex_0.24 tools_3.6.3 usefun_0.4.7 utf8_1.1.4 utils_3.6.3 vctrs_0.3.1 viridisLite_0.3.0 visNetwork_2.0.9 withr_2.2.0 xfun_0.15 yaml_2.2.1 zip_2.0.4 "],
["references.html", "References", " References Flobak, Åsmund, Anaïs Baudot, Elisabeth Remy, Liv Thommesen, Denis Thieffry, Martin Kuiper, and Astrid Lægreid. 2015. “Discovery of Drug Synergies in Gastric Cancer Cells Predicted by Logical Modeling.” Edited by Ioannis Xenarios. PLOS Computational Biology 11 (8): e1004426. https://doi.org/10.1371/journal.pcbi.1004426. Flobak, Åsmund, Barbara Niederdorfer, Vu To Nakstad, Liv Thommesen, Geir Klinkenberg, and Astrid Lægreid. 2019. “A high-throughput drug combination screen of targeted small molecule inhibitors in cancer cell lines.” Scientific Data 6 (1): 237. https://doi.org/10.1038/s41597-019-0255-7. Friedman, Jerome, Trevor Hastie, Rob Tibshirani, Balasubramanian Narasimhan, Kenneth Tay, and Noah Simon. 2020. Glmnet: Lasso and Elastic-Net Regularized Generalized Linear Models. https://CRAN.R-project.org/package=glmnet. Grau, Jan, Ivo Grosse, and Jens Keilwagen. 2015. “PRROC: computing and visualizing precision-recall and receiver operating characteristic curves in R.” Bioinformatics 31 (15): 2595–7. https://doi.org/10.1093/bioinformatics/btv153. Grau, Jan, and Jens Keilwagen. 2018. PRROC: Precision-Recall and Roc Curves for Weighted and Unweighted Data. https://CRAN.R-project.org/package=PRROC. Holland, John Henry. 1992. Adaptation in Natural and Artificial Systems: An Introductory Analysis with Applications to Biology, Control, and Artificial Intelligence. MIT press. Pepe, M. S. 2000. “Combining diagnostic test results to increase accuracy.” Biostatistics 1 (2): 123–40. https://doi.org/10.1093/biostatistics/1.2.123. Plante, Jean-Francois. 2017. MAMSE: Calculation of Minimum Averaged Mean Squared Error (Mamse) Weights. https://CRAN.R-project.org/package=MAMSE. Saito, Takaya, and Marc Rehmsmeier. 2015. “The Precision-Recall Plot Is More Informative than the ROC Plot When Evaluating Binary Classifiers on Imbalanced Datasets.” Edited by Guy Brock. PLOS ONE 10 (3): e0118432. https://doi.org/10.1371/journal.pone.0118432. Zobolas, John. 2020a. Rtemps: R Templates for Reproducible Data Analyses. https://github.com/bblodfon/rtemps. ———. 2020b. Usefun: A Collection of Useful Functions by John. https://github.com/bblodfon/usefun. "]
]
